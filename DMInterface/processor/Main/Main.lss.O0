
Main.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .vector_table 00000190  00000000  00000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .boot_code    00000320  00000190  00000190  00001190  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0000b630  000004b0  000004b0  000014b0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .ARM.exidx    00000008  0000bae0  0000bae0  0000cae0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .data         000000b0  20000000  0000baf0  0000d000  2**4
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          000046d0  200000b0  0000bba0  0000d0b0  2**4
                  ALLOC
  6 .heap         0000a880  20004780  0000bba0  0000d780  2**4
                  ALLOC
  7 .stack        00001000  2000f000  0000bba0  0000e000  2**4
                  ALLOC
  8 .debug_aranges 00000798  00000000  00000000  0000d0b0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_info   000194fd  00000000  00000000  0000d848  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_abbrev 000030e5  00000000  00000000  00026d45  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_line   000070f5  00000000  00000000  00029e2a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_frame  00001c94  00000000  00000000  00030f20  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_str    0000c632  00000000  00000000  00032bb4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .comment      00000039  00000000  00000000  0003f1e6  2**0
                  CONTENTS, READONLY
 15 .ARM.attributes 00000029  00000000  00000000  0003f21f  2**0
                  CONTENTS, READONLY
 16 .debug_rnglists 0000066c  00000000  00000000  0003f248  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line_str 00000141  00000000  00000000  0003f8b4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_loclists 00000b07  00000000  00000000  0003f9f5  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .vector_table:

00000000 <g_pfnVectors>:
#define FREQ_1MHZ    1000000u
#define FREQ_25MHZ   25000000u
#define FREQ_50MHZ   50000000u

void SystemCoreClockUpdate(void)
{
   0:	00 00 01 20 91 01 00 00 7f 03 00 00 f1 04 00 00     ... ............
    uint32_t controller_pll_init;
    uint32_t clk_src;

    controller_pll_init = SYSREG->MSSDDR_FACC1_CR & CONTROLLER_PLL_INIT_MASK;
  10:	83 03 00 00 03 05 00 00 15 05 00 00 00 00 00 00     ................
	...

        global_mux_sel = SYSREG->MSSDDR_FACC1_CR & FACC_GLMUX_SEL_MASK;
        if(0u == global_mux_sel)
        {
            /* MSS clocked from MSS PLL. Use Libero flow defines. */
            SystemCoreClock = MSS_SYS_M3_CLK_FREQ;
  2c:	89 03 00 00 8b 03 00 00 00 00 00 00 8d 03 00 00     ................
            g_FrequencyPCLK0 = MSS_SYS_APB_0_CLK_FREQ;
            g_FrequencyPCLK1 = MSS_SYS_APB_1_CLK_FREQ;
            g_FrequencyPCLK2 = MSS_SYS_APB_2_CLK_FREQ;
  3c:	8f 03 00 00 91 03 00 00 93 03 00 00 95 03 00 00     ................
            g_FrequencyFIC0 = MSS_SYS_FIC_0_CLK_FREQ;
            g_FrequencyFIC1 = MSS_SYS_FIC_1_CLK_FREQ;
  4c:	97 03 00 00 99 03 00 00 9b 03 00 00 9d 03 00 00     ................
            g_FrequencyFIC64 = MSS_SYS_FIC64_CLK_FREQ;
        }
        else
        {
            /* MSS clocked from standby clock. */
            const uint8_t standby_clock_lut[8] = { RCOSC_25_50MHZ_CLK_SRC,
  5c:	9f 03 00 00 a1 03 00 00 a3 03 00 00 a5 03 00 00     ................
                                                   CCC2ASCI_CLK_SRC };

            uint32_t standby_sel;
            uint8_t clock_source;

            standby_sel = (SYSREG->MSSDDR_FACC2_CR >> FACC_STANDBY_SHIFT) & FACC_STANDBY_SEL_MASK;
  6c:	a7 03 00 00 a9 03 00 00 ab 03 00 00 ad 03 00 00     ................
            clock_source = standby_clock_lut[standby_sel];
            switch(clock_source)
  7c:	af 03 00 00 b1 03 00 00 b3 03 00 00 b5 03 00 00     ................
  8c:	b7 03 00 00 b9 03 00 00 bb 03 00 00 bd 03 00 00     ................
                    clk_src = get_rcosc_25_50mhz_frequency();
                    set_clock_frequency_globals(clk_src);
                break;

                case CLK_XTAL_CLK_SRC:
                    set_clock_frequency_globals(FREQ_32KHZ);
  9c:	bf 03 00 00 c1 03 00 00 c3 03 00 00 c5 03 00 00     ................
                break;

                case RCOSC_1_MHZ_CLK_SRC:
                    set_clock_frequency_globals(FREQ_1MHZ);
                break;
  ac:	c7 03 00 00 c9 03 00 00 cb 03 00 00 cd 03 00 00     ................
    }
    else
    {
        /* PLL initialization mode. Running from 25/50MHZ RC oscillator. */
        clk_src = get_rcosc_25_50mhz_frequency();
        set_clock_frequency_globals(clk_src);
  bc:	cf 03 00 00 d1 03 00 00 d3 03 00 00 d5 03 00 00     ................
    }
}
  cc:	d7 03 00 00 d9 03 00 00 db 03 00 00 dd 03 00 00     ................
  dc:	df 03 00 00 e1 03 00 00 e3 03 00 00 e5 03 00 00     ................
  ec:	e7 03 00 00 e9 03 00 00 eb 03 00 00 ed 03 00 00     ................
  fc:	ef 03 00 00 f1 03 00 00 f3 03 00 00 f5 03 00 00     ................
 10c:	f7 03 00 00 f9 03 00 00 fb 03 00 00 fd 03 00 00     ................
 11c:	ff 03 00 00 01 04 00 00 03 04 00 00 05 04 00 00     ................
 12c:	07 04 00 00 09 04 00 00 0b 04 00 00 0d 04 00 00     ................
 13c:	0f 04 00 00 11 04 00 00 13 04 00 00 15 04 00 00     ................
 14c:	17 04 00 00 19 04 00 00 1b 04 00 00 1d 04 00 00     ................
 15c:	1f 04 00 00 21 04 00 00 23 04 00 00 25 04 00 00     ....!...#...%...
 16c:	27 04 00 00 29 04 00 00 2b 04 00 00 2d 04 00 00     '...)...+...-...
 17c:	2f 04 00 00 31 04 00 00 33 04 00 00 00 00 00 00     /...1...3.......
 18c:	00 00 00 00                                         ....

Disassembly of section .boot_code:

00000190 <Reset_Handler>:
 * cannot be located in MDDR since MDDR is not available at this point.
 * The bits of the content of register r11 have the following meaning:
 *  reg11[0]: eSRAM EDAC enabled
 *  reg11[1]: MDDR ECC/SECDED enabled
 */
    mov r11, #0
 190:	f04f 0b00 	mov.w	fp, #0
    ldr r0, SF2_MDDR_MODE_CR
 194:	f8df 02be 	ldr.w	r0, [pc, #702]	@ 456 <SF2_MDDR_MODE_CR>
    ldr r0, [r0]
 198:	6800      	ldr	r0, [r0, #0]
    ldr r1, SF2_EDAC_CR
 19a:	f8df 12b6 	ldr.w	r1, [pc, #694]	@ 452 <SF2_EDAC_CR>
    ldr r1, [r1]
 19e:	6809      	ldr	r1, [r1, #0]
    and r1, r1, #3
 1a0:	f001 0103 	and.w	r1, r1, #3
    and r0, r0, #0x1C
 1a4:	f000 001c 	and.w	r0, r0, #28
    cmp r0, #0x14
 1a8:	2814      	cmp	r0, #20
    bne check_esram_edac
 1aa:	d101      	bne.n	1b0 <check_esram_edac>
    orr r11, r11, #2
 1ac:	f04b 0b02 	orr.w	fp, fp, #2

000001b0 <check_esram_edac>:
check_esram_edac:
    cmp r1, #0
 1b0:	2900      	cmp	r1, #0
    beq check_stack_init
 1b2:	d001      	beq.n	1b8 <check_stack_init>
    orr r11, r11, #1
 1b4:	f04b 0b01 	orr.w	fp, fp, #1

000001b8 <check_stack_init>:
check_stack_init:
    cmp r11, #0
 1b8:	f1bb 0f00 	cmp.w	fp, #0
    beq system_init
 1bc:	d005      	beq.n	1ca <system_init>

000001be <clear_stack>:
clear_stack:
    ldr r0, = __stack_start__
 1be:	48a7      	ldr	r0, [pc, #668]	@ (45c <SF2_MDDR_MODE_CR+0x6>)
    ldr r1, =_estack
 1c0:	49a7      	ldr	r1, [pc, #668]	@ (460 <SF2_MDDR_MODE_CR+0xa>)
    ldr r2, RAM_INIT_PATTERN
 1c2:	f8df 2272 	ldr.w	r2, [pc, #626]	@ 436 <RAM_INIT_PATTERN>
    bl fill_memory                      /* ; fill_memory takes r0 - r2 as arguments uses r4, r5, r6, r7, r8, r9, and does not preserve contents */
 1c6:	f000 f89f 	bl	308 <fill_memory>

000001ca <system_init>:
    
/*------------------------------------------------------------------------------
 * Call CMSIS system init function.
 */
 system_init:
    ldr r0, =SystemInit
 1ca:	48a6      	ldr	r0, [pc, #664]	@ (464 <SF2_MDDR_MODE_CR+0xe>)
    blx r0
 1cc:	4780      	blx	r0

/*------------------------------------------------------------------------------
 * Modify MDDR configuration if ECC/SECDED is enabled for MDDR.
 * Enable write combining on MDDR bridge, disable non-bufferable regions.
 */
    and r10, r11, 0x2
 1ce:	f00b 0a02 	and.w	sl, fp, #2
    cmp r10, #0
 1d2:	f1ba 0f00 	cmp.w	sl, #0
    beq remap_memory
 1d6:	d00c      	beq.n	1f2 <remap_memory>
    ldr r0, SF2_DDRB_NB_SIZE
 1d8:	f8df 026e 	ldr.w	r0, [pc, #622]	@ 44a <SF2_DDRB_NB_SIZE>
    ldr r1, SF2_DDRB_CR
 1dc:	f8df 126e 	ldr.w	r1, [pc, #622]	@ 44e <SF2_DDRB_CR>
    ldr r2, [r0]
 1e0:	6802      	ldr	r2, [r0, #0]
    ldr r3, [r1]
 1e2:	680b      	ldr	r3, [r1, #0]
    push {r0, r1, r2, r3}
 1e4:	b40f      	push	{r0, r1, r2, r3}
    mov r2, #0
 1e6:	f04f 0200 	mov.w	r2, #0
    mov r3, #0xFF
 1ea:	f04f 03ff 	mov.w	r3, #255	@ 0xff
    str r2, [r0]
 1ee:	6002      	str	r2, [r0, #0]
    str r3, [r1]
 1f0:	600b      	str	r3, [r1, #0]

000001f2 <remap_memory>:
/*------------------------------------------------------------------------------
 * Perform memory remapping based on the value of __smartfusion2_memory_remap
 * set in the linker script.
 */
remap_memory:
    ldr r0, =__smartfusion2_memory_remap
 1f2:	489d      	ldr	r0, [pc, #628]	@ (468 <SF2_MDDR_MODE_CR+0x12>)
    ldr r2, =0
 1f4:	f04f 0200 	mov.w	r2, #0
    ldr r3, =1
 1f8:	f04f 0301 	mov.w	r3, #1
    cmp r0, #2
 1fc:	2802      	cmp	r0, #2
    bne check_esram_remap
 1fe:	d108      	bne.n	212 <check_esram_remap>
    /*
     * Remap external RAM to address 0x00000000
     */
    ldr r1, SF2_ESRAM_CR
 200:	f8df 123a 	ldr.w	r1, [pc, #570]	@ 43e <SF2_ESRAM_CR>
    str r2, [r1]
 204:	600a      	str	r2, [r1, #0]
    ldr r1, SF2_ENVM_REMAP_CR
 206:	f8df 123e 	ldr.w	r1, [pc, #574]	@ 446 <SF2_ENVM_REMAP_CR>
    str r2, [r1]
 20a:	600a      	str	r2, [r1, #0]
    ldr r1, SF2_DDR_CR
 20c:	f8df 1232 	ldr.w	r1, [pc, #562]	@ 442 <SF2_DDR_CR>
    str r3, [r1]
 210:	600b      	str	r3, [r1, #0]

00000212 <check_esram_remap>:
check_esram_remap:
    cmp r0, #1
 212:	2801      	cmp	r0, #1
    bne check_mirrored_nvm
 214:	d108      	bne.n	228 <check_mirrored_nvm>
    /*
     * Remap internal eSRAM to address 0x00000000
     */
    ldr r1, SF2_DDR_CR
 216:	f8df 122a 	ldr.w	r1, [pc, #554]	@ 442 <SF2_DDR_CR>
    str r2, [r1]
 21a:	600a      	str	r2, [r1, #0]
    ldr r1, SF2_ENVM_REMAP_CR
 21c:	f8df 1226 	ldr.w	r1, [pc, #550]	@ 446 <SF2_ENVM_REMAP_CR>
    str r2, [r1]
 220:	600a      	str	r2, [r1, #0]
    ldr r1, SF2_ESRAM_CR
 222:	f8df 121a 	ldr.w	r1, [pc, #538]	@ 43e <SF2_ESRAM_CR>
    str r3, [r1]
 226:	600b      	str	r3, [r1, #0]

00000228 <check_mirrored_nvm>:
 * This is done for debugging executables running out of eNVM with SoftConsole.
 * The .text section should not be copied in this case since both the LMA and
 * VMA point at the eNVM despite the LMA and VMa having different values.
 */
 check_mirrored_nvm:
    ldr r0, =__mirrored_nvm
 228:	4890      	ldr	r0, [pc, #576]	@ (46c <SF2_MDDR_MODE_CR+0x16>)
    cmp r0, #0
 22a:	2800      	cmp	r0, #0
    bne copy_data
 22c:	d109      	bne.n	242 <copy_data>
    
/*------------------------------------------------------------------------------
 * Copy vector table.
 */
    ldr r0, =__vector_table_load
 22e:	4890      	ldr	r0, [pc, #576]	@ (470 <SF2_MDDR_MODE_CR+0x1a>)
    ldr r1, =__vector_table_start
 230:	4990      	ldr	r1, [pc, #576]	@ (474 <SF2_MDDR_MODE_CR+0x1e>)
    ldr r2, =_evector_table
 232:	4a91      	ldr	r2, [pc, #580]	@ (478 <SF2_MDDR_MODE_CR+0x22>)
    bl block_copy
 234:	f000 f830 	bl	298 <block_copy>

00000238 <copy_text>:
    
/*------------------------------------------------------------------------------
 * Copy code section.
 */
copy_text:
    ldr r0, =__text_load
 238:	4890      	ldr	r0, [pc, #576]	@ (47c <SF2_MDDR_MODE_CR+0x26>)
    ldr r1, =__text_start
 23a:	4991      	ldr	r1, [pc, #580]	@ (480 <SF2_MDDR_MODE_CR+0x2a>)
    ldr r2, =_etext
 23c:	4a91      	ldr	r2, [pc, #580]	@ (484 <SF2_MDDR_MODE_CR+0x2e>)
    bl block_copy
 23e:	f000 f82b 	bl	298 <block_copy>

00000242 <copy_data>:
/*------------------------------------------------------------------------------
 * Copy data section.
 */

 copy_data:
    ldr r0, =__data_load
 242:	4891      	ldr	r0, [pc, #580]	@ (488 <SF2_MDDR_MODE_CR+0x32>)
    ldr r1, =__data_start
 244:	4991      	ldr	r1, [pc, #580]	@ (48c <SF2_MDDR_MODE_CR+0x36>)
    ldr r2, =_edata
 246:	4a92      	ldr	r2, [pc, #584]	@ (490 <SF2_MDDR_MODE_CR+0x3a>)
    bl block_copy
 248:	f000 f826 	bl	298 <block_copy>

0000024c <clear_bss>:
    
/*------------------------------------------------------------------------------
 *  Clear .bss
 */
clear_bss:                               
    ldr r0, =__bss_start__
 24c:	4891      	ldr	r0, [pc, #580]	@ (494 <SF2_MDDR_MODE_CR+0x3e>)
    ldr r1, =__bss_end__
 24e:	4992      	ldr	r1, [pc, #584]	@ (498 <SF2_MDDR_MODE_CR+0x42>)
    ldr r2, RAM_INIT_PATTERN
 250:	f8df 21e2 	ldr.w	r2, [pc, #482]	@ 436 <RAM_INIT_PATTERN>
    bl fill_memory                      /* ; fill_memory takes r0 - r2 as arguments uses r4, r5, r6, r7, r8, r9, and does not preserve contents */
 254:	f000 f858 	bl	308 <fill_memory>

00000258 <clear_heap>:
 * (EDAC). We use the decision made earlier in the startup code of whether or
 * not the stack RAM should be initialized. This decision is held in register
 * r11. A non-zero value indicates that the RAM content should be initialized.
 */
clear_heap:
    cmp r11, #0
 258:	f1bb 0f00 	cmp.w	fp, #0
    beq call_glob_ctor
 25c:	d010      	beq.n	280 <call_glob_ctor>
    ldr r0, =__heap_start__
 25e:	488f      	ldr	r0, [pc, #572]	@ (49c <SF2_MDDR_MODE_CR+0x46>)
    ldr r1, =_eheap
 260:	498f      	ldr	r1, [pc, #572]	@ (4a0 <SF2_MDDR_MODE_CR+0x4a>)
    ldr r2, HEAP_INIT_PATTERN
 262:	f8df 21d6 	ldr.w	r2, [pc, #470]	@ 43a <HEAP_INIT_PATTERN>
	bl fill_memory                      /* ; fill_memory takes r0 - r2 as arguments uses r4, r5, r6, r7, r8, r9, and does not preserve contents */
 266:	f000 f84f 	bl	308 <fill_memory>

/*------------------------------------------------------------------------------
 * Restore MDDR configuration.
 */
    and r10, r11, 0x2
 26a:	f00b 0a02 	and.w	sl, fp, #2
    cmp r10, #0
 26e:	f1ba 0f00 	cmp.w	sl, #0
    beq call_glob_ctor
 272:	d005      	beq.n	280 <call_glob_ctor>
    pop {r0, r1, r2, r3}
 274:	bc0f      	pop	{r0, r1, r2, r3}
    str r2, [r0]
 276:	6002      	str	r2, [r0, #0]
    str r3, [r1]
 278:	600b      	str	r3, [r1, #0]
 27a:	bf00      	nop
 27c:	f3af 8000 	nop.w

00000280 <call_glob_ctor>:
     * Align to word and use 32-bits LDR instruction to ensure the ADD instruction
     * taking PC as argument is aligned on a word boundary.
     */
    .align 4
call_glob_ctor:
    ldr.w r0, =__libc_init_array
 280:	f8df 0220 	ldr.w	r0, [pc, #544]	@ 4a4 <SF2_MDDR_MODE_CR+0x4e>
    add lr, pc, #3
 284:	f20f 0e03 	addw	lr, pc, #3
    bx r0
 288:	4700      	bx	r0

0000028a <branch_to_main>:
    
/*------------------------------------------------------------------------------
 * branch to main.
 */
branch_to_main:
    mov r0, #0      /*  ; no arguments  */
 28a:	f04f 0000 	mov.w	r0, #0
    mov r1, #0      /*  ; no argv either */
 28e:	f04f 0100 	mov.w	r1, #0
    ldr pc, =main
 292:	f8df f214 	ldr.w	pc, [pc, #532]	@ 4a8 <SF2_MDDR_MODE_CR+0x52>

00000296 <ExitLoop>:

ExitLoop:
    B ExitLoop
 296:	e7fe      	b.n	296 <ExitLoop>

00000298 <block_copy>:
 * should be used as per example linker scripts.
 * Note 1: If the memory address in r0 or r1, byte copy routine is used
 * Note 2: If r1 < r2, will loop indefinetley to highlight linker issue.
 */
block_copy:
    push {r3, r4, r5, r6, r7, r8, lr}
 298:	e92d 41f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, lr}
    cmp r0, r1
 29c:	4288      	cmp	r0, r1
    beq block_copy_exit          /* ; Exit early if source and destination the same */
 29e:	d025      	beq.n	2ec <block_copy_exit>
    subs.w r2, r2, r1            /* ; Calculate number of bytes to move */
 2a0:	ebb2 0201 	subs.w	r2, r2, r1
    bpl  block_copy_address_ok	 /* ; check (end target address) > (target address) => continue */
 2a4:	d500      	bpl.n	2a8 <block_copy_address_ok>
    b .							 /* ; halt as critical error-  memory map not OK- make it easy to catch in debugger */
 2a6:	e7fe      	b.n	2a6 <block_copy+0xe>

000002a8 <block_copy_address_ok>:
block_copy_address_ok:
    /* ; detect if source or target memory addresses unaligned. If so use byte copy routine */
    orr.w r3, r0, r1
 2a8:	ea40 0301 	orr.w	r3, r0, r1
    ands.w r3, r3, #3
 2ac:	f013 0303 	ands.w	r3, r3, #3
    beq  block_copy_continue
 2b0:	d002      	beq.n	2b8 <block_copy_continue>

000002b2 <block_copy_byte_copy>:
block_copy_byte_copy:
    bl block_copy_byte
 2b2:	f000 f81d 	bl	2f0 <block_copy_byte>
    b  block_copy_exit
 2b6:	e019      	b.n	2ec <block_copy_exit>

000002b8 <block_copy_continue>:
block_copy_continue:
	mov  r3, #0
 2b8:	f04f 0300 	mov.w	r3, #0
	mov  r8,r2                   /* ; Save copy of byte count */
 2bc:	4690      	mov	r8, r2
    asrs r2,r2, #4               /* ; Div by 16 to get number of chunks to move */
 2be:	1112      	asrs	r2, r2, #4
    beq block_copy_byte_copy	 /* ; need to use byte copy if less than 16 bytes */
 2c0:	d0f7      	beq.n	2b2 <block_copy_byte_copy>

000002c2 <block_copy_loop>:
block_copy_loop:
    cmp r2, r3
 2c2:	429a      	cmp	r2, r3
    itt ne
 2c4:	bf1c      	itt	ne
    ldmne r0!, {r4, r5, r6, r7}
 2c6:	c8f0      	ldmiane	r0!, {r4, r5, r6, r7}
    stmne r1!, {r4, r5, r6, r7}
 2c8:	c1f0      	stmiane	r1!, {r4, r5, r6, r7}
    add.w r3, r3, #1			/* ; use Thumb2- make sure condition code reg. not updated */
 2ca:	f103 0301 	add.w	r3, r3, #1
    bne block_copy_loop
 2ce:	d1f8      	bne.n	2c2 <block_copy_loop>
	/* ; copy spare bytes at the end if any */
    and r8, #15					/* ; get spare bytes  --check can you do an ands? 	*/
 2d0:	f008 080f 	and.w	r8, r8, #15
	cmp r8, #0					/* ; no spare bytes at end- end now 	*/
 2d4:	f1b8 0f00 	cmp.w	r8, #0
	beq block_copy_exit
 2d8:	d008      	beq.n	2ec <block_copy_exit>

000002da <copy_spare_bytes>:
copy_spare_bytes:               /* ; From above, R0 contains source address, R1 contains destination address */
	ldrb r4, [r0]
 2da:	7804      	ldrb	r4, [r0, #0]
    strb r4, [r1]
 2dc:	700c      	strb	r4, [r1, #0]
    add  r0, #1
 2de:	f100 0001 	add.w	r0, r0, #1
    add  r1, #1
 2e2:	f101 0101 	add.w	r1, r1, #1
  	subs r8, r8, #1
 2e6:	f1b8 0801 	subs.w	r8, r8, #1
    bne copy_spare_bytes
 2ea:	d1f6      	bne.n	2da <copy_spare_bytes>

000002ec <block_copy_exit>:
block_copy_exit:
    pop {r3, r4, r5, r6, r7, r8, pc}
 2ec:	e8bd 81f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, pc}

000002f0 <block_copy_byte>:
 * r0: source address
 * r1: target address
 * r2: number of bytes
*/
block_copy_byte:
    push {r3, lr}
 2f0:	b508      	push	{r3, lr}
	mov  r3, #0
 2f2:	f04f 0300 	mov.w	r3, #0

000002f6 <block_copy_byte_loop>:
block_copy_byte_loop:            /* ; From above, R0 contains source address, R1 contains destination address */
	ldrb r3, [r0]
 2f6:	7803      	ldrb	r3, [r0, #0]
    strb r3, [r1]
 2f8:	700b      	strb	r3, [r1, #0]
    add  r0, #1
 2fa:	f100 0001 	add.w	r0, r0, #1
    add  r1, #1
 2fe:	f101 0101 	add.w	r1, r1, #1
  	subs r2, r2, #1
 302:	3a01      	subs	r2, #1
    bne block_copy_byte_loop
 304:	d1f7      	bne.n	2f6 <block_copy_byte_loop>
    pop {r3, pc}
 306:	bd08      	pop	{r3, pc}

00000308 <fill_memory>:
; * @return none - Used Registers are not preserved
; */

fill_memory:
    /* ;push {r4, r5, r6, r7, r8, r9, lr}	 We will not use stack as may be not available */
    cmp r0, r1
 308:	4288      	cmp	r0, r1
    beq fill_memory_exit        /* ; Exit early if source and destination the same */
 30a:	d037      	beq.n	37c <fill_memory_exit>
/* ; copy non-aligned bytes at the start */
    and.w  r6, r0, #3			/* ; see if non-alaigned bytes at the start 	*/
 30c:	f000 0603 	and.w	r6, r0, #3
    cmp r6, #0
 310:	2e00      	cmp	r6, #0
    beq fill_memory_end_start   /* ; no spare bytes at start, continue 	*/
 312:	d014      	beq.n	33e <fill_memory_end_start>
    mov    r5, #4
 314:	f04f 0504 	mov.w	r5, #4
    sub.w  r4, r5, r6			/* ; now have number of non-aligned bytes in r4 */
 318:	eba5 0406 	sub.w	r4, r5, r6
    mov  r7, #8
 31c:	f04f 0708 	mov.w	r7, #8
    mul  r8, r7, r6				/* ; calculate number of shifts required to initalise pattern for non-aligned bytes */
 320:	fb07 f806 	mul.w	r8, r7, r6
    mov  r9, r2					/* ; copy pattern */
 324:	4691      	mov	r9, r2
    ror  r9, r9, r8             	/* ; Rotate right to keep pattern consistent */
 326:	fa69 f908 	ror.w	r9, r9, r8

0000032a <fill_memory_spare_bytes_start>:
fill_memory_spare_bytes_start:  /* ; From above, R0 contains source address, R1 contains destination address */
    cmp r4, #0					/* ; no spare bytes at end- end now 	*/
 32a:	2c00      	cmp	r4, #0
    beq fill_memory_end_start
 32c:	d007      	beq.n	33e <fill_memory_end_start>
    strb r9, [r0]				/* ; fill byte */
 32e:	f880 9000 	strb.w	r9, [r0]
    ror.w  r9, r9, r7             	/* ; Rotate right by one byte for the next time, to keep pattern consistent */
 332:	fa69 f907 	ror.w	r9, r9, r7
    add r0, r0, #1				/* ; add one to address */
 336:	f100 0001 	add.w	r0, r0, #1
    subs r4, r4, #1				/* ; subtract one from byte count 1	*/
 33a:	3c01      	subs	r4, #1
    b fill_memory_spare_bytes_start
 33c:	e7f5      	b.n	32a <fill_memory_spare_bytes_start>

0000033e <fill_memory_end_start>:
fill_memory_end_start:
    mov  r6, #0
 33e:	f04f 0600 	mov.w	r6, #0
    mov  r7, r1					 /* ; save end address */
 342:	460f      	mov	r7, r1
    subs r1, r1, r0              /* ; Calculate number of bytes to fill */
 344:	1a09      	subs	r1, r1, r0
    mov  r8,r1                   /* ; Save copy of byte count */
 346:	4688      	mov	r8, r1
    asrs r1,r1, #4               /* ; Div by 16 to get number of chunks to move */
 348:	1109      	asrs	r1, r1, #4
    mov  r9, r2					 /* ; copy pattern */
 34a:	4691      	mov	r9, r2
    mov  r4, r2					 /* ; copy pattern */
 34c:	4614      	mov	r4, r2
    mov  r5, r2					 /* ; copy pattern */
 34e:	4615      	mov	r5, r2
    cmp r1, r6					 /* ; compare to see if all chunks copied */
 350:	42b1      	cmp	r1, r6
    beq fill_memory_spare_bytes_end
 352:	d006      	beq.n	362 <fill_memory_spare_bytes_end>

00000354 <fill_memory_loop>:
fill_memory_loop:
    it ne
 354:	bf18      	it	ne
    stmne r0!, {r2, r4, r5, r9}  /* ; copy pattern- note: stmne instruction must me word aligned (address in r0) */
 356:	e8a0 0234 	stmiane.w	r0!, {r2, r4, r5, r9}
    add.w r6, r6, #1			 /* ; use Thumb2- make sure condition code reg. not updated */
 35a:	f106 0601 	add.w	r6, r6, #1
    cmp r1, r6					 /* ; compare to see if all chunks copied */
 35e:	42b1      	cmp	r1, r6
    bne fill_memory_loop
 360:	d1f8      	bne.n	354 <fill_memory_loop>

00000362 <fill_memory_spare_bytes_end>:
fill_memory_spare_bytes_end:	 /* ; copy spare bytes at the end if any */
    and.w r8, r8, #15					 /* ; get spare bytes  --check can you do an ands? 	*/
 362:	f008 080f 	and.w	r8, r8, #15

00000366 <fill_memory_spare_end_loop>:
fill_memory_spare_end_loop:      /* ; From above, R0 contains source address, R1 contains destination address */
    cmp r8, #0					 /* ; no spare bytes at end- end now 	*/
 366:	f1b8 0f00 	cmp.w	r8, #0
    beq fill_memory_exit
 36a:	d007      	beq.n	37c <fill_memory_exit>
    strb r2, [r0]
 36c:	7002      	strb	r2, [r0, #0]
    ror.w  r2, r2, #8             	 /* ; Rotate right by one byte for the next time, to keep pattern consistent */
 36e:	ea4f 2232 	mov.w	r2, r2, ror #8
    add r0, r0, #1				 /* ; add one to address */
 372:	f100 0001 	add.w	r0, r0, #1
    subs r8, r8, #1				 /* ; subtract one from byte count 1	*/
 376:	f1b8 0801 	subs.w	r8, r8, #1
    b fill_memory_spare_end_loop
 37a:	e7f4      	b.n	366 <fill_memory_spare_end_loop>

0000037c <fill_memory_exit>:
fill_memory_exit:
    bx lr				/*; We will not use pop as stack may be not available */
 37c:	4770      	bx	lr

0000037e <NMI_Handler>:
 * NMI_Handler
 */
    .weak   NMI_Handler
    .type   NMI_Handler, %function
NMI_Handler:
    B .
 37e:	e7fe      	b.n	37e <NMI_Handler>
 * HardFault_Handler
 */
    .weak   HardFault_Handler
    .type   HardFault_Handler, %function
HardFault_Handler:
    B .
 380:	e7fe      	b.n	380 <NMI_Handler+0x2>

00000382 <MemManage_Handler>:
 * MemManage_Handler
 */
    .weak   MemManage_Handler
    .type   MemManage_Handler, %function
MemManage_Handler:
    B .
 382:	e7fe      	b.n	382 <MemManage_Handler>
 * BusFault_Handler
 */
    .weak   BusFault_Handler
    .type   BusFault_Handler, %function
BusFault_Handler:
    B .
 384:	e7fe      	b.n	384 <MemManage_Handler+0x2>
 * UsageFault_Handler
 */
    .weak   UsageFault_Handler
    .type   UsageFault_Handler, %function
UsageFault_Handler:
    B .
 386:	e7fe      	b.n	386 <MemManage_Handler+0x4>

00000388 <SVC_Handler>:
 * SVC_Handler
 */
    .weak   SVC_Handler
    .type   SVC_Handler, %function
SVC_Handler:
    B .
 388:	e7fe      	b.n	388 <SVC_Handler>

0000038a <DebugMon_Handler>:
 * DebugMon_Handler
 */
    .weak   DebugMon_Handler
    .type   DebugMon_Handler, %function
DebugMon_Handler:
    B .
 38a:	e7fe      	b.n	38a <DebugMon_Handler>

0000038c <PendSV_Handler>:
 * PendSV_Handler
 */
    .weak   PendSV_Handler
    .type   PendSV_Handler, %function
PendSV_Handler:
    B .
 38c:	e7fe      	b.n	38c <PendSV_Handler>

0000038e <SysTick_Handler>:
 * SysTick_Handler
 */
    .weak   SysTick_Handler
    .type   SysTick_Handler, %function
SysTick_Handler:
    B .
 38e:	e7fe      	b.n	38e <SysTick_Handler>

00000390 <WdogWakeup_IRQHandler>:
 * WdogWakeup_IRQHandler
 */
    .weak   WdogWakeup_IRQHandler
    .type   WdogWakeup_IRQHandler, %function
WdogWakeup_IRQHandler:
    B .
 390:	e7fe      	b.n	390 <WdogWakeup_IRQHandler>

00000392 <RTC_Wakeup_IRQHandler>:
 * RTC_Wakeup_IRQHandler
 */
    .weak   RTC_Wakeup_IRQHandler
    .type   RTC_Wakeup_IRQHandler, %function
RTC_Wakeup_IRQHandler:
    B .
 392:	e7fe      	b.n	392 <RTC_Wakeup_IRQHandler>

00000394 <SPI0_IRQHandler>:
 * SPI0_IRQHandler
 */
    .weak   SPI0_IRQHandler
    .type   SPI0_IRQHandler, %function
SPI0_IRQHandler:
    B .
 394:	e7fe      	b.n	394 <SPI0_IRQHandler>

00000396 <SPI1_IRQHandler>:
 * SPI1_IRQHandler
 */
    .weak   SPI1_IRQHandler
    .type   SPI1_IRQHandler, %function
SPI1_IRQHandler:
    B .
 396:	e7fe      	b.n	396 <SPI1_IRQHandler>

00000398 <I2C0_IRQHandler>:
 * I2C0_IRQHandler
 */
    .weak   I2C0_IRQHandler
    .type   I2C0_IRQHandler, %function
I2C0_IRQHandler:
    B .
 398:	e7fe      	b.n	398 <I2C0_IRQHandler>

0000039a <I2C0_SMBAlert_IRQHandler>:
 * I2C0_SMBAlert_IRQHandler
 */
    .weak   I2C0_SMBAlert_IRQHandler
    .type   I2C0_SMBAlert_IRQHandler, %function
I2C0_SMBAlert_IRQHandler:
    B .
 39a:	e7fe      	b.n	39a <I2C0_SMBAlert_IRQHandler>

0000039c <I2C0_SMBus_IRQHandler>:
 * I2C0_SMBus_IRQHandler
 */
    .weak   I2C0_SMBus_IRQHandler
    .type   I2C0_SMBus_IRQHandler, %function
I2C0_SMBus_IRQHandler:
    B .
 39c:	e7fe      	b.n	39c <I2C0_SMBus_IRQHandler>

0000039e <I2C1_IRQHandler>:
 * I2C1_IRQHandler
 */
    .weak   I2C1_IRQHandler
    .type   I2C1_IRQHandler, %function
I2C1_IRQHandler:
    B .
 39e:	e7fe      	b.n	39e <I2C1_IRQHandler>

000003a0 <I2C1_SMBAlert_IRQHandler>:
 * I2C1_SMBAlert_IRQHandler
 */
    .weak   I2C1_SMBAlert_IRQHandler
    .type   I2C1_SMBAlert_IRQHandler, %function
I2C1_SMBAlert_IRQHandler:
    B .
 3a0:	e7fe      	b.n	3a0 <I2C1_SMBAlert_IRQHandler>

000003a2 <I2C1_SMBus_IRQHandler>:
 * I2C1_SMBus_IRQHandler
 */
    .weak   I2C1_SMBus_IRQHandler
    .type   I2C1_SMBus_IRQHandler, %function
I2C1_SMBus_IRQHandler:
    B .
 3a2:	e7fe      	b.n	3a2 <I2C1_SMBus_IRQHandler>

000003a4 <UART0_IRQHandler>:
 * UART0_IRQHandler
 */
    .weak   UART0_IRQHandler
    .type   UART0_IRQHandler, %function
UART0_IRQHandler:
    B .
 3a4:	e7fe      	b.n	3a4 <UART0_IRQHandler>

000003a6 <UART1_IRQHandler>:
 * UART1_IRQHandler
 */
    .weak   UART1_IRQHandler
    .type   UART1_IRQHandler, %function
UART1_IRQHandler:
    B .
 3a6:	e7fe      	b.n	3a6 <UART1_IRQHandler>

000003a8 <EthernetMAC_IRQHandler>:
 * EthernetMAC_IRQHandler
 */
    .weak   EthernetMAC_IRQHandler
    .type   EthernetMAC_IRQHandler, %function
EthernetMAC_IRQHandler:
    B .
 3a8:	e7fe      	b.n	3a8 <EthernetMAC_IRQHandler>

000003aa <DMA_IRQHandler>:
 * DMA_IRQHandler
 */
    .weak   DMA_IRQHandler
    .type   DMA_IRQHandler, %function
DMA_IRQHandler:
    B .
 3aa:	e7fe      	b.n	3aa <DMA_IRQHandler>

000003ac <Timer1_IRQHandler>:
 * Timer1_IRQHandler
 */
    .weak   Timer1_IRQHandler
    .type   Timer1_IRQHandler, %function
Timer1_IRQHandler:
    B .
 3ac:	e7fe      	b.n	3ac <Timer1_IRQHandler>

000003ae <Timer2_IRQHandler>:
 * Timer2_IRQHandler
 */
    .weak   Timer2_IRQHandler
    .type   Timer2_IRQHandler, %function
Timer2_IRQHandler:
    B .
 3ae:	e7fe      	b.n	3ae <Timer2_IRQHandler>

000003b0 <CAN_IRQHandler>:
 * CAN_IRQHandler
 */
    .weak   CAN_IRQHandler
    .type   CAN_IRQHandler, %function
CAN_IRQHandler:
    B .
 3b0:	e7fe      	b.n	3b0 <CAN_IRQHandler>

000003b2 <ENVM0_IRQHandler>:
 * ENVM0_IRQHandler
 */
    .weak   ENVM0_IRQHandler
    .type   ENVM0_IRQHandler, %function
ENVM0_IRQHandler:
    B .
 3b2:	e7fe      	b.n	3b2 <ENVM0_IRQHandler>

000003b4 <ENVM1_IRQHandler>:
 * ENVM1_IRQHandler
 */
    .weak   ENVM1_IRQHandler
    .type   ENVM1_IRQHandler, %function
ENVM1_IRQHandler:
    B .
 3b4:	e7fe      	b.n	3b4 <ENVM1_IRQHandler>

000003b6 <ComBlk_IRQHandler>:
 * ComBlk_IRQHandler
 */
    .weak   ComBlk_IRQHandler
    .type   ComBlk_IRQHandler, %function
ComBlk_IRQHandler:
    B .
 3b6:	e7fe      	b.n	3b6 <ComBlk_IRQHandler>

000003b8 <USB_IRQHandler>:
 * USB_IRQHandler
 */
    .weak   USB_IRQHandler
    .type   USB_IRQHandler, %function
USB_IRQHandler:
    B .
 3b8:	e7fe      	b.n	3b8 <USB_IRQHandler>

000003ba <USB_DMA_IRQHandler>:
 * USB_DMA_IRQHandler
 */
    .weak   USB_DMA_IRQHandler
    .type   USB_DMA_IRQHandler, %function
USB_DMA_IRQHandler:
    B .
 3ba:	e7fe      	b.n	3ba <USB_DMA_IRQHandler>

000003bc <PLL_Lock_IRQHandler>:
 * PLL_Lock_IRQHandler
 */
    .weak   PLL_Lock_IRQHandler
    .type   PLL_Lock_IRQHandler, %function
PLL_Lock_IRQHandler:
    B .
 3bc:	e7fe      	b.n	3bc <PLL_Lock_IRQHandler>

000003be <PLL_LockLost_IRQHandler>:
 * PLL_LockLost_IRQHandler
 */
    .weak   PLL_LockLost_IRQHandler
    .type   PLL_LockLost_IRQHandler, %function
PLL_LockLost_IRQHandler:
    B .
 3be:	e7fe      	b.n	3be <PLL_LockLost_IRQHandler>

000003c0 <CommSwitchError_IRQHandler>:
 * CommSwitchError_IRQHandler
 */
    .weak   CommSwitchError_IRQHandler
    .type   CommSwitchError_IRQHandler, %function
CommSwitchError_IRQHandler:
    B .
 3c0:	e7fe      	b.n	3c0 <CommSwitchError_IRQHandler>

000003c2 <CacheError_IRQHandler>:
 * CacheError_IRQHandler
 */
    .weak   CacheError_IRQHandler
    .type   CacheError_IRQHandler, %function
CacheError_IRQHandler:
    B .
 3c2:	e7fe      	b.n	3c2 <CacheError_IRQHandler>

000003c4 <DDR_IRQHandler>:
 * DDR_IRQHandler
 */
    .weak   DDR_IRQHandler
    .type   DDR_IRQHandler, %function
DDR_IRQHandler:
    B .
 3c4:	e7fe      	b.n	3c4 <DDR_IRQHandler>

000003c6 <HPDMA_Complete_IRQHandler>:
 * HPDMA_Complete_IRQHandler
 */
    .weak   HPDMA_Complete_IRQHandler
    .type   HPDMA_Complete_IRQHandler, %function
HPDMA_Complete_IRQHandler:
    B .
 3c6:	e7fe      	b.n	3c6 <HPDMA_Complete_IRQHandler>

000003c8 <HPDMA_Error_IRQHandler>:
 * HPDMA_Error_IRQHandler
 */
    .weak   HPDMA_Error_IRQHandler
    .type   HPDMA_Error_IRQHandler, %function
HPDMA_Error_IRQHandler:
    B .
 3c8:	e7fe      	b.n	3c8 <HPDMA_Error_IRQHandler>

000003ca <ECC_Error_IRQHandler>:
 * ECC_Error_IRQHandler
 */
    .weak   ECC_Error_IRQHandler
    .type   ECC_Error_IRQHandler, %function
ECC_Error_IRQHandler:
    B .
 3ca:	e7fe      	b.n	3ca <ECC_Error_IRQHandler>

000003cc <MDDR_IOCalib_IRQHandler>:
 * MDDR_IOCalib_IRQHandler
 */
    .weak   MDDR_IOCalib_IRQHandler
    .type   MDDR_IOCalib_IRQHandler, %function
MDDR_IOCalib_IRQHandler:
    B .
 3cc:	e7fe      	b.n	3cc <MDDR_IOCalib_IRQHandler>

000003ce <FAB_PLL_Lock_IRQHandler>:
 * FAB_PLL_Lock_IRQHandler
 */
    .weak   FAB_PLL_Lock_IRQHandler
    .type   FAB_PLL_Lock_IRQHandler, %function    
FAB_PLL_Lock_IRQHandler:
    B .
 3ce:	e7fe      	b.n	3ce <FAB_PLL_Lock_IRQHandler>

000003d0 <FAB_PLL_LockLost_IRQHandler>:
 * FAB_PLL_LockLost_IRQHandler
 */
    .weak   FAB_PLL_LockLost_IRQHandler
    .type   FAB_PLL_LockLost_IRQHandler, %function        
FAB_PLL_LockLost_IRQHandler:
    B .
 3d0:	e7fe      	b.n	3d0 <FAB_PLL_LockLost_IRQHandler>

000003d2 <FIC64_IRQHandler>:
 * FIC64_IRQHandler
 */
    .weak   FIC64_IRQHandler
    .type   FIC64_IRQHandler, %function            
FIC64_IRQHandler:
    B .
 3d2:	e7fe      	b.n	3d2 <FIC64_IRQHandler>

000003d4 <FabricIrq0_IRQHandler>:
 * FabricIrq0_IRQHandler
 */
    .weak   FabricIrq0_IRQHandler
    .type   FabricIrq0_IRQHandler, %function
FabricIrq0_IRQHandler:
    B .
 3d4:	e7fe      	b.n	3d4 <FabricIrq0_IRQHandler>

000003d6 <FabricIrq1_IRQHandler>:
 * FabricIrq1_IRQHandler
 */
    .weak   FabricIrq1_IRQHandler
    .type   FabricIrq1_IRQHandler, %function
FabricIrq1_IRQHandler:
    B .
 3d6:	e7fe      	b.n	3d6 <FabricIrq1_IRQHandler>

000003d8 <FabricIrq2_IRQHandler>:
 * FabricIrq2_IRQHandler
 */
    .weak   FabricIrq2_IRQHandler
    .type   FabricIrq2_IRQHandler, %function
FabricIrq2_IRQHandler:
    B .
 3d8:	e7fe      	b.n	3d8 <FabricIrq2_IRQHandler>

000003da <FabricIrq3_IRQHandler>:
 * FabricIrq3_IRQHandler
 */
    .weak   FabricIrq3_IRQHandler
    .type   FabricIrq3_IRQHandler, %function
FabricIrq3_IRQHandler:
    B .
 3da:	e7fe      	b.n	3da <FabricIrq3_IRQHandler>

000003dc <FabricIrq4_IRQHandler>:
 * FabricIrq4_IRQHandler
 */
    .weak   FabricIrq4_IRQHandler
    .type   FabricIrq4_IRQHandler, %function
FabricIrq4_IRQHandler:
    B .
 3dc:	e7fe      	b.n	3dc <FabricIrq4_IRQHandler>

000003de <FabricIrq5_IRQHandler>:
 * FabricIrq5_IRQHandler
 */
    .weak   FabricIrq5_IRQHandler
    .type   FabricIrq5_IRQHandler, %function
FabricIrq5_IRQHandler:
    B .
 3de:	e7fe      	b.n	3de <FabricIrq5_IRQHandler>

000003e0 <FabricIrq6_IRQHandler>:
 * FabricIrq6_IRQHandler
 */
    .weak   FabricIrq6_IRQHandler
    .type   FabricIrq6_IRQHandler, %function
FabricIrq6_IRQHandler:
    B .
 3e0:	e7fe      	b.n	3e0 <FabricIrq6_IRQHandler>

000003e2 <FabricIrq7_IRQHandler>:
 * FabricIrq7_IRQHandler
 */
    .weak   FabricIrq7_IRQHandler
    .type   FabricIrq7_IRQHandler, %function
FabricIrq7_IRQHandler:
    B .
 3e2:	e7fe      	b.n	3e2 <FabricIrq7_IRQHandler>

000003e4 <FabricIrq8_IRQHandler>:
 * FabricIrq8_IRQHandler
 */
    .weak   FabricIrq8_IRQHandler
    .type   FabricIrq8_IRQHandler, %function
FabricIrq8_IRQHandler:
    B .
 3e4:	e7fe      	b.n	3e4 <FabricIrq8_IRQHandler>

000003e6 <FabricIrq9_IRQHandler>:
 * FabricIrq9_IRQHandler
 */
    .weak   FabricIrq9_IRQHandler
    .type   FabricIrq9_IRQHandler, %function
FabricIrq9_IRQHandler:
    B .
 3e6:	e7fe      	b.n	3e6 <FabricIrq9_IRQHandler>

000003e8 <FabricIrq10_IRQHandler>:
 * FabricIrq10_IRQHandler
 */
    .weak   FabricIrq10_IRQHandler
    .type   FabricIrq10_IRQHandler, %function
FabricIrq10_IRQHandler:
    B .
 3e8:	e7fe      	b.n	3e8 <FabricIrq10_IRQHandler>

000003ea <FabricIrq11_IRQHandler>:
 * FabricIrq11_IRQHandler
 */
    .weak   FabricIrq11_IRQHandler
    .type   FabricIrq11_IRQHandler, %function
FabricIrq11_IRQHandler:
    B .
 3ea:	e7fe      	b.n	3ea <FabricIrq11_IRQHandler>

000003ec <FabricIrq12_IRQHandler>:
 * FabricIrq12_IRQHandler
 */
    .weak   FabricIrq12_IRQHandler
    .type   FabricIrq12_IRQHandler, %function
FabricIrq12_IRQHandler:
    B .
 3ec:	e7fe      	b.n	3ec <FabricIrq12_IRQHandler>

000003ee <FabricIrq13_IRQHandler>:
 * FabricIrq13_IRQHandler
 */
    .weak   FabricIrq13_IRQHandler
    .type   FabricIrq13_IRQHandler, %function
FabricIrq13_IRQHandler:
    B .
 3ee:	e7fe      	b.n	3ee <FabricIrq13_IRQHandler>

000003f0 <FabricIrq14_IRQHandler>:
 * FabricIrq14_IRQHandler
 */
    .weak   FabricIrq14_IRQHandler
    .type   FabricIrq14_IRQHandler, %function
FabricIrq14_IRQHandler:
    B .
 3f0:	e7fe      	b.n	3f0 <FabricIrq14_IRQHandler>

000003f2 <FabricIrq15_IRQHandler>:
 * FabricIrq15_IRQHandler
 */
    .weak   FabricIrq15_IRQHandler
    .type   FabricIrq15_IRQHandler, %function
FabricIrq15_IRQHandler:
    B .    
 3f2:	e7fe      	b.n	3f2 <FabricIrq15_IRQHandler>

000003f4 <GPIO0_IRQHandler>:
 * GPIO0_IRQHandler
 */
    .weak   GPIO0_IRQHandler
    .type   GPIO0_IRQHandler, %function
GPIO0_IRQHandler:
    B .
 3f4:	e7fe      	b.n	3f4 <GPIO0_IRQHandler>

000003f6 <GPIO1_IRQHandler>:
 * GPIO1_IRQHandler
 */
    .weak   GPIO1_IRQHandler
    .type   GPIO1_IRQHandler, %function
GPIO1_IRQHandler:
    B .
 3f6:	e7fe      	b.n	3f6 <GPIO1_IRQHandler>

000003f8 <GPIO2_IRQHandler>:
 * GPIO2_IRQHandler
 */
    .weak   GPIO2_IRQHandler
    .type   GPIO2_IRQHandler, %function
GPIO2_IRQHandler:
    B .
 3f8:	e7fe      	b.n	3f8 <GPIO2_IRQHandler>

000003fa <GPIO3_IRQHandler>:
 * GPIO3_IRQHandler
 */
    .weak   GPIO3_IRQHandler
    .type   GPIO3_IRQHandler, %function
GPIO3_IRQHandler:
    B .
 3fa:	e7fe      	b.n	3fa <GPIO3_IRQHandler>

000003fc <GPIO4_IRQHandler>:
 * GPIO4_IRQHandler
 */
    .weak   GPIO4_IRQHandler
    .type   GPIO4_IRQHandler, %function
GPIO4_IRQHandler:
    B .
 3fc:	e7fe      	b.n	3fc <GPIO4_IRQHandler>

000003fe <GPIO5_IRQHandler>:
 * GPIO5_IRQHandler
 */
    .weak   GPIO5_IRQHandler
    .type   GPIO5_IRQHandler, %function
GPIO5_IRQHandler:
    B .
 3fe:	e7fe      	b.n	3fe <GPIO5_IRQHandler>

00000400 <GPIO6_IRQHandler>:
 * GPIO6_IRQHandler
 */
    .weak   GPIO6_IRQHandler
    .type   GPIO6_IRQHandler, %function
GPIO6_IRQHandler:
    B .
 400:	e7fe      	b.n	400 <GPIO6_IRQHandler>

00000402 <GPIO7_IRQHandler>:
 * GPIO7_IRQHandler
 */
    .weak   GPIO7_IRQHandler
    .type   GPIO7_IRQHandler, %function
GPIO7_IRQHandler:
    B .
 402:	e7fe      	b.n	402 <GPIO7_IRQHandler>

00000404 <GPIO8_IRQHandler>:
 * GPIO8_IRQHandler
 */
    .weak   GPIO8_IRQHandler
    .type   GPIO8_IRQHandler, %function
GPIO8_IRQHandler:
    B .
 404:	e7fe      	b.n	404 <GPIO8_IRQHandler>

00000406 <GPIO9_IRQHandler>:
 * GPIO9_IRQHandler
 */
    .weak   GPIO9_IRQHandler
    .type   GPIO9_IRQHandler, %function
GPIO9_IRQHandler:
    B .
 406:	e7fe      	b.n	406 <GPIO9_IRQHandler>

00000408 <GPIO10_IRQHandler>:
 * GPIO10_IRQHandler
 */
    .weak   GPIO10_IRQHandler
    .type   GPIO10_IRQHandler, %function
GPIO10_IRQHandler:
    B .
 408:	e7fe      	b.n	408 <GPIO10_IRQHandler>

0000040a <GPIO11_IRQHandler>:
 * GPIO11_IRQHandler
 */
    .weak   GPIO11_IRQHandler
    .type   GPIO11_IRQHandler, %function
GPIO11_IRQHandler:
    B .
 40a:	e7fe      	b.n	40a <GPIO11_IRQHandler>

0000040c <GPIO12_IRQHandler>:
 * GPIO12_IRQHandler
 */
    .weak   GPIO12_IRQHandler
    .type   GPIO12_IRQHandler, %function
GPIO12_IRQHandler:
    B .
 40c:	e7fe      	b.n	40c <GPIO12_IRQHandler>

0000040e <GPIO13_IRQHandler>:
 * GPIO13_IRQHandler
 */
    .weak   GPIO13_IRQHandler
    .type   GPIO13_IRQHandler, %function
GPIO13_IRQHandler:
    B .
 40e:	e7fe      	b.n	40e <GPIO13_IRQHandler>

00000410 <GPIO14_IRQHandler>:
 * GPIO14_IRQHandler
 */
    .weak   GPIO14_IRQHandler
    .type   GPIO14_IRQHandler, %function
GPIO14_IRQHandler:
    B .
 410:	e7fe      	b.n	410 <GPIO14_IRQHandler>

00000412 <GPIO15_IRQHandler>:
 * GPIO15_IRQHandler
 */
    .weak   GPIO15_IRQHandler
    .type   GPIO15_IRQHandler, %function
GPIO15_IRQHandler:
    B .
 412:	e7fe      	b.n	412 <GPIO15_IRQHandler>

00000414 <GPIO16_IRQHandler>:
 * GPIO16_IRQHandler
 */
    .weak   GPIO16_IRQHandler
    .type   GPIO16_IRQHandler, %function
GPIO16_IRQHandler:
    B .
 414:	e7fe      	b.n	414 <GPIO16_IRQHandler>

00000416 <GPIO17_IRQHandler>:
 * GPIO17_IRQHandler
 */
    .weak   GPIO17_IRQHandler
    .type   GPIO17_IRQHandler, %function
GPIO17_IRQHandler:
    B .
 416:	e7fe      	b.n	416 <GPIO17_IRQHandler>

00000418 <GPIO18_IRQHandler>:
 * GPIO18_IRQHandler
 */
    .weak   GPIO18_IRQHandler
    .type   GPIO18_IRQHandler, %function
GPIO18_IRQHandler:
    B .
 418:	e7fe      	b.n	418 <GPIO18_IRQHandler>

0000041a <GPIO19_IRQHandler>:
 * GPIO19_IRQHandler
 */
    .weak   GPIO19_IRQHandler
    .type   GPIO19_IRQHandler, %function
GPIO19_IRQHandler:
    B .
 41a:	e7fe      	b.n	41a <GPIO19_IRQHandler>

0000041c <GPIO20_IRQHandler>:
 * GPIO20_IRQHandler
 */
    .weak   GPIO20_IRQHandler
    .type   GPIO20_IRQHandler, %function
GPIO20_IRQHandler:
    B .
 41c:	e7fe      	b.n	41c <GPIO20_IRQHandler>

0000041e <GPIO21_IRQHandler>:
 * GPIO21_IRQHandler
 */
    .weak   GPIO21_IRQHandler
    .type   GPIO21_IRQHandler, %function
GPIO21_IRQHandler:
    B .
 41e:	e7fe      	b.n	41e <GPIO21_IRQHandler>

00000420 <GPIO22_IRQHandler>:
 * GPIO22_IRQHandler
 */
    .weak   GPIO22_IRQHandler
    .type   GPIO22_IRQHandler, %function
GPIO22_IRQHandler:
    B .
 420:	e7fe      	b.n	420 <GPIO22_IRQHandler>

00000422 <GPIO23_IRQHandler>:
 * GPIO23_IRQHandler
 */
    .weak   GPIO23_IRQHandler
    .type   GPIO23_IRQHandler, %function
GPIO23_IRQHandler:
    B .
 422:	e7fe      	b.n	422 <GPIO23_IRQHandler>

00000424 <GPIO24_IRQHandler>:
 * GPIO24_IRQHandler
 */
    .weak   GPIO24_IRQHandler
    .type   GPIO24_IRQHandler, %function
GPIO24_IRQHandler:
    B .
 424:	e7fe      	b.n	424 <GPIO24_IRQHandler>

00000426 <GPIO25_IRQHandler>:
 * GPIO25_IRQHandler
 */
    .weak   GPIO25_IRQHandler
    .type   GPIO25_IRQHandler, %function
GPIO25_IRQHandler:
    B .
 426:	e7fe      	b.n	426 <GPIO25_IRQHandler>

00000428 <GPIO26_IRQHandler>:
 * GPIO26_IRQHandler
 */
    .weak   GPIO26_IRQHandler
    .type   GPIO26_IRQHandler, %function
GPIO26_IRQHandler:
    B .
 428:	e7fe      	b.n	428 <GPIO26_IRQHandler>

0000042a <GPIO27_IRQHandler>:
 * GPIO27_IRQHandler
 */
    .weak   GPIO27_IRQHandler
    .type   GPIO27_IRQHandler, %function
GPIO27_IRQHandler:
    B .
 42a:	e7fe      	b.n	42a <GPIO27_IRQHandler>

0000042c <GPIO28_IRQHandler>:
 * GPIO28_IRQHandler
 */
    .weak   GPIO28_IRQHandler
    .type   GPIO28_IRQHandler, %function
GPIO28_IRQHandler:
    B .
 42c:	e7fe      	b.n	42c <GPIO28_IRQHandler>

0000042e <GPIO29_IRQHandler>:
 * GPIO29_IRQHandler
 */
    .weak   GPIO29_IRQHandler
    .type   GPIO29_IRQHandler, %function
GPIO29_IRQHandler:
    B .
 42e:	e7fe      	b.n	42e <GPIO29_IRQHandler>

00000430 <GPIO30_IRQHandler>:
 * GPIO30_IRQHandler
 */
    .weak   GPIO30_IRQHandler
    .type   GPIO30_IRQHandler, %function
GPIO30_IRQHandler:
    B .
 430:	e7fe      	b.n	430 <GPIO30_IRQHandler>

00000432 <GPIO31_IRQHandler>:
 * GPIO31_IRQHandler
 */
    .weak   GPIO31_IRQHandler
    .type   GPIO31_IRQHandler, %function
GPIO31_IRQHandler:
    B .
 432:	e7fe      	b.n	432 <GPIO31_IRQHandler>

00000434 <mscc_post_hw_cfg_init>:
 * mscc_post_hw_cfg_init
 */
    .weak   mscc_post_hw_cfg_init
    .type   mscc_post_hw_cfg_init, %function
mscc_post_hw_cfg_init:
    BX LR
 434:	4770      	bx	lr

00000436 <RAM_INIT_PATTERN>:
 436:	0000      	.short	0x0000
	...

0000043a <HEAP_INIT_PATTERN>:
 43a:	a2a2      	.short	0xa2a2
 43c:	a2a2      	.short	0xa2a2

0000043e <SF2_ESRAM_CR>:
 43e:	8000      	.short	0x8000
 440:	4003      	.short	0x4003

00000442 <SF2_DDR_CR>:
 442:	8008      	.short	0x8008
 444:	4003      	.short	0x4003

00000446 <SF2_ENVM_REMAP_CR>:
 446:	8010      	.short	0x8010
 448:	4003      	.short	0x4003

0000044a <SF2_DDRB_NB_SIZE>:
 44a:	8030      	.short	0x8030
 44c:	4003      	.short	0x4003

0000044e <SF2_DDRB_CR>:
 44e:	8034      	.short	0x8034
 450:	4003      	.short	0x4003

00000452 <SF2_EDAC_CR>:
 452:	8038      	.short	0x8038
 454:	4003      	.short	0x4003

00000456 <SF2_MDDR_MODE_CR>:
 456:	0818      	.short	0x0818
 458:	00004002 	.word	0x00004002
    ldr r0, = __stack_start__
 45c:	2000f000 	.word	0x2000f000
    ldr r1, =_estack
 460:	20010000 	.word	0x20010000
    ldr r0, =SystemInit
 464:	00000529 	.word	0x00000529
	...
    ldr r2, =_evector_table
 478:	00000190 	.word	0x00000190
    ldr r0, =__text_load
 47c:	000004b0 	.word	0x000004b0
    ldr r1, =__text_start
 480:	000004b0 	.word	0x000004b0
    ldr r2, =_etext
 484:	0000bae8 	.word	0x0000bae8
    ldr r0, =__data_load
 488:	0000baf0 	.word	0x0000baf0
    ldr r1, =__data_start
 48c:	20000000 	.word	0x20000000
    ldr r2, =_edata
 490:	200000b0 	.word	0x200000b0
    ldr r0, =__bss_start__
 494:	200000b0 	.word	0x200000b0
    ldr r1, =__bss_end__
 498:	20004780 	.word	0x20004780
    ldr r0, =__heap_start__
 49c:	20004780 	.word	0x20004780
    ldr r1, =_eheap
 4a0:	2000f000 	.word	0x2000f000
    ldr.w r0, =__libc_init_array
 4a4:	00007409 	.word	0x00007409
    ldr pc, =main
 4a8:	00006909 	.word	0x00006909
 4ac:	00000000 	.word	0x00000000

Disassembly of section .text:

000004b0 <__do_global_dtors_aux>:
     4b0:	b510      	push	{r4, lr}
     4b2:	4c05      	ldr	r4, [pc, #20]	@ (4c8 <__do_global_dtors_aux+0x18>)
     4b4:	7823      	ldrb	r3, [r4, #0]
     4b6:	b933      	cbnz	r3, 4c6 <__do_global_dtors_aux+0x16>
     4b8:	4b04      	ldr	r3, [pc, #16]	@ (4cc <__do_global_dtors_aux+0x1c>)
     4ba:	b113      	cbz	r3, 4c2 <__do_global_dtors_aux+0x12>
     4bc:	4804      	ldr	r0, [pc, #16]	@ (4d0 <__do_global_dtors_aux+0x20>)
     4be:	f3af 8000 	nop.w
     4c2:	2301      	movs	r3, #1
     4c4:	7023      	strb	r3, [r4, #0]
     4c6:	bd10      	pop	{r4, pc}
     4c8:	200000b0 	.word	0x200000b0
     4cc:	00000000 	.word	0x00000000
     4d0:	0000baac 	.word	0x0000baac

000004d4 <frame_dummy>:
     4d4:	b508      	push	{r3, lr}
     4d6:	4b03      	ldr	r3, [pc, #12]	@ (4e4 <frame_dummy+0x10>)
     4d8:	b11b      	cbz	r3, 4e2 <frame_dummy+0xe>
     4da:	4903      	ldr	r1, [pc, #12]	@ (4e8 <frame_dummy+0x14>)
     4dc:	4803      	ldr	r0, [pc, #12]	@ (4ec <frame_dummy+0x18>)
     4de:	f3af 8000 	nop.w
     4e2:	bd08      	pop	{r3, pc}
     4e4:	00000000 	.word	0x00000000
     4e8:	200000b4 	.word	0x200000b4
     4ec:	0000baac 	.word	0x0000baac

000004f0 <HardFault_Handler>:
#	.extern memmang_fault_handler_c 
	
	.global HardFault_Handler 
	.type   HardFault_Handler, %function
	HardFault_Handler: 
	TST LR, #4 
     4f0:	f01e 0f04 	tst.w	lr, #4
	ITE EQ 
     4f4:	bf0c      	ite	eq
	MRSEQ R0, MSP 
     4f6:	f3ef 8008 	mrseq	r0, MSP
	MRSNE R0, PSP 
     4fa:	f3ef 8009 	mrsne	r0, PSP
	B hard_fault_handler_c 
     4fe:	f002 bbdb 	b.w	2cb8 <hard_fault_handler_c>

00000502 <BusFault_Handler>:
	
	.global BusFault_Handler 
	.type   BusFault_Handler, %function
	BusFault_Handler: 
	TST LR, #4 
     502:	f01e 0f04 	tst.w	lr, #4
	ITE EQ 
     506:	bf0c      	ite	eq
	MRSEQ R0, MSP 
     508:	f3ef 8008 	mrseq	r0, MSP
	MRSNE R0, PSP 
     50c:	f3ef 8009 	mrsne	r0, PSP
	B bus_fault_handler_c 
     510:	f002 bc5e 	b.w	2dd0 <bus_fault_handler_c>

00000514 <UsageFault_Handler>:
	
	.global UsageFault_Handler 
	.type   UsageFault_Handler, %function
	UsageFault_Handler: 
	TST LR, #4 
     514:	f01e 0f04 	tst.w	lr, #4
	ITE EQ 
     518:	bf0c      	ite	eq
	MRSEQ R0, MSP 
     51a:	f3ef 8008 	mrseq	r0, MSP
	MRSNE R0, PSP 
     51e:	f3ef 8009 	mrsne	r0, PSP
	B usage_fault_handler_c 
     522:	f002 bc79 	b.w	2e18 <usage_fault_handler_c>
	...

00000528 <SystemInit>:
{
     528:	b580      	push	{r7, lr}
     52a:	af00      	add	r7, sp, #0
    silicon_workarounds();
     52c:	f000 f830 	bl	590 <silicon_workarounds>
    SCB->CCR |= SCB_CCR_STKALIGN_Msk;
     530:	4b04      	ldr	r3, [pc, #16]	@ (544 <SystemInit+0x1c>)
     532:	695b      	ldr	r3, [r3, #20]
     534:	4a03      	ldr	r2, [pc, #12]	@ (544 <SystemInit+0x1c>)
     536:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
     53a:	6153      	str	r3, [r2, #20]
    mscc_post_hw_cfg_init();
     53c:	f7ff ff7a 	bl	434 <mscc_post_hw_cfg_init>
}
     540:	bf00      	nop
     542:	bd80      	pop	{r7, pc}
     544:	e000ed00 	.word	0xe000ed00

00000548 <get_silicon_revision>:

/*------------------------------------------------------------------------------
  Retrieve silicon revision from system registers.
 */
static uint32_t get_silicon_revision(void)
{
     548:	b480      	push	{r7}
     54a:	b083      	sub	sp, #12
     54c:	af00      	add	r7, sp, #0
    uint32_t silicon_revision;
    uint32_t device_version;

    device_version = SYSREG->DEVICE_VERSION;
     54e:	4b0e      	ldr	r3, [pc, #56]	@ (588 <get_silicon_revision+0x40>)
     550:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
     554:	603b      	str	r3, [r7, #0]
    switch(device_version)
     556:	683b      	ldr	r3, [r7, #0]
     558:	f64f 0202 	movw	r2, #63490	@ 0xf802
     55c:	4293      	cmp	r3, r2
     55e:	d004      	beq.n	56a <get_silicon_revision+0x22>
     560:	683b      	ldr	r3, [r7, #0]
     562:	4a0a      	ldr	r2, [pc, #40]	@ (58c <get_silicon_revision+0x44>)
     564:	4293      	cmp	r3, r2
     566:	d003      	beq.n	570 <get_silicon_revision+0x28>
     568:	e005      	b.n	576 <get_silicon_revision+0x2e>
    {
        case 0x0000F802:
            silicon_revision = M2S050_REV_A_SILICON;
     56a:	2301      	movs	r3, #1
     56c:	607b      	str	r3, [r7, #4]
            break;
     56e:	e005      	b.n	57c <get_silicon_revision+0x34>

        case 0x0001F802:
            silicon_revision = M2S050_REV_B_SILICON;
     570:	2302      	movs	r3, #2
     572:	607b      	str	r3, [r7, #4]
            break;
     574:	e002      	b.n	57c <get_silicon_revision+0x34>

        default:
            silicon_revision = UNKNOWN_SILICON_REV;
     576:	2300      	movs	r3, #0
     578:	607b      	str	r3, [r7, #4]
            break;
     57a:	bf00      	nop
    }

    return silicon_revision;
     57c:	687b      	ldr	r3, [r7, #4]
}
     57e:	4618      	mov	r0, r3
     580:	370c      	adds	r7, #12
     582:	46bd      	mov	sp, r7
     584:	bc80      	pop	{r7}
     586:	4770      	bx	lr
     588:	40038000 	.word	0x40038000
     58c:	0001f802 	.word	0x0001f802

00000590 <silicon_workarounds>:

/*------------------------------------------------------------------------------
  Workarounds for various silicon versions.
 */
static void silicon_workarounds(void)
{
     590:	b580      	push	{r7, lr}
     592:	b082      	sub	sp, #8
     594:	af00      	add	r7, sp, #0
    uint32_t silicon_revision;

    silicon_revision = get_silicon_revision();
     596:	f7ff ffd7 	bl	548 <get_silicon_revision>
     59a:	6078      	str	r0, [r7, #4]

    switch(silicon_revision)
     59c:	687b      	ldr	r3, [r7, #4]
     59e:	2b01      	cmp	r3, #1
     5a0:	d102      	bne.n	5a8 <silicon_workarounds+0x18>
    {
        case M2S050_REV_A_SILICON:
            m2s050_rev_a_workarounds();
     5a2:	f000 f807 	bl	5b4 <m2s050_rev_a_workarounds>
            break;
     5a6:	e000      	b.n	5aa <silicon_workarounds+0x1a>
        case M2S050_REV_B_SILICON:
            /* Fall through. */
        case UNKNOWN_SILICON_REV:
            /* Fall through. */
        default:
            break;
     5a8:	bf00      	nop
    }
}
     5aa:	bf00      	nop
     5ac:	3708      	adds	r7, #8
     5ae:	46bd      	mov	sp, r7
     5b0:	bd80      	pop	{r7, pc}
	...

000005b4 <m2s050_rev_a_workarounds>:

/*------------------------------------------------------------------------------
  Silicon workarounds for M2S050 rev A.
 */
static void m2s050_rev_a_workarounds(void)
{
     5b4:	b480      	push	{r7}
     5b6:	af00      	add	r7, sp, #0
    /*--------------------------------------------------------------------------
     * Work around a couple of silicon issues:
     */
    /* DDR_CLK_EN <- 1 */
    SYSREG->MSSDDR_FACC1_CR |= (uint32_t)1 << DDR_CLK_EN_SHIFT;
     5b8:	4b09      	ldr	r3, [pc, #36]	@ (5e0 <m2s050_rev_a_workarounds+0x2c>)
     5ba:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
     5be:	4a08      	ldr	r2, [pc, #32]	@ (5e0 <m2s050_rev_a_workarounds+0x2c>)
     5c0:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
     5c4:	f8c2 3098 	str.w	r3, [r2, #152]	@ 0x98

    /* CONTROLLER_PLL_INIT <- 0 */
    SYSREG->MSSDDR_FACC1_CR = SYSREG->MSSDDR_FACC1_CR & ~CONTROLLER_PLL_INIT_MASK;
     5c8:	4b05      	ldr	r3, [pc, #20]	@ (5e0 <m2s050_rev_a_workarounds+0x2c>)
     5ca:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
     5ce:	4a04      	ldr	r2, [pc, #16]	@ (5e0 <m2s050_rev_a_workarounds+0x2c>)
     5d0:	f023 6380 	bic.w	r3, r3, #67108864	@ 0x4000000
     5d4:	f8c2 3098 	str.w	r3, [r2, #152]	@ 0x98
}
     5d8:	bf00      	nop
     5da:	46bd      	mov	sp, r7
     5dc:	bc80      	pop	{r7}
     5de:	4770      	bx	lr
     5e0:	40038000 	.word	0x40038000

000005e4 <_close>:

/*==============================================================================
 * Close a file.
 */
int _close(int file)
{
     5e4:	b480      	push	{r7}
     5e6:	b083      	sub	sp, #12
     5e8:	af00      	add	r7, sp, #0
     5ea:	6078      	str	r0, [r7, #4]
    return -1;
     5ec:	f04f 33ff 	mov.w	r3, #4294967295
}
     5f0:	4618      	mov	r0, r3
     5f2:	370c      	adds	r7, #12
     5f4:	46bd      	mov	sp, r7
     5f6:	bc80      	pop	{r7}
     5f8:	4770      	bx	lr

000005fa <_exit>:

/*==============================================================================
 * Exit a program without cleaning up files.
 */
void _exit( int code )
{
     5fa:	b480      	push	{r7}
     5fc:	b083      	sub	sp, #12
     5fe:	af00      	add	r7, sp, #0
     600:	6078      	str	r0, [r7, #4]
    /* Should we force a system reset? */
    while( 1 )
     602:	bf00      	nop
     604:	e7fd      	b.n	602 <_exit+0x8>

00000606 <_fstat>:

/*==============================================================================
 * Status of an open file.
 */
int _fstat(int file, struct stat *st)
{
     606:	b480      	push	{r7}
     608:	b083      	sub	sp, #12
     60a:	af00      	add	r7, sp, #0
     60c:	6078      	str	r0, [r7, #4]
     60e:	6039      	str	r1, [r7, #0]
    st->st_mode = S_IFCHR;
     610:	683b      	ldr	r3, [r7, #0]
     612:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
     616:	605a      	str	r2, [r3, #4]
    return 0;
     618:	2300      	movs	r3, #0
}
     61a:	4618      	mov	r0, r3
     61c:	370c      	adds	r7, #12
     61e:	46bd      	mov	sp, r7
     620:	bc80      	pop	{r7}
     622:	4770      	bx	lr

00000624 <_getpid>:

/*==============================================================================
 * Process-ID
 */
int _getpid(void)
{
     624:	b480      	push	{r7}
     626:	af00      	add	r7, sp, #0
    return 1;
     628:	2301      	movs	r3, #1
}
     62a:	4618      	mov	r0, r3
     62c:	46bd      	mov	sp, r7
     62e:	bc80      	pop	{r7}
     630:	4770      	bx	lr

00000632 <_isatty>:

/*==============================================================================
 * Query whether output stream is a terminal.
 */
int _isatty(int file)
{
     632:	b480      	push	{r7}
     634:	b083      	sub	sp, #12
     636:	af00      	add	r7, sp, #0
     638:	6078      	str	r0, [r7, #4]
    return 1;
     63a:	2301      	movs	r3, #1
}
     63c:	4618      	mov	r0, r3
     63e:	370c      	adds	r7, #12
     640:	46bd      	mov	sp, r7
     642:	bc80      	pop	{r7}
     644:	4770      	bx	lr

00000646 <_kill>:

/*==============================================================================
 * Send a signal.
 */
int _kill(int pid, int sig)
{
     646:	b580      	push	{r7, lr}
     648:	b082      	sub	sp, #8
     64a:	af00      	add	r7, sp, #0
     64c:	6078      	str	r0, [r7, #4]
     64e:	6039      	str	r1, [r7, #0]
    errno = EINVAL;
     650:	f006 fed4 	bl	73fc <__errno>
     654:	4603      	mov	r3, r0
     656:	2216      	movs	r2, #22
     658:	601a      	str	r2, [r3, #0]
    return -1;
     65a:	f04f 33ff 	mov.w	r3, #4294967295
}
     65e:	4618      	mov	r0, r3
     660:	3708      	adds	r7, #8
     662:	46bd      	mov	sp, r7
     664:	bd80      	pop	{r7, pc}

00000666 <_lseek>:

/*==============================================================================
 * Set position in a file.
 */
int _lseek(int file, int ptr, int dir)
{
     666:	b480      	push	{r7}
     668:	b085      	sub	sp, #20
     66a:	af00      	add	r7, sp, #0
     66c:	60f8      	str	r0, [r7, #12]
     66e:	60b9      	str	r1, [r7, #8]
     670:	607a      	str	r2, [r7, #4]
    return 0;
     672:	2300      	movs	r3, #0
}
     674:	4618      	mov	r0, r3
     676:	3714      	adds	r7, #20
     678:	46bd      	mov	sp, r7
     67a:	bc80      	pop	{r7}
     67c:	4770      	bx	lr

0000067e <_read>:

/*==============================================================================
 * Read from a file.
 */
int _read(int file, char *ptr, int len)
{
     67e:	b480      	push	{r7}
     680:	b085      	sub	sp, #20
     682:	af00      	add	r7, sp, #0
     684:	60f8      	str	r0, [r7, #12]
     686:	60b9      	str	r1, [r7, #8]
     688:	607a      	str	r2, [r7, #4]
    return 0;
     68a:	2300      	movs	r3, #0
}
     68c:	4618      	mov	r0, r3
     68e:	3714      	adds	r7, #20
     690:	46bd      	mov	sp, r7
     692:	bc80      	pop	{r7}
     694:	4770      	bx	lr

00000696 <_write_r>:
 * all files, including stdoutso if you need to generate any output, for
 * example to a serial port for debugging, you should make your minimal write
 * capable of doing this.
 */
int _write_r( void * reent, int file, char * ptr, int len )
{
     696:	b480      	push	{r7}
     698:	b085      	sub	sp, #20
     69a:	af00      	add	r7, sp, #0
     69c:	60f8      	str	r0, [r7, #12]
     69e:	60b9      	str	r1, [r7, #8]
     6a0:	607a      	str	r2, [r7, #4]
     6a2:	603b      	str	r3, [r7, #0]
     */
    MSS_UART_polled_tx(gp_my_uart, (uint8_t *)ptr, len);
    
    return len;
#else   /* MICROSEMI_STDIO_THRU_UART */
    return 0;
     6a4:	2300      	movs	r3, #0
#endif  /* MICROSEMI_STDIO_THRU_UART */
}
     6a6:	4618      	mov	r0, r3
     6a8:	3714      	adds	r7, #20
     6aa:	46bd      	mov	sp, r7
     6ac:	bc80      	pop	{r7}
     6ae:	4770      	bx	lr

000006b0 <_sbrk>:
 * GNU linker. 
 */
extern char _end;       /* Defined by the linker */
extern char _eheap;     /* Defined by the linker */
caddr_t _sbrk(int incr)
{
     6b0:	b580      	push	{r7, lr}
     6b2:	b086      	sub	sp, #24
     6b4:	af00      	add	r7, sp, #0
     6b6:	6078      	str	r0, [r7, #4]
    static char *heap_end;
    char *prev_heap_end;
    char * stack_ptr;
    
    if (heap_end == 0)
     6b8:	4b1f      	ldr	r3, [pc, #124]	@ (738 <_sbrk+0x88>)
     6ba:	681b      	ldr	r3, [r3, #0]
     6bc:	2b00      	cmp	r3, #0
     6be:	d102      	bne.n	6c6 <_sbrk+0x16>
    {
      heap_end = &_end;
     6c0:	4b1d      	ldr	r3, [pc, #116]	@ (738 <_sbrk+0x88>)
     6c2:	4a1e      	ldr	r2, [pc, #120]	@ (73c <_sbrk+0x8c>)
     6c4:	601a      	str	r2, [r3, #0]
    }
    
    prev_heap_end = heap_end;
     6c6:	4b1c      	ldr	r3, [pc, #112]	@ (738 <_sbrk+0x88>)
     6c8:	681b      	ldr	r3, [r3, #0]
     6ca:	617b      	str	r3, [r7, #20]
    
    asm volatile ("MRS %0, msp" : "=r" (stack_ptr) );
     6cc:	f3ef 8308 	mrs	r3, MSP
     6d0:	613b      	str	r3, [r7, #16]
    if(heap_end < stack_ptr)
     6d2:	4b19      	ldr	r3, [pc, #100]	@ (738 <_sbrk+0x88>)
     6d4:	681b      	ldr	r3, [r3, #0]
     6d6:	693a      	ldr	r2, [r7, #16]
     6d8:	429a      	cmp	r2, r3
     6da:	d90f      	bls.n	6fc <_sbrk+0x4c>
        /*
         * Heap is at an address below the stack, growing up toward the stack.
         * The stack is above the heap, growing down towards the heap.
         * Make sure the stack and heap do not run into each other.
         */
        if (heap_end + incr > stack_ptr)
     6dc:	4b16      	ldr	r3, [pc, #88]	@ (738 <_sbrk+0x88>)
     6de:	681a      	ldr	r2, [r3, #0]
     6e0:	687b      	ldr	r3, [r7, #4]
     6e2:	4413      	add	r3, r2
     6e4:	693a      	ldr	r2, [r7, #16]
     6e6:	429a      	cmp	r2, r3
     6e8:	d21a      	bcs.n	720 <_sbrk+0x70>
        {
          _write_r ((void *)0, 1, "Heap and stack collision\n", 25);
     6ea:	2319      	movs	r3, #25
     6ec:	4a14      	ldr	r2, [pc, #80]	@ (740 <_sbrk+0x90>)
     6ee:	2101      	movs	r1, #1
     6f0:	2000      	movs	r0, #0
     6f2:	f7ff ffd0 	bl	696 <_write_r>
          _exit (1);
     6f6:	2001      	movs	r0, #1
     6f8:	f7ff ff7f 	bl	5fa <_exit>
         * 0x00000000 memory range to read/write variables/data because of the
         * SmartFusion2 cache design.
         */
        char *top_of_heap;
        
        top_of_heap = &_eheap;
     6fc:	4b11      	ldr	r3, [pc, #68]	@ (744 <_sbrk+0x94>)
     6fe:	60fb      	str	r3, [r7, #12]
        if(heap_end + incr  > top_of_heap)
     700:	4b0d      	ldr	r3, [pc, #52]	@ (738 <_sbrk+0x88>)
     702:	681a      	ldr	r2, [r3, #0]
     704:	687b      	ldr	r3, [r7, #4]
     706:	4413      	add	r3, r2
     708:	68fa      	ldr	r2, [r7, #12]
     70a:	429a      	cmp	r2, r3
     70c:	d208      	bcs.n	720 <_sbrk+0x70>
        {
          _write_r ((void *)0, 1, "Out of heap memory\n", 25);
     70e:	2319      	movs	r3, #25
     710:	4a0d      	ldr	r2, [pc, #52]	@ (748 <_sbrk+0x98>)
     712:	2101      	movs	r1, #1
     714:	2000      	movs	r0, #0
     716:	f7ff ffbe 	bl	696 <_write_r>
          _exit (1);
     71a:	2001      	movs	r0, #1
     71c:	f7ff ff6d 	bl	5fa <_exit>
        }
    }
  
    heap_end += incr;
     720:	4b05      	ldr	r3, [pc, #20]	@ (738 <_sbrk+0x88>)
     722:	681a      	ldr	r2, [r3, #0]
     724:	687b      	ldr	r3, [r7, #4]
     726:	4413      	add	r3, r2
     728:	4a03      	ldr	r2, [pc, #12]	@ (738 <_sbrk+0x88>)
     72a:	6013      	str	r3, [r2, #0]
    return (caddr_t) prev_heap_end;
     72c:	697b      	ldr	r3, [r7, #20]
}
     72e:	4618      	mov	r0, r3
     730:	3718      	adds	r7, #24
     732:	46bd      	mov	sp, r7
     734:	bd80      	pop	{r7, pc}
     736:	bf00      	nop
     738:	200000cc 	.word	0x200000cc
     73c:	20004780 	.word	0x20004780
     740:	000091f4 	.word	0x000091f4
     744:	2000f000 	.word	0x2000f000
     748:	00009210 	.word	0x00009210

0000074c <CRC32BZIP2>:
#endif
  
//This technically is a "BZIP2CRC32", not an "ANSICRC32"; seealso: https://crccalc.com/
//Also it should be moved to a CRC32BZIP2.cpp file or somesuch instead of cluttering up main...
uint32_t CRC32BZIP2(const uint8_t* data, const size_t length)
{
     74c:	b480      	push	{r7}
     74e:	b085      	sub	sp, #20
     750:	af00      	add	r7, sp, #0
     752:	6078      	str	r0, [r7, #4]
     754:	6039      	str	r1, [r7, #0]
    0x9ABC8BD5UL,0x9E7D9662UL,0x933EB0BBUL,0x97FFAD0CUL,
    0xAFB010B1UL,0xAB710D06UL,0xA6322BDFUL,0xA2F33668UL,
    0xBCB4666DUL,0xB8757BDAUL,0xB5365D03UL,0xB1F740B4UL,
    };

	uint32_t crc = 0xffffffff;
     756:	f04f 33ff 	mov.w	r3, #4294967295
     75a:	60fb      	str	r3, [r7, #12]
	
	size_t len = length;
     75c:	683b      	ldr	r3, [r7, #0]
     75e:	60bb      	str	r3, [r7, #8]
    while (len > 0)
     760:	e012      	b.n	788 <CRC32BZIP2+0x3c>
    {
      crc = table[*data ^ ((crc >> 24) & 0xff)] ^ (crc << 8);
     762:	687b      	ldr	r3, [r7, #4]
     764:	781b      	ldrb	r3, [r3, #0]
     766:	461a      	mov	r2, r3
     768:	68fb      	ldr	r3, [r7, #12]
     76a:	0e1b      	lsrs	r3, r3, #24
     76c:	4053      	eors	r3, r2
     76e:	4a0b      	ldr	r2, [pc, #44]	@ (79c <CRC32BZIP2+0x50>)
     770:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
     774:	68fb      	ldr	r3, [r7, #12]
     776:	021b      	lsls	r3, r3, #8
     778:	4053      	eors	r3, r2
     77a:	60fb      	str	r3, [r7, #12]
      data++;
     77c:	687b      	ldr	r3, [r7, #4]
     77e:	3301      	adds	r3, #1
     780:	607b      	str	r3, [r7, #4]
      len--;
     782:	68bb      	ldr	r3, [r7, #8]
     784:	3b01      	subs	r3, #1
     786:	60bb      	str	r3, [r7, #8]
    while (len > 0)
     788:	68bb      	ldr	r3, [r7, #8]
     78a:	2b00      	cmp	r3, #0
     78c:	d1e9      	bne.n	762 <CRC32BZIP2+0x16>
    }
    return crc ^ 0xffffffff;
     78e:	68fb      	ldr	r3, [r7, #12]
     790:	43db      	mvns	r3, r3
}
     792:	4618      	mov	r0, r3
     794:	3714      	adds	r7, #20
     796:	46bd      	mov	sp, r7
     798:	bc80      	pop	{r7}
     79a:	4770      	bx	lr
     79c:	00009224 	.word	0x00009224

000007a0 <emit>:

    @return 0 if successful, or EXBADFORMAT if failed.
**/
static int emit( const char *s, size_t n,
                 void * (* cons)(void *, const char *, size_t), void * * parg )
{
     7a0:	b580      	push	{r7, lr}
     7a2:	b084      	sub	sp, #16
     7a4:	af00      	add	r7, sp, #0
     7a6:	60f8      	str	r0, [r7, #12]
     7a8:	60b9      	str	r1, [r7, #8]
     7aa:	607a      	str	r2, [r7, #4]
     7ac:	603b      	str	r3, [r7, #0]
    if ( ( *parg = ( *cons )( *parg, s, n ) ) == NULL )
     7ae:	683b      	ldr	r3, [r7, #0]
     7b0:	6818      	ldr	r0, [r3, #0]
     7b2:	687b      	ldr	r3, [r7, #4]
     7b4:	68ba      	ldr	r2, [r7, #8]
     7b6:	68f9      	ldr	r1, [r7, #12]
     7b8:	4798      	blx	r3
     7ba:	4602      	mov	r2, r0
     7bc:	683b      	ldr	r3, [r7, #0]
     7be:	601a      	str	r2, [r3, #0]
     7c0:	683b      	ldr	r3, [r7, #0]
     7c2:	681b      	ldr	r3, [r3, #0]
     7c4:	2b00      	cmp	r3, #0
     7c6:	d102      	bne.n	7ce <emit+0x2e>
        return EXBADFORMAT;
     7c8:	f04f 33ff 	mov.w	r3, #4294967295
     7cc:	e000      	b.n	7d0 <emit+0x30>
    else
        return 0;
     7ce:	2300      	movs	r3, #0
}
     7d0:	4618      	mov	r0, r3
     7d2:	3710      	adds	r7, #16
     7d4:	46bd      	mov	sp, r7
     7d6:	bd80      	pop	{r7, pc}

000007d8 <pad>:

    @return 0 if successful, or EXBADFORMAT if failed.
**/
static int pad( const char *s, size_t n,
                void * (* cons)(void *, const char *, size_t), void * * parg )
{
     7d8:	b580      	push	{r7, lr}
     7da:	b086      	sub	sp, #24
     7dc:	af00      	add	r7, sp, #0
     7de:	60f8      	str	r0, [r7, #12]
     7e0:	60b9      	str	r1, [r7, #8]
     7e2:	607a      	str	r2, [r7, #4]
     7e4:	603b      	str	r3, [r7, #0]
    while ( n > 0 )
     7e6:	e014      	b.n	812 <pad+0x3a>
    {
        size_t j = MIN( PAD_STRING_LEN, n );
     7e8:	68bb      	ldr	r3, [r7, #8]
     7ea:	2b10      	cmp	r3, #16
     7ec:	bf28      	it	cs
     7ee:	2310      	movcs	r3, #16
     7f0:	617b      	str	r3, [r7, #20]
        if ( emit( s, j, cons, parg ) < 0 )
     7f2:	683b      	ldr	r3, [r7, #0]
     7f4:	687a      	ldr	r2, [r7, #4]
     7f6:	6979      	ldr	r1, [r7, #20]
     7f8:	68f8      	ldr	r0, [r7, #12]
     7fa:	f7ff ffd1 	bl	7a0 <emit>
     7fe:	4603      	mov	r3, r0
     800:	2b00      	cmp	r3, #0
     802:	da02      	bge.n	80a <pad+0x32>
            return EXBADFORMAT;
     804:	f04f 33ff 	mov.w	r3, #4294967295
     808:	e007      	b.n	81a <pad+0x42>
        n -= j;
     80a:	68ba      	ldr	r2, [r7, #8]
     80c:	697b      	ldr	r3, [r7, #20]
     80e:	1ad3      	subs	r3, r2, r3
     810:	60bb      	str	r3, [r7, #8]
    while ( n > 0 )
     812:	68bb      	ldr	r3, [r7, #8]
     814:	2b00      	cmp	r3, #0
     816:	d1e7      	bne.n	7e8 <pad+0x10>
    }
    return 0;
     818:	2300      	movs	r3, #0
}
     81a:	4618      	mov	r0, r3
     81c:	3718      	adds	r7, #24
     81e:	46bd      	mov	sp, r7
     820:	bd80      	pop	{r7, pc}
	...

00000824 <gen_out>:
                    size_t ps1,
                    const char *pfx_s, size_t pfx_n,
                    size_t pz,
                    const char *e_s, size_t e_n,
                    size_t ps2 )
{
     824:	b580      	push	{r7, lr}
     826:	b086      	sub	sp, #24
     828:	af00      	add	r7, sp, #0
     82a:	60f8      	str	r0, [r7, #12]
     82c:	60b9      	str	r1, [r7, #8]
     82e:	607a      	str	r2, [r7, #4]
     830:	603b      	str	r3, [r7, #0]
    size_t n = 0;
     832:	2300      	movs	r3, #0
     834:	617b      	str	r3, [r7, #20]

    if ( ps1 && pad( spaces, ps1, cons, parg ) < 0 )
     836:	687b      	ldr	r3, [r7, #4]
     838:	2b00      	cmp	r3, #0
     83a:	d00b      	beq.n	854 <gen_out+0x30>
     83c:	68bb      	ldr	r3, [r7, #8]
     83e:	68fa      	ldr	r2, [r7, #12]
     840:	6879      	ldr	r1, [r7, #4]
     842:	4830      	ldr	r0, [pc, #192]	@ (904 <gen_out+0xe0>)
     844:	f7ff ffc8 	bl	7d8 <pad>
     848:	4603      	mov	r3, r0
     84a:	2b00      	cmp	r3, #0
     84c:	da02      	bge.n	854 <gen_out+0x30>
        return EXBADFORMAT;
     84e:	f04f 33ff 	mov.w	r3, #4294967295
     852:	e053      	b.n	8fc <gen_out+0xd8>
    n += ps1;
     854:	697a      	ldr	r2, [r7, #20]
     856:	687b      	ldr	r3, [r7, #4]
     858:	4413      	add	r3, r2
     85a:	617b      	str	r3, [r7, #20]

    if ( pfx_s && pfx_n )
     85c:	683b      	ldr	r3, [r7, #0]
     85e:	2b00      	cmp	r3, #0
     860:	d012      	beq.n	888 <gen_out+0x64>
     862:	6a3b      	ldr	r3, [r7, #32]
     864:	2b00      	cmp	r3, #0
     866:	d00f      	beq.n	888 <gen_out+0x64>
    {
        if ( emit( pfx_s, pfx_n, cons, parg ) < 0 )
     868:	68bb      	ldr	r3, [r7, #8]
     86a:	68fa      	ldr	r2, [r7, #12]
     86c:	6a39      	ldr	r1, [r7, #32]
     86e:	6838      	ldr	r0, [r7, #0]
     870:	f7ff ff96 	bl	7a0 <emit>
     874:	4603      	mov	r3, r0
     876:	2b00      	cmp	r3, #0
     878:	da02      	bge.n	880 <gen_out+0x5c>
            return EXBADFORMAT;
     87a:	f04f 33ff 	mov.w	r3, #4294967295
     87e:	e03d      	b.n	8fc <gen_out+0xd8>
        n += pfx_n;
     880:	697a      	ldr	r2, [r7, #20]
     882:	6a3b      	ldr	r3, [r7, #32]
     884:	4413      	add	r3, r2
     886:	617b      	str	r3, [r7, #20]
    }

    if ( pz && pad( zeroes, pz, cons, parg ) < 0 )
     888:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
     88a:	2b00      	cmp	r3, #0
     88c:	d00b      	beq.n	8a6 <gen_out+0x82>
     88e:	68bb      	ldr	r3, [r7, #8]
     890:	68fa      	ldr	r2, [r7, #12]
     892:	6a79      	ldr	r1, [r7, #36]	@ 0x24
     894:	481c      	ldr	r0, [pc, #112]	@ (908 <gen_out+0xe4>)
     896:	f7ff ff9f 	bl	7d8 <pad>
     89a:	4603      	mov	r3, r0
     89c:	2b00      	cmp	r3, #0
     89e:	da02      	bge.n	8a6 <gen_out+0x82>
        return EXBADFORMAT;
     8a0:	f04f 33ff 	mov.w	r3, #4294967295
     8a4:	e02a      	b.n	8fc <gen_out+0xd8>
    n += pz;
     8a6:	697a      	ldr	r2, [r7, #20]
     8a8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
     8aa:	4413      	add	r3, r2
     8ac:	617b      	str	r3, [r7, #20]

    if ( e_n && emit( e_s, e_n, cons, parg ) < 0 )
     8ae:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
     8b0:	2b00      	cmp	r3, #0
     8b2:	d00b      	beq.n	8cc <gen_out+0xa8>
     8b4:	68bb      	ldr	r3, [r7, #8]
     8b6:	68fa      	ldr	r2, [r7, #12]
     8b8:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
     8ba:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
     8bc:	f7ff ff70 	bl	7a0 <emit>
     8c0:	4603      	mov	r3, r0
     8c2:	2b00      	cmp	r3, #0
     8c4:	da02      	bge.n	8cc <gen_out+0xa8>
        return EXBADFORMAT;
     8c6:	f04f 33ff 	mov.w	r3, #4294967295
     8ca:	e017      	b.n	8fc <gen_out+0xd8>
    n += e_n;
     8cc:	697a      	ldr	r2, [r7, #20]
     8ce:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
     8d0:	4413      	add	r3, r2
     8d2:	617b      	str	r3, [r7, #20]

    if ( ps2 && pad( spaces, ps2, cons, parg ) < 0 )
     8d4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
     8d6:	2b00      	cmp	r3, #0
     8d8:	d00b      	beq.n	8f2 <gen_out+0xce>
     8da:	68bb      	ldr	r3, [r7, #8]
     8dc:	68fa      	ldr	r2, [r7, #12]
     8de:	6b39      	ldr	r1, [r7, #48]	@ 0x30
     8e0:	4808      	ldr	r0, [pc, #32]	@ (904 <gen_out+0xe0>)
     8e2:	f7ff ff79 	bl	7d8 <pad>
     8e6:	4603      	mov	r3, r0
     8e8:	2b00      	cmp	r3, #0
     8ea:	da02      	bge.n	8f2 <gen_out+0xce>
        return EXBADFORMAT;
     8ec:	f04f 33ff 	mov.w	r3, #4294967295
     8f0:	e004      	b.n	8fc <gen_out+0xd8>
    n += ps2;
     8f2:	697a      	ldr	r2, [r7, #20]
     8f4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
     8f6:	4413      	add	r3, r2
     8f8:	617b      	str	r3, [r7, #20]

    return (int)n;
     8fa:	697b      	ldr	r3, [r7, #20]
}
     8fc:	4618      	mov	r0, r3
     8fe:	3718      	adds	r7, #24
     900:	46bd      	mov	sp, r7
     902:	bd80      	pop	{r7, pc}
     904:	00009624 	.word	0x00009624
     908:	00009638 	.word	0x00009638

0000090c <calc_space_padding>:
**/
static void calc_space_padding( T_FormatSpec * pspec,
                                size_t         length,
                                size_t *       ps1,
                                size_t *       ps2 )
{
     90c:	b480      	push	{r7}
     90e:	b089      	sub	sp, #36	@ 0x24
     910:	af00      	add	r7, sp, #0
     912:	60f8      	str	r0, [r7, #12]
     914:	60b9      	str	r1, [r7, #8]
     916:	607a      	str	r2, [r7, #4]
     918:	603b      	str	r3, [r7, #0]
    size_t left = 0, right = 0, width = 0;
     91a:	2300      	movs	r3, #0
     91c:	61fb      	str	r3, [r7, #28]
     91e:	2300      	movs	r3, #0
     920:	61bb      	str	r3, [r7, #24]
     922:	2300      	movs	r3, #0
     924:	617b      	str	r3, [r7, #20]

    if ( length < pspec->width )
     926:	68fb      	ldr	r3, [r7, #12]
     928:	689b      	ldr	r3, [r3, #8]
     92a:	461a      	mov	r2, r3
     92c:	68bb      	ldr	r3, [r7, #8]
     92e:	4293      	cmp	r3, r2
     930:	d205      	bcs.n	93e <calc_space_padding+0x32>
        width = pspec->width - length;
     932:	68fb      	ldr	r3, [r7, #12]
     934:	689b      	ldr	r3, [r3, #8]
     936:	461a      	mov	r2, r3
     938:	68bb      	ldr	r3, [r7, #8]
     93a:	1ad3      	subs	r3, r2, r3
     93c:	617b      	str	r3, [r7, #20]

    if ( pspec->flags & FMINUS )
     93e:	68fb      	ldr	r3, [r7, #12]
     940:	685b      	ldr	r3, [r3, #4]
     942:	f003 0304 	and.w	r3, r3, #4
     946:	2b00      	cmp	r3, #0
     948:	d002      	beq.n	950 <calc_space_padding+0x44>
        right = width;
     94a:	697b      	ldr	r3, [r7, #20]
     94c:	61bb      	str	r3, [r7, #24]
     94e:	e001      	b.n	954 <calc_space_padding+0x48>
    else
        left = width;
     950:	697b      	ldr	r3, [r7, #20]
     952:	61fb      	str	r3, [r7, #28]

    if ( pspec->flags & FCARET )
     954:	68fb      	ldr	r3, [r7, #12]
     956:	685b      	ldr	r3, [r3, #4]
     958:	f003 0340 	and.w	r3, r3, #64	@ 0x40
     95c:	2b00      	cmp	r3, #0
     95e:	d015      	beq.n	98c <calc_space_padding+0x80>
    {
        size_t tot = left + right;
     960:	69fa      	ldr	r2, [r7, #28]
     962:	69bb      	ldr	r3, [r7, #24]
     964:	4413      	add	r3, r2
     966:	613b      	str	r3, [r7, #16]
        left       = ( tot + !( pspec->flags & FMINUS ) ) / 2;
     968:	68fb      	ldr	r3, [r7, #12]
     96a:	685b      	ldr	r3, [r3, #4]
     96c:	f003 0304 	and.w	r3, r3, #4
     970:	2b00      	cmp	r3, #0
     972:	bf0c      	ite	eq
     974:	2301      	moveq	r3, #1
     976:	2300      	movne	r3, #0
     978:	b2db      	uxtb	r3, r3
     97a:	461a      	mov	r2, r3
     97c:	693b      	ldr	r3, [r7, #16]
     97e:	4413      	add	r3, r2
     980:	085b      	lsrs	r3, r3, #1
     982:	61fb      	str	r3, [r7, #28]
        right      = tot - left;
     984:	693a      	ldr	r2, [r7, #16]
     986:	69fb      	ldr	r3, [r7, #28]
     988:	1ad3      	subs	r3, r2, r3
     98a:	61bb      	str	r3, [r7, #24]
    }

    if ( ps1 ) *ps1 = left;
     98c:	687b      	ldr	r3, [r7, #4]
     98e:	2b00      	cmp	r3, #0
     990:	d002      	beq.n	998 <calc_space_padding+0x8c>
     992:	687b      	ldr	r3, [r7, #4]
     994:	69fa      	ldr	r2, [r7, #28]
     996:	601a      	str	r2, [r3, #0]
    if ( ps2 ) *ps2 = right;
     998:	683b      	ldr	r3, [r7, #0]
     99a:	2b00      	cmp	r3, #0
     99c:	d002      	beq.n	9a4 <calc_space_padding+0x98>
     99e:	683b      	ldr	r3, [r7, #0]
     9a0:	69ba      	ldr	r2, [r7, #24]
     9a2:	601a      	str	r2, [r3, #0]
}
     9a4:	bf00      	nop
     9a6:	3724      	adds	r7, #36	@ 0x24
     9a8:	46bd      	mov	sp, r7
     9aa:	bc80      	pop	{r7}
     9ac:	4770      	bx	lr
	...

000009b0 <radix_convert>:
**/
static void radix_convert( double              v,
                           unsigned int       *d_sign,
                           DEC_MANT_REG_TYPE  *d_mantissa,
                           int                *d_exponent )
{
     9b0:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
     9b4:	b0a0      	sub	sp, #128	@ 0x80
     9b6:	af00      	add	r7, sp, #0
     9b8:	e9c7 0112 	strd	r0, r1, [r7, #72]	@ 0x48
     9bc:	647a      	str	r2, [r7, #68]	@ 0x44
     9be:	643b      	str	r3, [r7, #64]	@ 0x40
    } bin, dec;

    /* Get the double value into a bit-addressable format with a union and then
    *  extract the mantissa, exponent and sign fields.
    */
    u.fv = v;
     9c0:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	@ 0x48
     9c4:	e9c7 231c 	strd	r2, r3, [r7, #112]	@ 0x70
    bin.mantissa = BIN_UNPACK_MANT( u.bits );
     9c8:	e9d7 231c 	ldrd	r2, r3, [r7, #112]	@ 0x70
     9cc:	4614      	mov	r4, r2
     9ce:	f3c3 0513 	ubfx	r5, r3, #0, #20
     9d2:	e9c7 4518 	strd	r4, r5, [r7, #96]	@ 0x60
    bin.exponent = BIN_UNPACK_EXPO( u.bits );
     9d6:	e9d7 231c 	ldrd	r2, r3, [r7, #112]	@ 0x70
     9da:	f04f 0000 	mov.w	r0, #0
     9de:	f04f 0100 	mov.w	r1, #0
     9e2:	0d18      	lsrs	r0, r3, #20
     9e4:	2100      	movs	r1, #0
     9e6:	4603      	mov	r3, r0
     9e8:	f3c3 030a 	ubfx	r3, r3, #0, #11
     9ec:	66bb      	str	r3, [r7, #104]	@ 0x68
    bin.sign     = BIN_UNPACK_SIGN( u.bits );
     9ee:	e9d7 231c 	ldrd	r2, r3, [r7, #112]	@ 0x70
     9f2:	f04f 0000 	mov.w	r0, #0
     9f6:	f04f 0100 	mov.w	r1, #0
     9fa:	0fd8      	lsrs	r0, r3, #31
     9fc:	2100      	movs	r1, #0
     9fe:	4603      	mov	r3, r0
     a00:	66fb      	str	r3, [r7, #108]	@ 0x6c

    /* Check for +/-inf and NaN.  The indication is the radix-2 exponent being
    *  all-1s.  We mark this in the radix-10 domain by setting the exponent to
    *  INT_MAX.
    */
    if ( bin.exponent == BIN_EXP_MASK )
     a02:	6eba      	ldr	r2, [r7, #104]	@ 0x68
     a04:	f240 73ff 	movw	r3, #2047	@ 0x7ff
     a08:	429a      	cmp	r2, r3
     a0a:	d109      	bne.n	a20 <radix_convert+0x70>
    {
        dec.exponent = INT_MAX;
     a0c:	f06f 4300 	mvn.w	r3, #2147483648	@ 0x80000000
     a10:	65bb      	str	r3, [r7, #88]	@ 0x58
        dec.sign     = bin.sign;
     a12:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
     a14:	65fb      	str	r3, [r7, #92]	@ 0x5c
        dec.mantissa = bin.mantissa;
     a16:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
     a1a:	e9c7 2314 	strd	r2, r3, [r7, #80]	@ 0x50
     a1e:	e0ff      	b.n	c20 <radix_convert+0x270>
    }
    /* Zero (both + and -) is a special case */
    else if ( bin.mantissa == 0 && bin.exponent == 0 )
     a20:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
     a24:	4313      	orrs	r3, r2
     a26:	d10d      	bne.n	a44 <radix_convert+0x94>
     a28:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
     a2a:	2b00      	cmp	r3, #0
     a2c:	d10a      	bne.n	a44 <radix_convert+0x94>
    {
        dec.exponent = 0;
     a2e:	2300      	movs	r3, #0
     a30:	65bb      	str	r3, [r7, #88]	@ 0x58
        dec.mantissa = 0;
     a32:	f04f 0200 	mov.w	r2, #0
     a36:	f04f 0300 	mov.w	r3, #0
     a3a:	e9c7 2314 	strd	r2, r3, [r7, #80]	@ 0x50
        dec.sign     = bin.sign;
     a3e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
     a40:	65fb      	str	r3, [r7, #92]	@ 0x5c
     a42:	e0ed      	b.n	c20 <radix_convert+0x270>
    }
    else
    {
        DEC_MANT_REG_TYPE inc;

        dec.sign     = bin.sign;
     a44:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
     a46:	65fb      	str	r3, [r7, #92]	@ 0x5c

        /* Load initial conditions for conversion */
        if ( bin.exponent == 0 ) /* then this is a denormal */
     a48:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
     a4a:	2b00      	cmp	r3, #0
     a4c:	d121      	bne.n	a92 <radix_convert+0xe2>
        {
            bin.exponent = 1;
     a4e:	2301      	movs	r3, #1
     a50:	66bb      	str	r3, [r7, #104]	@ 0x68
            dec.mantissa = 0;
     a52:	f04f 0200 	mov.w	r2, #0
     a56:	f04f 0300 	mov.w	r3, #0
     a5a:	e9c7 2314 	strd	r2, r3, [r7, #80]	@ 0x50
            dec.exponent = 0;
     a5e:	2300      	movs	r3, #0
     a60:	65bb      	str	r3, [r7, #88]	@ 0x58
            
            while ( 0 == ( bin.mantissa & ( BIN_MANT_SINGLE_BIT << ( BIN_MANT_WIDTH - 1 ) ) ) )
     a62:	e00c      	b.n	a7e <radix_convert+0xce>
            {
                bin.mantissa <<= 1;
     a64:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
     a68:	1891      	adds	r1, r2, r2
     a6a:	61b9      	str	r1, [r7, #24]
     a6c:	415b      	adcs	r3, r3
     a6e:	61fb      	str	r3, [r7, #28]
     a70:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
     a74:	e9c7 2318 	strd	r2, r3, [r7, #96]	@ 0x60
                bin.exponent--;
     a78:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
     a7a:	3b01      	subs	r3, #1
     a7c:	66bb      	str	r3, [r7, #104]	@ 0x68
            while ( 0 == ( bin.mantissa & ( BIN_MANT_SINGLE_BIT << ( BIN_MANT_WIDTH - 1 ) ) ) )
     a7e:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
     a82:	f04f 0a00 	mov.w	sl, #0
     a86:	f403 2b00 	and.w	fp, r3, #524288	@ 0x80000
     a8a:	ea5a 030b 	orrs.w	r3, sl, fp
     a8e:	d0e9      	beq.n	a64 <radix_convert+0xb4>
     a90:	e006      	b.n	aa0 <radix_convert+0xf0>
            }
        }
        else /* this is a normal number with a assumed leading "1." */
        {
            dec.mantissa = DEC_1P0;
     a92:	a375      	add	r3, pc, #468	@ (adr r3, c68 <radix_convert+0x2b8>)
     a94:	e9d3 2300 	ldrd	r2, r3, [r3]
     a98:	e9c7 2314 	strd	r2, r3, [r7, #80]	@ 0x50
            dec.exponent = 0;
     a9c:	2300      	movs	r3, #0
     a9e:	65bb      	str	r3, [r7, #88]	@ 0x58
        }

        /* STEP 1: compute decimal mantissa */
        inc = ( DEC_1P0 + 1 ) / 2;
     aa0:	a373      	add	r3, pc, #460	@ (adr r3, c70 <radix_convert+0x2c0>)
     aa2:	e9d3 2300 	ldrd	r2, r3, [r3]
     aa6:	e9c7 231e 	strd	r2, r3, [r7, #120]	@ 0x78
        bin.mantissa <<= BIN_MANT_LEFT_ALIGN;
     aaa:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
     aae:	f04f 0000 	mov.w	r0, #0
     ab2:	f04f 0100 	mov.w	r1, #0
     ab6:	0319      	lsls	r1, r3, #12
     ab8:	ea41 5112 	orr.w	r1, r1, r2, lsr #20
     abc:	0310      	lsls	r0, r2, #12
     abe:	e9c7 0118 	strd	r0, r1, [r7, #96]	@ 0x60
        while ( bin.mantissa )
     ac2:	e031      	b.n	b28 <radix_convert+0x178>
        {
            if ( bin.mantissa & BIN_MANT_REG_TOP_BIT )
     ac4:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
     ac8:	2b00      	cmp	r3, #0
     aca:	da0c      	bge.n	ae6 <radix_convert+0x136>
                dec.mantissa += inc;
     acc:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	@ 0x50
     ad0:	e9d7 231e 	ldrd	r2, r3, [r7, #120]	@ 0x78
     ad4:	1884      	adds	r4, r0, r2
     ad6:	63bc      	str	r4, [r7, #56]	@ 0x38
     ad8:	eb41 0303 	adc.w	r3, r1, r3
     adc:	63fb      	str	r3, [r7, #60]	@ 0x3c
     ade:	e9d7 340e 	ldrd	r3, r4, [r7, #56]	@ 0x38
     ae2:	e9c7 3414 	strd	r3, r4, [r7, #80]	@ 0x50

            bin.mantissa <<= 1;
     ae6:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
     aea:	1891      	adds	r1, r2, r2
     aec:	6139      	str	r1, [r7, #16]
     aee:	415b      	adcs	r3, r3
     af0:	617b      	str	r3, [r7, #20]
     af2:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
     af6:	e9c7 2318 	strd	r2, r3, [r7, #96]	@ 0x60
            inc = ( inc + 1 ) / 2;
     afa:	e9d7 231e 	ldrd	r2, r3, [r7, #120]	@ 0x78
     afe:	1c51      	adds	r1, r2, #1
     b00:	6339      	str	r1, [r7, #48]	@ 0x30
     b02:	f143 0300 	adc.w	r3, r3, #0
     b06:	637b      	str	r3, [r7, #52]	@ 0x34
     b08:	f04f 0200 	mov.w	r2, #0
     b0c:	f04f 0300 	mov.w	r3, #0
     b10:	e9d7 450c 	ldrd	r4, r5, [r7, #48]	@ 0x30
     b14:	4621      	mov	r1, r4
     b16:	084a      	lsrs	r2, r1, #1
     b18:	4620      	mov	r0, r4
     b1a:	4629      	mov	r1, r5
     b1c:	460c      	mov	r4, r1
     b1e:	ea42 72c4 	orr.w	r2, r2, r4, lsl #31
     b22:	084b      	lsrs	r3, r1, #1
     b24:	e9c7 231e 	strd	r2, r3, [r7, #120]	@ 0x78
        while ( bin.mantissa )
     b28:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
     b2c:	4313      	orrs	r3, r2
     b2e:	d1c9      	bne.n	ac4 <radix_convert+0x114>
        /* STEP 2: convert base-2 exponent to base-10 exponent,
         *          adjusting mantissa accordingly.
         *         treat positive and negative exponents separately to keep as
         *          much information in the mantissa as possible.
         */
        bin.exponent -= BIN_EXP_BIAS;  /* Subtract exponent bias */
     b30:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
     b32:	f2a3 33ff 	subw	r3, r3, #1023	@ 0x3ff
     b36:	66bb      	str	r3, [r7, #104]	@ 0x68
        for ( ; bin.exponent > 0; bin.exponent-- )
     b38:	e029      	b.n	b8e <radix_convert+0x1de>
        {
            dec.mantissa *= 2;
     b3a:	e9d7 2314 	ldrd	r2, r3, [r7, #80]	@ 0x50
     b3e:	1891      	adds	r1, r2, r2
     b40:	60b9      	str	r1, [r7, #8]
     b42:	415b      	adcs	r3, r3
     b44:	60fb      	str	r3, [r7, #12]
     b46:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
     b4a:	e9c7 2314 	strd	r2, r3, [r7, #80]	@ 0x50
            if ( dec.mantissa >= ( DEC_1P0 * 10 ) )
     b4e:	e9d7 2314 	ldrd	r2, r3, [r7, #80]	@ 0x50
     b52:	4941      	ldr	r1, [pc, #260]	@ (c58 <radix_convert+0x2a8>)
     b54:	428a      	cmp	r2, r1
     b56:	4941      	ldr	r1, [pc, #260]	@ (c5c <radix_convert+0x2ac>)
     b58:	418b      	sbcs	r3, r1
     b5a:	d315      	bcc.n	b88 <radix_convert+0x1d8>
            {
                dec.mantissa = ( dec.mantissa + 5 ) / 10;
     b5c:	e9d7 2314 	ldrd	r2, r3, [r7, #80]	@ 0x50
     b60:	1d51      	adds	r1, r2, #5
     b62:	62b9      	str	r1, [r7, #40]	@ 0x28
     b64:	f143 0300 	adc.w	r3, r3, #0
     b68:	62fb      	str	r3, [r7, #44]	@ 0x2c
     b6a:	f04f 020a 	mov.w	r2, #10
     b6e:	f04f 0300 	mov.w	r3, #0
     b72:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	@ 0x28
     b76:	f008 f9a5 	bl	8ec4 <__aeabi_uldivmod>
     b7a:	4602      	mov	r2, r0
     b7c:	460b      	mov	r3, r1
     b7e:	e9c7 2314 	strd	r2, r3, [r7, #80]	@ 0x50
                dec.exponent++;
     b82:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
     b84:	3301      	adds	r3, #1
     b86:	65bb      	str	r3, [r7, #88]	@ 0x58
        for ( ; bin.exponent > 0; bin.exponent-- )
     b88:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
     b8a:	3b01      	subs	r3, #1
     b8c:	66bb      	str	r3, [r7, #104]	@ 0x68
     b8e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
     b90:	2b00      	cmp	r3, #0
     b92:	dcd2      	bgt.n	b3a <radix_convert+0x18a>
            }
        }
        for ( ; bin.exponent < 0; bin.exponent++ )
     b94:	e041      	b.n	c1a <radix_convert+0x26a>
        {
            if ( dec.mantissa < ( ( DEC_1P0 * 2 ) ) )
     b96:	e9d7 2314 	ldrd	r2, r3, [r7, #80]	@ 0x50
     b9a:	4931      	ldr	r1, [pc, #196]	@ (c60 <radix_convert+0x2b0>)
     b9c:	428a      	cmp	r2, r1
     b9e:	4931      	ldr	r1, [pc, #196]	@ (c64 <radix_convert+0x2b4>)
     ba0:	418b      	sbcs	r3, r1
     ba2:	d220      	bcs.n	be6 <radix_convert+0x236>
            {
                dec.mantissa *= 10;
     ba4:	e9d7 4514 	ldrd	r4, r5, [r7, #80]	@ 0x50
     ba8:	4622      	mov	r2, r4
     baa:	462b      	mov	r3, r5
     bac:	f04f 0000 	mov.w	r0, #0
     bb0:	f04f 0100 	mov.w	r1, #0
     bb4:	0099      	lsls	r1, r3, #2
     bb6:	ea41 7192 	orr.w	r1, r1, r2, lsr #30
     bba:	0090      	lsls	r0, r2, #2
     bbc:	4602      	mov	r2, r0
     bbe:	460b      	mov	r3, r1
     bc0:	eb12 0804 	adds.w	r8, r2, r4
     bc4:	eb43 0905 	adc.w	r9, r3, r5
     bc8:	eb18 0308 	adds.w	r3, r8, r8
     bcc:	603b      	str	r3, [r7, #0]
     bce:	eb49 0309 	adc.w	r3, r9, r9
     bd2:	607b      	str	r3, [r7, #4]
     bd4:	e9d7 8900 	ldrd	r8, r9, [r7]
     bd8:	4642      	mov	r2, r8
     bda:	464b      	mov	r3, r9
     bdc:	e9c7 2314 	strd	r2, r3, [r7, #80]	@ 0x50
                dec.exponent--;
     be0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
     be2:	3b01      	subs	r3, #1
     be4:	65bb      	str	r3, [r7, #88]	@ 0x58
            }
            dec.mantissa = ( dec.mantissa + 1 ) / 2;
     be6:	e9d7 2314 	ldrd	r2, r3, [r7, #80]	@ 0x50
     bea:	1c51      	adds	r1, r2, #1
     bec:	6239      	str	r1, [r7, #32]
     bee:	f143 0300 	adc.w	r3, r3, #0
     bf2:	627b      	str	r3, [r7, #36]	@ 0x24
     bf4:	f04f 0200 	mov.w	r2, #0
     bf8:	f04f 0300 	mov.w	r3, #0
     bfc:	e9d7 4508 	ldrd	r4, r5, [r7, #32]
     c00:	4621      	mov	r1, r4
     c02:	084a      	lsrs	r2, r1, #1
     c04:	4620      	mov	r0, r4
     c06:	4629      	mov	r1, r5
     c08:	460c      	mov	r4, r1
     c0a:	ea42 72c4 	orr.w	r2, r2, r4, lsl #31
     c0e:	084b      	lsrs	r3, r1, #1
     c10:	e9c7 2314 	strd	r2, r3, [r7, #80]	@ 0x50
        for ( ; bin.exponent < 0; bin.exponent++ )
     c14:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
     c16:	3301      	adds	r3, #1
     c18:	66bb      	str	r3, [r7, #104]	@ 0x68
     c1a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
     c1c:	2b00      	cmp	r3, #0
     c1e:	dbba      	blt.n	b96 <radix_convert+0x1e6>
        }
    }

    if ( d_sign     ) *d_sign     = dec.sign;
     c20:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
     c22:	2b00      	cmp	r3, #0
     c24:	d002      	beq.n	c2c <radix_convert+0x27c>
     c26:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
     c28:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
     c2a:	601a      	str	r2, [r3, #0]
    if ( d_mantissa ) *d_mantissa = dec.mantissa;
     c2c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
     c2e:	2b00      	cmp	r3, #0
     c30:	d004      	beq.n	c3c <radix_convert+0x28c>
     c32:	e9d7 2314 	ldrd	r2, r3, [r7, #80]	@ 0x50
     c36:	6c39      	ldr	r1, [r7, #64]	@ 0x40
     c38:	e9c1 2300 	strd	r2, r3, [r1]
    if ( d_exponent ) *d_exponent = dec.exponent;
     c3c:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
     c40:	2b00      	cmp	r3, #0
     c42:	d003      	beq.n	c4c <radix_convert+0x29c>
     c44:	6dba      	ldr	r2, [r7, #88]	@ 0x58
     c46:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
     c4a:	601a      	str	r2, [r3, #0]
}
     c4c:	bf00      	nop
     c4e:	3780      	adds	r7, #128	@ 0x80
     c50:	46bd      	mov	sp, r7
     c52:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
     c56:	bf00      	nop
     c58:	6fc10000 	.word	0x6fc10000
     c5c:	002386f2 	.word	0x002386f2
     c60:	498d0000 	.word	0x498d0000
     c64:	00071afd 	.word	0x00071afd
     c68:	a4c68000 	.word	0xa4c68000
     c6c:	00038d7e 	.word	0x00038d7e
     c70:	52634000 	.word	0x52634000
     c74:	0001c6bf 	.word	0x0001c6bf

00000c78 <mant_to_char>:
**/
static int mant_to_char( char * buf,
                         DEC_MANT_REG_TYPE m,
                         int digits_total,
                         int digits_to_convert )
{
     c78:	b580      	push	{r7, lr}
     c7a:	b086      	sub	sp, #24
     c7c:	af00      	add	r7, sp, #0
     c7e:	60f8      	str	r0, [r7, #12]
     c80:	e9c7 2300 	strd	r2, r3, [r7]
    int i;

    for ( i = digits_total - digits_to_convert; i > 0; i-- )
     c84:	6a3a      	ldr	r2, [r7, #32]
     c86:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
     c88:	1ad3      	subs	r3, r2, r3
     c8a:	617b      	str	r3, [r7, #20]
     c8c:	e00e      	b.n	cac <mant_to_char+0x34>
    {
        m /= 10;
     c8e:	e9d7 0100 	ldrd	r0, r1, [r7]
     c92:	f04f 020a 	mov.w	r2, #10
     c96:	f04f 0300 	mov.w	r3, #0
     c9a:	f008 f913 	bl	8ec4 <__aeabi_uldivmod>
     c9e:	4602      	mov	r2, r0
     ca0:	460b      	mov	r3, r1
     ca2:	e9c7 2300 	strd	r2, r3, [r7]
    for ( i = digits_total - digits_to_convert; i > 0; i-- )
     ca6:	697b      	ldr	r3, [r7, #20]
     ca8:	3b01      	subs	r3, #1
     caa:	617b      	str	r3, [r7, #20]
     cac:	697b      	ldr	r3, [r7, #20]
     cae:	2b00      	cmp	r3, #0
     cb0:	dced      	bgt.n	c8e <mant_to_char+0x16>
    }

    for ( i = digits_to_convert; i; i-- )
     cb2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
     cb4:	617b      	str	r3, [r7, #20]
     cb6:	e022      	b.n	cfe <mant_to_char+0x86>
    {
        unsigned int d = m % 10;
     cb8:	e9d7 0100 	ldrd	r0, r1, [r7]
     cbc:	f04f 020a 	mov.w	r2, #10
     cc0:	f04f 0300 	mov.w	r3, #0
     cc4:	f008 f8fe 	bl	8ec4 <__aeabi_uldivmod>
     cc8:	4613      	mov	r3, r2
     cca:	613b      	str	r3, [r7, #16]

        buf[i-1] = '0' + d;
     ccc:	693b      	ldr	r3, [r7, #16]
     cce:	b2db      	uxtb	r3, r3
     cd0:	3330      	adds	r3, #48	@ 0x30
     cd2:	b2d9      	uxtb	r1, r3
     cd4:	697b      	ldr	r3, [r7, #20]
     cd6:	3b01      	subs	r3, #1
     cd8:	68fa      	ldr	r2, [r7, #12]
     cda:	4413      	add	r3, r2
     cdc:	b24a      	sxtb	r2, r1
     cde:	701a      	strb	r2, [r3, #0]
        m /= 10;
     ce0:	e9d7 0100 	ldrd	r0, r1, [r7]
     ce4:	f04f 020a 	mov.w	r2, #10
     ce8:	f04f 0300 	mov.w	r3, #0
     cec:	f008 f8ea 	bl	8ec4 <__aeabi_uldivmod>
     cf0:	4602      	mov	r2, r0
     cf2:	460b      	mov	r3, r1
     cf4:	e9c7 2300 	strd	r2, r3, [r7]
    for ( i = digits_to_convert; i; i-- )
     cf8:	697b      	ldr	r3, [r7, #20]
     cfa:	3b01      	subs	r3, #1
     cfc:	617b      	str	r3, [r7, #20]
     cfe:	697b      	ldr	r3, [r7, #20]
     d00:	2b00      	cmp	r3, #0
     d02:	d1d9      	bne.n	cb8 <mant_to_char+0x40>
    }

    return digits_to_convert;
     d04:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
     d06:	4618      	mov	r0, r3
     d08:	3718      	adds	r7, #24
     d0a:	46bd      	mov	sp, r7
     d0c:	bd80      	pop	{r7, pc}
	...

00000d10 <do_conv_infnan>:
                           void *          (* cons)(void *, const char *, size_t),
                           void * *           parg,
                           unsigned int       sign,
                           DEC_MANT_REG_TYPE  mantissa,
                           int                exponent )
{
     d10:	b580      	push	{r7, lr}
     d12:	b090      	sub	sp, #64	@ 0x40
     d14:	af06      	add	r7, sp, #24
     d16:	60f8      	str	r0, [r7, #12]
     d18:	607a      	str	r2, [r7, #4]
     d1a:	603b      	str	r3, [r7, #0]
     d1c:	460b      	mov	r3, r1
     d1e:	72fb      	strb	r3, [r7, #11]
    const char * pfx_s;
    size_t pfx_n;
    const char * e_s;
    size_t e_n;
    size_t ps1 = 0, ps2 = 0;
     d20:	2300      	movs	r3, #0
     d22:	617b      	str	r3, [r7, #20]
     d24:	2300      	movs	r3, #0
     d26:	613b      	str	r3, [r7, #16]

    if ( DEC_FP_IS_NAN( sign, mantissa, exponent ) )
     d28:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
     d2a:	f06f 4200 	mvn.w	r2, #2147483648	@ 0x80000000
     d2e:	4293      	cmp	r3, r2
     d30:	d115      	bne.n	d5e <do_conv_infnan+0x4e>
     d32:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
     d36:	4313      	orrs	r3, r2
     d38:	d011      	beq.n	d5e <do_conv_infnan+0x4e>
        if ( code == 'f' || code == 'e' || code == 'g' )
     d3a:	f997 300b 	ldrsb.w	r3, [r7, #11]
     d3e:	2b66      	cmp	r3, #102	@ 0x66
     d40:	d007      	beq.n	d52 <do_conv_infnan+0x42>
     d42:	f997 300b 	ldrsb.w	r3, [r7, #11]
     d46:	2b65      	cmp	r3, #101	@ 0x65
     d48:	d003      	beq.n	d52 <do_conv_infnan+0x42>
     d4a:	f997 300b 	ldrsb.w	r3, [r7, #11]
     d4e:	2b67      	cmp	r3, #103	@ 0x67
     d50:	d102      	bne.n	d58 <do_conv_infnan+0x48>
            e_s = "nan";
     d52:	4b2f      	ldr	r3, [pc, #188]	@ (e10 <do_conv_infnan+0x100>)
     d54:	623b      	str	r3, [r7, #32]
        if ( code == 'f' || code == 'e' || code == 'g' )
     d56:	e013      	b.n	d80 <do_conv_infnan+0x70>
        else
            e_s = "NAN";
     d58:	4b2e      	ldr	r3, [pc, #184]	@ (e14 <do_conv_infnan+0x104>)
     d5a:	623b      	str	r3, [r7, #32]
        if ( code == 'f' || code == 'e' || code == 'g' )
     d5c:	e010      	b.n	d80 <do_conv_infnan+0x70>
    else
        if ( code == 'f' || code == 'e' || code == 'g' )
     d5e:	f997 300b 	ldrsb.w	r3, [r7, #11]
     d62:	2b66      	cmp	r3, #102	@ 0x66
     d64:	d007      	beq.n	d76 <do_conv_infnan+0x66>
     d66:	f997 300b 	ldrsb.w	r3, [r7, #11]
     d6a:	2b65      	cmp	r3, #101	@ 0x65
     d6c:	d003      	beq.n	d76 <do_conv_infnan+0x66>
     d6e:	f997 300b 	ldrsb.w	r3, [r7, #11]
     d72:	2b67      	cmp	r3, #103	@ 0x67
     d74:	d102      	bne.n	d7c <do_conv_infnan+0x6c>
            e_s = "inf";
     d76:	4b28      	ldr	r3, [pc, #160]	@ (e18 <do_conv_infnan+0x108>)
     d78:	623b      	str	r3, [r7, #32]
     d7a:	e001      	b.n	d80 <do_conv_infnan+0x70>
        else
            e_s = "INF";
     d7c:	4b27      	ldr	r3, [pc, #156]	@ (e1c <do_conv_infnan+0x10c>)
     d7e:	623b      	str	r3, [r7, #32]

    e_n = STRLEN(e_s);
     d80:	6a38      	ldr	r0, [r7, #32]
     d82:	f006 fb76 	bl	7472 <strlen>
     d86:	61f8      	str	r0, [r7, #28]

    if ( sign )
     d88:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
     d8a:	2b00      	cmp	r3, #0
     d8c:	d002      	beq.n	d94 <do_conv_infnan+0x84>
        pfx_s = "-";
     d8e:	4b24      	ldr	r3, [pc, #144]	@ (e20 <do_conv_infnan+0x110>)
     d90:	627b      	str	r3, [r7, #36]	@ 0x24
     d92:	e019      	b.n	dc8 <do_conv_infnan+0xb8>
    else if ( !sign && pspec->flags & FPLUS )
     d94:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
     d96:	2b00      	cmp	r3, #0
     d98:	d108      	bne.n	dac <do_conv_infnan+0x9c>
     d9a:	68fb      	ldr	r3, [r7, #12]
     d9c:	685b      	ldr	r3, [r3, #4]
     d9e:	f003 0302 	and.w	r3, r3, #2
     da2:	2b00      	cmp	r3, #0
     da4:	d002      	beq.n	dac <do_conv_infnan+0x9c>
        pfx_s = "+";
     da6:	4b1f      	ldr	r3, [pc, #124]	@ (e24 <do_conv_infnan+0x114>)
     da8:	627b      	str	r3, [r7, #36]	@ 0x24
     daa:	e00d      	b.n	dc8 <do_conv_infnan+0xb8>
    else if ( !sign && pspec->flags & FSPACE )
     dac:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
     dae:	2b00      	cmp	r3, #0
     db0:	d108      	bne.n	dc4 <do_conv_infnan+0xb4>
     db2:	68fb      	ldr	r3, [r7, #12]
     db4:	685b      	ldr	r3, [r3, #4]
     db6:	f003 0301 	and.w	r3, r3, #1
     dba:	2b00      	cmp	r3, #0
     dbc:	d002      	beq.n	dc4 <do_conv_infnan+0xb4>
        pfx_s = " ";
     dbe:	4b1a      	ldr	r3, [pc, #104]	@ (e28 <do_conv_infnan+0x118>)
     dc0:	627b      	str	r3, [r7, #36]	@ 0x24
     dc2:	e001      	b.n	dc8 <do_conv_infnan+0xb8>
    else
        pfx_s = "";
     dc4:	4b19      	ldr	r3, [pc, #100]	@ (e2c <do_conv_infnan+0x11c>)
     dc6:	627b      	str	r3, [r7, #36]	@ 0x24
    pfx_n = STRLEN( pfx_s );
     dc8:	6a78      	ldr	r0, [r7, #36]	@ 0x24
     dca:	f006 fb52 	bl	7472 <strlen>
     dce:	61b8      	str	r0, [r7, #24]

    calc_space_padding( pspec, e_n + pfx_n, &ps1, &ps2 );
     dd0:	69fa      	ldr	r2, [r7, #28]
     dd2:	69bb      	ldr	r3, [r7, #24]
     dd4:	18d1      	adds	r1, r2, r3
     dd6:	f107 0310 	add.w	r3, r7, #16
     dda:	f107 0214 	add.w	r2, r7, #20
     dde:	68f8      	ldr	r0, [r7, #12]
     de0:	f7ff fd94 	bl	90c <calc_space_padding>

    return gen_out( cons, parg, ps1, pfx_s, pfx_n, 0, e_s, e_n, ps2 );
     de4:	697a      	ldr	r2, [r7, #20]
     de6:	693b      	ldr	r3, [r7, #16]
     de8:	9304      	str	r3, [sp, #16]
     dea:	69fb      	ldr	r3, [r7, #28]
     dec:	9303      	str	r3, [sp, #12]
     dee:	6a3b      	ldr	r3, [r7, #32]
     df0:	9302      	str	r3, [sp, #8]
     df2:	2300      	movs	r3, #0
     df4:	9301      	str	r3, [sp, #4]
     df6:	69bb      	ldr	r3, [r7, #24]
     df8:	9300      	str	r3, [sp, #0]
     dfa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
     dfc:	6839      	ldr	r1, [r7, #0]
     dfe:	6878      	ldr	r0, [r7, #4]
     e00:	f7ff fd10 	bl	824 <gen_out>
     e04:	4603      	mov	r3, r0
}
     e06:	4618      	mov	r0, r3
     e08:	3728      	adds	r7, #40	@ 0x28
     e0a:	46bd      	mov	sp, r7
     e0c:	bd80      	pop	{r7, pc}
     e0e:	bf00      	nop
     e10:	0000964c 	.word	0x0000964c
     e14:	00009650 	.word	0x00009650
     e18:	00009654 	.word	0x00009654
     e1c:	00009658 	.word	0x00009658
     e20:	0000965c 	.word	0x0000965c
     e24:	00009660 	.word	0x00009660
     e28:	00009664 	.word	0x00009664
     e2c:	00009668 	.word	0x00009668

00000e30 <round_mantissa>:
    @param compressed           True if using compressed engineering or 
                                   scientific formatting
**/
static void round_mantissa( DEC_MANT_REG_TYPE *mantissa, int *exponent, 
                            int prec, int is_f, int really_g, int compressed )
{
     e30:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
     e34:	b08a      	sub	sp, #40	@ 0x28
     e36:	af00      	add	r7, sp, #0
     e38:	60f8      	str	r0, [r7, #12]
     e3a:	60b9      	str	r1, [r7, #8]
     e3c:	607a      	str	r2, [r7, #4]
     e3e:	603b      	str	r3, [r7, #0]
      output.  The exponent tells us how many of the digits in the
      mantissa are after the decimal point.

    */

   DEC_MANT_REG_TYPE addend = DEC_1P0 * 5;
     e40:	a348      	add	r3, pc, #288	@ (adr r3, f64 <round_mantissa+0x134>)
     e42:	e9d3 2300 	ldrd	r2, r3, [r3]
     e46:	e9c7 2308 	strd	r2, r3, [r7, #32]
   int shift = 0;
     e4a:	2300      	movs	r3, #0
     e4c:	61fb      	str	r3, [r7, #28]
   int e = *exponent;
     e4e:	68bb      	ldr	r3, [r7, #8]
     e50:	681b      	ldr	r3, [r3, #0]
     e52:	61bb      	str	r3, [r7, #24]

   if ( compressed )
     e54:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
     e56:	2b00      	cmp	r3, #0
     e58:	d021      	beq.n	e9e <round_mantissa+0x6e>
   {
      e %= 3;
     e5a:	69ba      	ldr	r2, [r7, #24]
     e5c:	4b3e      	ldr	r3, [pc, #248]	@ (f58 <round_mantissa+0x128>)
     e5e:	fb83 3102 	smull	r3, r1, r3, r2
     e62:	17d3      	asrs	r3, r2, #31
     e64:	1ac9      	subs	r1, r1, r3
     e66:	460b      	mov	r3, r1
     e68:	005b      	lsls	r3, r3, #1
     e6a:	440b      	add	r3, r1
     e6c:	1ad3      	subs	r3, r2, r3
     e6e:	61bb      	str	r3, [r7, #24]

      if ( e < 0 )
     e70:	69bb      	ldr	r3, [r7, #24]
     e72:	2b00      	cmp	r3, #0
     e74:	da02      	bge.n	e7c <round_mantissa+0x4c>
         e += 3;
     e76:	69bb      	ldr	r3, [r7, #24]
     e78:	3303      	adds	r3, #3
     e7a:	61bb      	str	r3, [r7, #24]

      if ( is_f )
     e7c:	683b      	ldr	r3, [r7, #0]
     e7e:	2b00      	cmp	r3, #0
     e80:	d00d      	beq.n	e9e <round_mantissa+0x6e>
      {
         /* Scientific notation has limited suffixes */
         int absexp = ABS(*exponent);
     e82:	68bb      	ldr	r3, [r7, #8]
     e84:	681b      	ldr	r3, [r3, #0]
     e86:	2b00      	cmp	r3, #0
     e88:	bfb8      	it	lt
     e8a:	425b      	neglt	r3, r3
     e8c:	617b      	str	r3, [r7, #20]
         if ( absexp > COMP_EXP_LIMIT ) e += ( absexp - COMP_EXP_LIMIT );
     e8e:	697b      	ldr	r3, [r7, #20]
     e90:	2b18      	cmp	r3, #24
     e92:	dd04      	ble.n	e9e <round_mantissa+0x6e>
     e94:	697b      	ldr	r3, [r7, #20]
     e96:	3b18      	subs	r3, #24
     e98:	69ba      	ldr	r2, [r7, #24]
     e9a:	4413      	add	r3, r2
     e9c:	61bb      	str	r3, [r7, #24]
      }

      DEBUG_LOG( "round_mantissa(): compressed exponent = %d\n", e );
   }

   if ( !is_f )
     e9e:	683b      	ldr	r3, [r7, #0]
     ea0:	2b00      	cmp	r3, #0
     ea2:	d10a      	bne.n	eba <round_mantissa+0x8a>
   {
      /* e/E always has one digit to the left of DP */

      if ( e < 0 ) e++;
     ea4:	69bb      	ldr	r3, [r7, #24]
     ea6:	2b00      	cmp	r3, #0
     ea8:	da02      	bge.n	eb0 <round_mantissa+0x80>
     eaa:	69bb      	ldr	r3, [r7, #24]
     eac:	3301      	adds	r3, #1
     eae:	61bb      	str	r3, [r7, #24]
      e = ABS(e);
     eb0:	69bb      	ldr	r3, [r7, #24]
     eb2:	2b00      	cmp	r3, #0
     eb4:	bfb8      	it	lt
     eb6:	425b      	neglt	r3, r3
     eb8:	61bb      	str	r3, [r7, #24]
   }
   shift = e + prec + 1;
     eba:	69ba      	ldr	r2, [r7, #24]
     ebc:	687b      	ldr	r3, [r7, #4]
     ebe:	4413      	add	r3, r2
     ec0:	3301      	adds	r3, #1
     ec2:	61fb      	str	r3, [r7, #28]
   shift = MAX( shift, 0 );
     ec4:	69fb      	ldr	r3, [r7, #28]
     ec6:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
     eca:	61fb      	str	r3, [r7, #28]

   DEBUG_LOG( "round_mantissa(): shift = %d\n", shift );


   while ( shift-- )
     ecc:	e00b      	b.n	ee6 <round_mantissa+0xb6>
      addend /= 10;
     ece:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
     ed2:	f04f 020a 	mov.w	r2, #10
     ed6:	f04f 0300 	mov.w	r3, #0
     eda:	f007 fff3 	bl	8ec4 <__aeabi_uldivmod>
     ede:	4602      	mov	r2, r0
     ee0:	460b      	mov	r3, r1
     ee2:	e9c7 2308 	strd	r2, r3, [r7, #32]
   while ( shift-- )
     ee6:	69fb      	ldr	r3, [r7, #28]
     ee8:	1e5a      	subs	r2, r3, #1
     eea:	61fa      	str	r2, [r7, #28]
     eec:	2b00      	cmp	r3, #0
     eee:	d1ee      	bne.n	ece <round_mantissa+0x9e>

   *mantissa += addend;
     ef0:	68fb      	ldr	r3, [r7, #12]
     ef2:	e9d3 0100 	ldrd	r0, r1, [r3]
     ef6:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
     efa:	1884      	adds	r4, r0, r2
     efc:	eb41 0503 	adc.w	r5, r1, r3
     f00:	68fb      	ldr	r3, [r7, #12]
     f02:	e9c3 4500 	strd	r4, r5, [r3]

   /* Catch integer portion overflow */
   if ( *mantissa >= ( DEC_1P0 * 10 ) )
     f06:	68fb      	ldr	r3, [r7, #12]
     f08:	e9d3 2300 	ldrd	r2, r3, [r3]
     f0c:	4913      	ldr	r1, [pc, #76]	@ (f5c <round_mantissa+0x12c>)
     f0e:	428a      	cmp	r2, r1
     f10:	4913      	ldr	r1, [pc, #76]	@ (f60 <round_mantissa+0x130>)
     f12:	418b      	sbcs	r3, r1
     f14:	d318      	bcc.n	f48 <round_mantissa+0x118>
   {
      *mantissa = ( *mantissa + 5 ) / 10;
     f16:	68fb      	ldr	r3, [r7, #12]
     f18:	e9d3 2300 	ldrd	r2, r3, [r3]
     f1c:	f112 0805 	adds.w	r8, r2, #5
     f20:	f143 0900 	adc.w	r9, r3, #0
     f24:	f04f 020a 	mov.w	r2, #10
     f28:	f04f 0300 	mov.w	r3, #0
     f2c:	4640      	mov	r0, r8
     f2e:	4649      	mov	r1, r9
     f30:	f007 ffc8 	bl	8ec4 <__aeabi_uldivmod>
     f34:	4602      	mov	r2, r0
     f36:	460b      	mov	r3, r1
     f38:	68f9      	ldr	r1, [r7, #12]
     f3a:	e9c1 2300 	strd	r2, r3, [r1]
      *exponent += 1;
     f3e:	68bb      	ldr	r3, [r7, #8]
     f40:	681b      	ldr	r3, [r3, #0]
     f42:	1c5a      	adds	r2, r3, #1
     f44:	68bb      	ldr	r3, [r7, #8]
     f46:	601a      	str	r2, [r3, #0]
      DEBUG_LOG( "round_mantissa(): integer overflow (new exponent: %d)\n", *exponent );
   }
}
     f48:	bf00      	nop
     f4a:	3728      	adds	r7, #40	@ 0x28
     f4c:	46bd      	mov	sp, r7
     f4e:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
     f52:	bf00      	nop
     f54:	f3af 8000 	nop.w
     f58:	55555556 	.word	0x55555556
     f5c:	6fc10000 	.word	0x6fc10000
     f60:	002386f2 	.word	0x002386f2
     f64:	37e08000 	.word	0x37e08000
     f68:	0011c379 	.word	0x0011c379

00000f6c <do_conv_efg>:
                        void *          (* cons)(void *, const char *, size_t),
                        void * *           parg,
                        unsigned int       sign,
                        DEC_MANT_REG_TYPE  mantissa,
                        int                exponent )
{
     f6c:	b580      	push	{r7, lr}
     f6e:	b0aa      	sub	sp, #168	@ 0xa8
     f70:	af06      	add	r7, sp, #24
     f72:	60f8      	str	r0, [r7, #12]
     f74:	607a      	str	r2, [r7, #4]
     f76:	603b      	str	r3, [r7, #0]
     f78:	460b      	mov	r3, r1
     f7a:	72fb      	strb	r3, [r7, #11]
    int sigfig = 0;
     f7c:	2300      	movs	r3, #0
     f7e:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
    const char * pfx_s;
    size_t pfx_n;
    char   e_s[DEC_SIG_FIG];
    size_t e_n = 0;
     f82:	2300      	movs	r3, #0
     f84:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
    size_t length = 0;
     f88:	2300      	movs	r3, #0
     f8a:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
    size_t ps1 = 0, ps2 = 0;
     f8e:	2300      	movs	r3, #0
     f90:	61bb      	str	r3, [r7, #24]
     f92:	2300      	movs	r3, #0
     f94:	617b      	str	r3, [r7, #20]
    size_t pz1 = 0, pz2 = 0, pz3 = 0, pz4 = 0;
     f96:	2300      	movs	r3, #0
     f98:	67fb      	str	r3, [r7, #124]	@ 0x7c
     f9a:	2300      	movs	r3, #0
     f9c:	67bb      	str	r3, [r7, #120]	@ 0x78
     f9e:	2300      	movs	r3, #0
     fa0:	677b      	str	r3, [r7, #116]	@ 0x74
     fa2:	2300      	movs	r3, #0
     fa4:	673b      	str	r3, [r7, #112]	@ 0x70
    int count = 0;
     fa6:	2300      	movs	r3, #0
     fa8:	66fb      	str	r3, [r7, #108]	@ 0x6c
    int n;
    int want_dp = 0;
     faa:	2300      	movs	r3, #0
     fac:	66bb      	str	r3, [r7, #104]	@ 0x68
    int n_left, n_right;
    int i;
    size_t n_exp = 0;
     fae:	2300      	movs	r3, #0
     fb0:	65bb      	str	r3, [r7, #88]	@ 0x58
    int really_g = 0;
     fb2:	2300      	movs	r3, #0
     fb4:	657b      	str	r3, [r7, #84]	@ 0x54
    int is_f = 0;
     fb6:	2300      	movs	r3, #0
     fb8:	653b      	str	r3, [r7, #80]	@ 0x50
    char si = '\0';
     fba:	2300      	movs	r3, #0
     fbc:	74fb      	strb	r3, [r7, #19]

    /* "g,G   ... style e (or E) is used only if the exponent resulting from
     *        such a conversion is less than -4 or greater than or equal to the
     *        precision."
     */
    if ( code == 'g' || code == 'G' )
     fbe:	f997 300b 	ldrsb.w	r3, [r7, #11]
     fc2:	2b67      	cmp	r3, #103	@ 0x67
     fc4:	d003      	beq.n	fce <do_conv_efg+0x62>
     fc6:	f997 300b 	ldrsb.w	r3, [r7, #11]
     fca:	2b47      	cmp	r3, #71	@ 0x47
     fcc:	d123      	bne.n	1016 <MAIN_STACK_SIZE+0x16>
    {
        /* Make a note that we were called with 'g' or 'G'. */
        really_g = 1;
     fce:	2301      	movs	r3, #1
     fd0:	657b      	str	r3, [r7, #84]	@ 0x54

        /* Turn off the '!' flag - just too messy with g/G */
        pspec->flags &= ~FBANG;
     fd2:	68fb      	ldr	r3, [r7, #12]
     fd4:	685b      	ldr	r3, [r3, #4]
     fd6:	f023 0220 	bic.w	r2, r3, #32
     fda:	68fb      	ldr	r3, [r7, #12]
     fdc:	605a      	str	r2, [r3, #4]

        /* Then convert the g/G into e/E or f/F as appropriate. */
        if ( exponent < -4 || exponent >= pspec->prec )
     fde:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
     fe2:	f113 0f04 	cmn.w	r3, #4
     fe6:	db05      	blt.n	ff4 <do_conv_efg+0x88>
     fe8:	68fb      	ldr	r3, [r7, #12]
     fea:	68da      	ldr	r2, [r3, #12]
     fec:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
     ff0:	429a      	cmp	r2, r3
     ff2:	dc08      	bgt.n	1006 <MAIN_STACK_SIZE+0x6>
            code = (code == 'g') ? 'e' : 'E';
     ff4:	f997 300b 	ldrsb.w	r3, [r7, #11]
     ff8:	2b67      	cmp	r3, #103	@ 0x67
     ffa:	d101      	bne.n	1000 <MAIN_STACK_SIZE>
     ffc:	2365      	movs	r3, #101	@ 0x65
     ffe:	e000      	b.n	1002 <MAIN_STACK_SIZE+0x2>
    1000:	2345      	movs	r3, #69	@ 0x45
    1002:	72fb      	strb	r3, [r7, #11]
    1004:	e007      	b.n	1016 <MAIN_STACK_SIZE+0x16>
        else
            code = (code == 'g') ? 'f' : 'F';
    1006:	f997 300b 	ldrsb.w	r3, [r7, #11]
    100a:	2b67      	cmp	r3, #103	@ 0x67
    100c:	d101      	bne.n	1012 <MAIN_STACK_SIZE+0x12>
    100e:	2366      	movs	r3, #102	@ 0x66
    1010:	e000      	b.n	1014 <MAIN_STACK_SIZE+0x14>
    1012:	2346      	movs	r3, #70	@ 0x46
    1014:	72fb      	strb	r3, [r7, #11]
    }

    if ( code == 'f' || code == 'F' )
    1016:	f997 300b 	ldrsb.w	r3, [r7, #11]
    101a:	2b66      	cmp	r3, #102	@ 0x66
    101c:	d003      	beq.n	1026 <MAIN_STACK_SIZE+0x26>
    101e:	f997 300b 	ldrsb.w	r3, [r7, #11]
    1022:	2b46      	cmp	r3, #70	@ 0x46
    1024:	d101      	bne.n	102a <MAIN_STACK_SIZE+0x2a>
        is_f = 1;   
    1026:	2301      	movs	r3, #1
    1028:	653b      	str	r3, [r7, #80]	@ 0x50

    /* Apply default precision */
    if ( pspec->prec < 0 )
    102a:	68fb      	ldr	r3, [r7, #12]
    102c:	68db      	ldr	r3, [r3, #12]
    102e:	2b00      	cmp	r3, #0
    1030:	da02      	bge.n	1038 <MAIN_STACK_SIZE+0x38>
        pspec->prec = 6;
    1032:	68fb      	ldr	r3, [r7, #12]
    1034:	2206      	movs	r2, #6
    1036:	60da      	str	r2, [r3, #12]

    if ( really_g )
    1038:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
    103a:	2b00      	cmp	r3, #0
    103c:	d006      	beq.n	104c <MAIN_STACK_SIZE+0x4c>
    {
        /* g/G: "If the precision is zero, it is taken as 1." */
        if ( pspec->prec == 0 )
    103e:	68fb      	ldr	r3, [r7, #12]
    1040:	68db      	ldr	r3, [r3, #12]
    1042:	2b00      	cmp	r3, #0
    1044:	d102      	bne.n	104c <MAIN_STACK_SIZE+0x4c>
            pspec->prec = 1;
    1046:	68fb      	ldr	r3, [r7, #12]
    1048:	2201      	movs	r2, #1
    104a:	60da      	str	r2, [r3, #12]
    }

    /* Generate the prefix, if any */
    if ( sign )
    104c:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
    1050:	2b00      	cmp	r3, #0
    1052:	d003      	beq.n	105c <MAIN_STACK_SIZE+0x5c>
        pfx_s = "-";
    1054:	4bab      	ldr	r3, [pc, #684]	@ (1304 <MAIN_STACK_SIZE+0x304>)
    1056:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
    105a:	e01e      	b.n	109a <MAIN_STACK_SIZE+0x9a>
    else if ( !sign && pspec->flags & FPLUS )
    105c:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
    1060:	2b00      	cmp	r3, #0
    1062:	d109      	bne.n	1078 <MAIN_STACK_SIZE+0x78>
    1064:	68fb      	ldr	r3, [r7, #12]
    1066:	685b      	ldr	r3, [r3, #4]
    1068:	f003 0302 	and.w	r3, r3, #2
    106c:	2b00      	cmp	r3, #0
    106e:	d003      	beq.n	1078 <MAIN_STACK_SIZE+0x78>
        pfx_s = "+";
    1070:	4ba5      	ldr	r3, [pc, #660]	@ (1308 <MAIN_STACK_SIZE+0x308>)
    1072:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
    1076:	e010      	b.n	109a <MAIN_STACK_SIZE+0x9a>
    else if ( !sign && pspec->flags & FSPACE )
    1078:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
    107c:	2b00      	cmp	r3, #0
    107e:	d109      	bne.n	1094 <MAIN_STACK_SIZE+0x94>
    1080:	68fb      	ldr	r3, [r7, #12]
    1082:	685b      	ldr	r3, [r3, #4]
    1084:	f003 0301 	and.w	r3, r3, #1
    1088:	2b00      	cmp	r3, #0
    108a:	d003      	beq.n	1094 <MAIN_STACK_SIZE+0x94>
        pfx_s = " ";
    108c:	4b9f      	ldr	r3, [pc, #636]	@ (130c <MAIN_STACK_SIZE+0x30c>)
    108e:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
    1092:	e002      	b.n	109a <MAIN_STACK_SIZE+0x9a>
    else
        pfx_s = "";
    1094:	4b9e      	ldr	r3, [pc, #632]	@ (1310 <MAIN_STACK_SIZE+0x310>)
    1096:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
    pfx_n = STRLEN( pfx_s );
    109a:	f8d7 0088 	ldr.w	r0, [r7, #136]	@ 0x88
    109e:	f006 f9e8 	bl	7472 <strlen>
    10a2:	6378      	str	r0, [r7, #52]	@ 0x34

    /* Perform any rounding on the mantissa prior to formatting */
    round_mantissa( &mantissa, &exponent, pspec->prec, is_f, really_g, pspec->flags & FBANG );
    10a4:	68fb      	ldr	r3, [r7, #12]
    10a6:	68da      	ldr	r2, [r3, #12]
    10a8:	68fb      	ldr	r3, [r7, #12]
    10aa:	685b      	ldr	r3, [r3, #4]
    10ac:	f003 0320 	and.w	r3, r3, #32
    10b0:	f107 01a8 	add.w	r1, r7, #168	@ 0xa8
    10b4:	f107 00a0 	add.w	r0, r7, #160	@ 0xa0
    10b8:	9301      	str	r3, [sp, #4]
    10ba:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
    10bc:	9300      	str	r3, [sp, #0]
    10be:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
    10c0:	f7ff feb6 	bl	e30 <round_mantissa>

    /* Trim trailing zeros from mantissa and compute no. of sig.figures */
    if ( mantissa )
    10c4:	e9d7 2328 	ldrd	r2, r3, [r7, #160]	@ 0xa0
    10c8:	4313      	orrs	r3, r2
    10ca:	d024      	beq.n	1116 <MAIN_STACK_SIZE+0x116>
        for ( sigfig = DEC_SIG_FIG; sigfig; sigfig--, mantissa /= 10 )
    10cc:	2310      	movs	r3, #16
    10ce:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
    10d2:	e01a      	b.n	110a <MAIN_STACK_SIZE+0x10a>
            if ( mantissa % 10 )
    10d4:	e9d7 0128 	ldrd	r0, r1, [r7, #160]	@ 0xa0
    10d8:	f04f 020a 	mov.w	r2, #10
    10dc:	f04f 0300 	mov.w	r3, #0
    10e0:	f007 fef0 	bl	8ec4 <__aeabi_uldivmod>
    10e4:	4313      	orrs	r3, r2
    10e6:	d115      	bne.n	1114 <MAIN_STACK_SIZE+0x114>
        for ( sigfig = DEC_SIG_FIG; sigfig; sigfig--, mantissa /= 10 )
    10e8:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
    10ec:	3b01      	subs	r3, #1
    10ee:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
    10f2:	e9d7 0128 	ldrd	r0, r1, [r7, #160]	@ 0xa0
    10f6:	f04f 020a 	mov.w	r2, #10
    10fa:	f04f 0300 	mov.w	r3, #0
    10fe:	f007 fee1 	bl	8ec4 <__aeabi_uldivmod>
    1102:	4602      	mov	r2, r0
    1104:	460b      	mov	r3, r1
    1106:	e9c7 2328 	strd	r2, r3, [r7, #160]	@ 0xa0
    110a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
    110e:	2b00      	cmp	r3, #0
    1110:	d1e0      	bne.n	10d4 <MAIN_STACK_SIZE+0xd4>
    1112:	e000      	b.n	1116 <MAIN_STACK_SIZE+0x116>
                break;
    1114:	bf00      	nop

    DEBUG_LOG( "sigfig: %d\n", sigfig );

    /* Work out how many digits on each side of the DP */
    if ( is_f )
    1116:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
    1118:	2b00      	cmp	r3, #0
    111a:	d037      	beq.n	118c <MAIN_STACK_SIZE+0x18c>
    {
        if ( pspec->flags & FBANG )
    111c:	68fb      	ldr	r3, [r7, #12]
    111e:	685b      	ldr	r3, [r3, #4]
    1120:	f003 0320 	and.w	r3, r3, #32
    1124:	2b00      	cmp	r3, #0
    1126:	d02a      	beq.n	117e <MAIN_STACK_SIZE+0x17e>
        {
            static char sitab[] = { 'y', 'z', 'a', 'f', 'p', 'n', 'u', 'm',
                                    '\0', 
                                    'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y' };
            int idx = NELEMS(sitab) / 2;
    1128:	2308      	movs	r3, #8
    112a:	64fb      	str	r3, [r7, #76]	@ 0x4c

            while ( idx > 0 && idx < (NELEMS(sitab) - 1) )
    112c:	e019      	b.n	1162 <MAIN_STACK_SIZE+0x162>
            {
                if ( exponent >= 3 ) { idx++; exponent -= 3; continue; }
    112e:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
    1132:	2b02      	cmp	r3, #2
    1134:	dd08      	ble.n	1148 <MAIN_STACK_SIZE+0x148>
    1136:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
    1138:	3301      	adds	r3, #1
    113a:	64fb      	str	r3, [r7, #76]	@ 0x4c
    113c:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
    1140:	3b03      	subs	r3, #3
    1142:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    1146:	e00c      	b.n	1162 <MAIN_STACK_SIZE+0x162>
                if ( exponent <  0 ) { idx--; exponent += 3; continue; }
    1148:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
    114c:	2b00      	cmp	r3, #0
    114e:	da0f      	bge.n	1170 <MAIN_STACK_SIZE+0x170>
    1150:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
    1152:	3b01      	subs	r3, #1
    1154:	64fb      	str	r3, [r7, #76]	@ 0x4c
    1156:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
    115a:	3303      	adds	r3, #3
    115c:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    1160:	bf00      	nop
            while ( idx > 0 && idx < (NELEMS(sitab) - 1) )
    1162:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
    1164:	2b00      	cmp	r3, #0
    1166:	dd04      	ble.n	1172 <MAIN_STACK_SIZE+0x172>
    1168:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
    116a:	2b0f      	cmp	r3, #15
    116c:	d9df      	bls.n	112e <MAIN_STACK_SIZE+0x12e>
    116e:	e000      	b.n	1172 <MAIN_STACK_SIZE+0x172>
                break;
    1170:	bf00      	nop
            }
            si = sitab[idx];
    1172:	4a68      	ldr	r2, [pc, #416]	@ (1314 <MAIN_STACK_SIZE+0x314>)
    1174:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
    1176:	4413      	add	r3, r2
    1178:	f993 3000 	ldrsb.w	r3, [r3]
    117c:	74fb      	strb	r3, [r7, #19]
        }

        n_left = exponent > -1 ? 1 + exponent : 0;
    117e:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
    1182:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
    1186:	3301      	adds	r3, #1
    1188:	667b      	str	r3, [r7, #100]	@ 0x64
    118a:	e023      	b.n	11d4 <MAIN_STACK_SIZE+0x1d4>
    }
    else /* must be 'e' */
    {
        n_left = 1;
    118c:	2301      	movs	r3, #1
    118e:	667b      	str	r3, [r7, #100]	@ 0x64

        /* Engineering format forces exponent to multiple of 3 */
        if ( pspec->flags & FBANG )
    1190:	68fb      	ldr	r3, [r7, #12]
    1192:	685b      	ldr	r3, [r3, #4]
    1194:	f003 0320 	and.w	r3, r3, #32
    1198:	2b00      	cmp	r3, #0
    119a:	d01b      	beq.n	11d4 <MAIN_STACK_SIZE+0x1d4>
        {
           int m = exponent % 3;
    119c:	f8d7 20a8 	ldr.w	r2, [r7, #168]	@ 0xa8
    11a0:	4b5d      	ldr	r3, [pc, #372]	@ (1318 <MAIN_STACK_SIZE+0x318>)
    11a2:	fb83 3102 	smull	r3, r1, r3, r2
    11a6:	17d3      	asrs	r3, r2, #31
    11a8:	1ac9      	subs	r1, r1, r3
    11aa:	460b      	mov	r3, r1
    11ac:	005b      	lsls	r3, r3, #1
    11ae:	440b      	add	r3, r1
    11b0:	1ad3      	subs	r3, r2, r3
    11b2:	64bb      	str	r3, [r7, #72]	@ 0x48

           if ( m < 0 )
    11b4:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
    11b6:	2b00      	cmp	r3, #0
    11b8:	da02      	bge.n	11c0 <MAIN_STACK_SIZE+0x1c0>
              m += 3;
    11ba:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
    11bc:	3303      	adds	r3, #3
    11be:	64bb      	str	r3, [r7, #72]	@ 0x48
           n_left   += m;
    11c0:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
    11c2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
    11c4:	4413      	add	r3, r2
    11c6:	667b      	str	r3, [r7, #100]	@ 0x64
           exponent -= m;
    11c8:	f8d7 20a8 	ldr.w	r2, [r7, #168]	@ 0xa8
    11cc:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
    11ce:	1ad3      	subs	r3, r2, r3
    11d0:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
        }
    }

    n_right = MIN( MAX( sigfig - n_left, 0 ), pspec->prec );
    11d4:	68fb      	ldr	r3, [r7, #12]
    11d6:	68da      	ldr	r2, [r3, #12]
    11d8:	f8d7 108c 	ldr.w	r1, [r7, #140]	@ 0x8c
    11dc:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
    11de:	1acb      	subs	r3, r1, r3
    11e0:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    11e4:	4293      	cmp	r3, r2
    11e6:	bfa8      	it	ge
    11e8:	4613      	movge	r3, r2
    11ea:	663b      	str	r3, [r7, #96]	@ 0x60

    /* The g-as-f conversion strips out additional digits */
    if ( is_f && really_g )
    11ec:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
    11ee:	2b00      	cmp	r3, #0
    11f0:	d03c      	beq.n	126c <MAIN_STACK_SIZE+0x26c>
    11f2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
    11f4:	2b00      	cmp	r3, #0
    11f6:	d039      	beq.n	126c <MAIN_STACK_SIZE+0x26c>
    {
        DEC_MANT_REG_TYPE  m = mantissa;
    11f8:	e9d7 2328 	ldrd	r2, r3, [r7, #160]	@ 0xa0
    11fc:	e9c7 2310 	strd	r2, r3, [r7, #64]	@ 0x40
        int j;

        /* strip extraneous digits */
        for ( j = sigfig; j > n_left + n_right; j--, m /= 10 );
    1200:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
    1204:	63fb      	str	r3, [r7, #60]	@ 0x3c
    1206:	e00e      	b.n	1226 <MAIN_STACK_SIZE+0x226>
    1208:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
    120a:	3b01      	subs	r3, #1
    120c:	63fb      	str	r3, [r7, #60]	@ 0x3c
    120e:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	@ 0x40
    1212:	f04f 020a 	mov.w	r2, #10
    1216:	f04f 0300 	mov.w	r3, #0
    121a:	f007 fe53 	bl	8ec4 <__aeabi_uldivmod>
    121e:	4602      	mov	r2, r0
    1220:	460b      	mov	r3, r1
    1222:	e9c7 2310 	strd	r2, r3, [r7, #64]	@ 0x40
    1226:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
    1228:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    122a:	4413      	add	r3, r2
    122c:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
    122e:	429a      	cmp	r2, r3
    1230:	dcea      	bgt.n	1208 <MAIN_STACK_SIZE+0x208>

        /* strip trailing zeros */
        for ( ; n_right > 0 && m % 10 == 0; m /= 10, n_right-- );
    1232:	e00e      	b.n	1252 <MAIN_STACK_SIZE+0x252>
    1234:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	@ 0x40
    1238:	f04f 020a 	mov.w	r2, #10
    123c:	f04f 0300 	mov.w	r3, #0
    1240:	f007 fe40 	bl	8ec4 <__aeabi_uldivmod>
    1244:	4602      	mov	r2, r0
    1246:	460b      	mov	r3, r1
    1248:	e9c7 2310 	strd	r2, r3, [r7, #64]	@ 0x40
    124c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    124e:	3b01      	subs	r3, #1
    1250:	663b      	str	r3, [r7, #96]	@ 0x60
    1252:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    1254:	2b00      	cmp	r3, #0
    1256:	dd09      	ble.n	126c <MAIN_STACK_SIZE+0x26c>
    1258:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	@ 0x40
    125c:	f04f 020a 	mov.w	r2, #10
    1260:	f04f 0300 	mov.w	r3, #0
    1264:	f007 fe2e 	bl	8ec4 <__aeabi_uldivmod>
    1268:	4313      	orrs	r3, r2
    126a:	d0e3      	beq.n	1234 <MAIN_STACK_SIZE+0x234>

    DEBUG_LOG( "n_left: %d ", n_left );
    DEBUG_LOG( "n_right: %d\n", n_right );

    /* Compute length of the actual generated text */
    length = pfx_n + n_left + n_right;
    126c:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
    126e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    1270:	441a      	add	r2, r3
    1272:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    1274:	4413      	add	r3, r2
    1276:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80

    if ( is_f )
    127a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
    127c:	2b00      	cmp	r3, #0
    127e:	d038      	beq.n	12f2 <MAIN_STACK_SIZE+0x2f2>
    {
        /* If nothing on the left make sure we have a '0' */
        if ( n_left == 0 )
    1280:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
    1282:	2b00      	cmp	r3, #0
    1284:	d106      	bne.n	1294 <MAIN_STACK_SIZE+0x294>
        {
            pz1 = 1;
    1286:	2301      	movs	r3, #1
    1288:	67fb      	str	r3, [r7, #124]	@ 0x7c
            length++;
    128a:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
    128e:	3301      	adds	r3, #1
    1290:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
        }

        /* Add any zero padding after figures but before DP */
        if ( n_left > sigfig )
    1294:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
    1296:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
    129a:	429a      	cmp	r2, r3
    129c:	dd04      	ble.n	12a8 <MAIN_STACK_SIZE+0x2a8>
            pz2 = n_left - sigfig;
    129e:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
    12a0:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
    12a4:	1ad3      	subs	r3, r2, r3
    12a6:	67bb      	str	r3, [r7, #120]	@ 0x78

        /* Add any zero padding between DP and figures on right */
        if ( exponent < -1 && pspec->prec > 0 )
    12a8:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
    12ac:	f1b3 3fff 	cmp.w	r3, #4294967295
    12b0:	da15      	bge.n	12de <MAIN_STACK_SIZE+0x2de>
    12b2:	68fb      	ldr	r3, [r7, #12]
    12b4:	68db      	ldr	r3, [r3, #12]
    12b6:	2b00      	cmp	r3, #0
    12b8:	dd11      	ble.n	12de <MAIN_STACK_SIZE+0x2de>
        {
            pz3 = -1 - exponent;
    12ba:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
    12be:	43db      	mvns	r3, r3
    12c0:	677b      	str	r3, [r7, #116]	@ 0x74
            pz3 = MIN( pz3, pspec->prec );
    12c2:	68fb      	ldr	r3, [r7, #12]
    12c4:	68db      	ldr	r3, [r3, #12]
    12c6:	461a      	mov	r2, r3
    12c8:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
    12ca:	4293      	cmp	r3, r2
    12cc:	bf28      	it	cs
    12ce:	4613      	movcs	r3, r2
    12d0:	677b      	str	r3, [r7, #116]	@ 0x74
            length += pz3;
    12d2:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
    12d6:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
    12d8:	4413      	add	r3, r2
    12da:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
        }

        /* Include any SI multiplier suffix */
        if ( si )
    12de:	f997 3013 	ldrsb.w	r3, [r7, #19]
    12e2:	2b00      	cmp	r3, #0
    12e4:	d034      	beq.n	1350 <MAIN_STACK_SIZE+0x350>
            length++;
    12e6:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
    12ea:	3301      	adds	r3, #1
    12ec:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
    12f0:	e02e      	b.n	1350 <MAIN_STACK_SIZE+0x350>
    else /* is 'e' */
    {
        /* Add length of exponent suffix, remembering that the length of the
         *  exponent field is minimum of 2.
         */
        for ( i = ABS(exponent), n_exp = 0; i > 0; n_exp++, i /= 10 )
    12f2:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
    12f6:	2b00      	cmp	r3, #0
    12f8:	bfb8      	it	lt
    12fa:	425b      	neglt	r3, r3
    12fc:	65fb      	str	r3, [r7, #92]	@ 0x5c
    12fe:	2300      	movs	r3, #0
    1300:	65bb      	str	r3, [r7, #88]	@ 0x58
    1302:	e016      	b.n	1332 <MAIN_STACK_SIZE+0x332>
    1304:	0000965c 	.word	0x0000965c
    1308:	00009660 	.word	0x00009660
    130c:	00009664 	.word	0x00009664
    1310:	00009668 	.word	0x00009668
    1314:	20000000 	.word	0x20000000
    1318:	55555556 	.word	0x55555556
    131c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
    131e:	3301      	adds	r3, #1
    1320:	65bb      	str	r3, [r7, #88]	@ 0x58
    1322:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
    1324:	4a9c      	ldr	r2, [pc, #624]	@ (1598 <MAIN_STACK_SIZE+0x598>)
    1326:	fb82 1203 	smull	r1, r2, r2, r3
    132a:	1092      	asrs	r2, r2, #2
    132c:	17db      	asrs	r3, r3, #31
    132e:	1ad3      	subs	r3, r2, r3
    1330:	65fb      	str	r3, [r7, #92]	@ 0x5c
    1332:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
    1334:	2b00      	cmp	r3, #0
    1336:	dcf1      	bgt.n	131c <MAIN_STACK_SIZE+0x31c>
            ;

        n_exp = MAX( n_exp, 2 );
    1338:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
    133a:	2b02      	cmp	r3, #2
    133c:	bf38      	it	cc
    133e:	2302      	movcc	r3, #2
    1340:	65bb      	str	r3, [r7, #88]	@ 0x58

        /* Total length = 'e'/'E' + sign + 'dd..d' */
        length += 2 + n_exp;
    1342:	6dba      	ldr	r2, [r7, #88]	@ 0x58
    1344:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
    1348:	4413      	add	r3, r2
    134a:	3302      	adds	r3, #2
    134c:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
    }

    /* Compute trailing zeros */
    if ( pz3 + n_right < pspec->prec
    1350:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
    1352:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
    1354:	4413      	add	r3, r2
    1356:	68fa      	ldr	r2, [r7, #12]
    1358:	68d2      	ldr	r2, [r2, #12]
    135a:	4293      	cmp	r3, r2
    135c:	d217      	bcs.n	138e <MAIN_STACK_SIZE+0x38e>
         /* g,G     ... Trailing zeros are removed from the fractional portion
          *         of the result unless the # flag is specified; ...
          */
        && !( really_g && !(pspec->flags & FHASH) )
    135e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
    1360:	2b00      	cmp	r3, #0
    1362:	d005      	beq.n	1370 <MAIN_STACK_SIZE+0x370>
    1364:	68fb      	ldr	r3, [r7, #12]
    1366:	685b      	ldr	r3, [r3, #4]
    1368:	f003 0308 	and.w	r3, r3, #8
    136c:	2b00      	cmp	r3, #0
    136e:	d00e      	beq.n	138e <MAIN_STACK_SIZE+0x38e>
       )
    {
        pz4 = pspec->prec - pz3 - n_right;
    1370:	68fb      	ldr	r3, [r7, #12]
    1372:	68db      	ldr	r3, [r3, #12]
    1374:	461a      	mov	r2, r3
    1376:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
    1378:	1ad2      	subs	r2, r2, r3
    137a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    137c:	1ad3      	subs	r3, r2, r3
    137e:	673b      	str	r3, [r7, #112]	@ 0x70
        length += pz4;
    1380:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
    1384:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
    1386:	4413      	add	r3, r2
    1388:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
    138c:	e01a      	b.n	13c4 <MAIN_STACK_SIZE+0x3c4>
    }
    else if ( is_f && pz3 + n_right > pspec->prec )
    138e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
    1390:	2b00      	cmp	r3, #0
    1392:	d017      	beq.n	13c4 <MAIN_STACK_SIZE+0x3c4>
    1394:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
    1396:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
    1398:	4413      	add	r3, r2
    139a:	68fa      	ldr	r2, [r7, #12]
    139c:	68d2      	ldr	r2, [r2, #12]
    139e:	4293      	cmp	r3, r2
    13a0:	d910      	bls.n	13c4 <MAIN_STACK_SIZE+0x3c4>
    {
        int x = pz3 + n_right - pspec->prec;
    13a2:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
    13a4:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
    13a6:	4413      	add	r3, r2
    13a8:	68fa      	ldr	r2, [r7, #12]
    13aa:	68d2      	ldr	r2, [r2, #12]
    13ac:	1a9b      	subs	r3, r3, r2
    13ae:	633b      	str	r3, [r7, #48]	@ 0x30
        length  -= x;
    13b0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    13b2:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
    13b6:	1ad3      	subs	r3, r2, r3
    13b8:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
        n_right -= x;
    13bc:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
    13be:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    13c0:	1ad3      	subs	r3, r2, r3
    13c2:	663b      	str	r3, [r7, #96]	@ 0x60
    }

    /* Add DP if required */
    if ( ( pz3 || pz4 ) || n_right > 0 || pspec->flags & FHASH )
    13c4:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
    13c6:	2b00      	cmp	r3, #0
    13c8:	d10b      	bne.n	13e2 <MAIN_STACK_SIZE+0x3e2>
    13ca:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
    13cc:	2b00      	cmp	r3, #0
    13ce:	d108      	bne.n	13e2 <MAIN_STACK_SIZE+0x3e2>
    13d0:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    13d2:	2b00      	cmp	r3, #0
    13d4:	dc05      	bgt.n	13e2 <MAIN_STACK_SIZE+0x3e2>
    13d6:	68fb      	ldr	r3, [r7, #12]
    13d8:	685b      	ldr	r3, [r3, #4]
    13da:	f003 0308 	and.w	r3, r3, #8
    13de:	2b00      	cmp	r3, #0
    13e0:	d006      	beq.n	13f0 <MAIN_STACK_SIZE+0x3f0>
    {
        want_dp = 1;
    13e2:	2301      	movs	r3, #1
    13e4:	66bb      	str	r3, [r7, #104]	@ 0x68
        length++;
    13e6:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
    13ea:	3301      	adds	r3, #1
    13ec:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
    }

    calc_space_padding( pspec, length, &ps1, &ps2 );
    13f0:	f107 0314 	add.w	r3, r7, #20
    13f4:	f107 0218 	add.w	r2, r7, #24
    13f8:	f8d7 1080 	ldr.w	r1, [r7, #128]	@ 0x80
    13fc:	68f8      	ldr	r0, [r7, #12]
    13fe:	f7ff fa85 	bl	90c <calc_space_padding>

    /* Convert space padding into zero padding if we have the ZERO flag */
    if ( pspec->flags & FZERO )
    1402:	68fb      	ldr	r3, [r7, #12]
    1404:	685b      	ldr	r3, [r3, #4]
    1406:	f003 0310 	and.w	r3, r3, #16
    140a:	2b00      	cmp	r3, #0
    140c:	d005      	beq.n	141a <MAIN_STACK_SIZE+0x41a>
    {
        pz1 += ps1;
    140e:	69bb      	ldr	r3, [r7, #24]
    1410:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
    1412:	4413      	add	r3, r2
    1414:	67fb      	str	r3, [r7, #124]	@ 0x7c
        ps1 = 0;
    1416:	2300      	movs	r3, #0
    1418:	61bb      	str	r3, [r7, #24]

    /* Generate the output sections */

    /* LEFT, including leading space and prefix */
    e_n = n_left ? mant_to_char( e_s, mantissa, sigfig, n_left - pz2 )
                 : 0;
    141a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
    141c:	2b00      	cmp	r3, #0
    141e:	d00e      	beq.n	143e <MAIN_STACK_SIZE+0x43e>
    e_n = n_left ? mant_to_char( e_s, mantissa, sigfig, n_left - pz2 )
    1420:	e9d7 2328 	ldrd	r2, r3, [r7, #160]	@ 0xa0
    1424:	6e78      	ldr	r0, [r7, #100]	@ 0x64
    1426:	6fb9      	ldr	r1, [r7, #120]	@ 0x78
    1428:	1a41      	subs	r1, r0, r1
    142a:	f107 001c 	add.w	r0, r7, #28
    142e:	9101      	str	r1, [sp, #4]
    1430:	f8d7 108c 	ldr.w	r1, [r7, #140]	@ 0x8c
    1434:	9100      	str	r1, [sp, #0]
    1436:	f7ff fc1f 	bl	c78 <mant_to_char>
    143a:	4603      	mov	r3, r0
    143c:	e000      	b.n	1440 <MAIN_STACK_SIZE+0x440>
                 : 0;
    143e:	2300      	movs	r3, #0
    e_n = n_left ? mant_to_char( e_s, mantissa, sigfig, n_left - pz2 )
    1440:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84

    sigfig -= e_n;
    1444:	f8d7 208c 	ldr.w	r2, [r7, #140]	@ 0x8c
    1448:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
    144c:	1ad3      	subs	r3, r2, r3
    144e:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c

    n = gen_out( cons, parg, ps1, pfx_s, pfx_n, pz1, e_s, e_n, 0 );
    1452:	69ba      	ldr	r2, [r7, #24]
    1454:	2300      	movs	r3, #0
    1456:	9304      	str	r3, [sp, #16]
    1458:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
    145c:	9303      	str	r3, [sp, #12]
    145e:	f107 031c 	add.w	r3, r7, #28
    1462:	9302      	str	r3, [sp, #8]
    1464:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
    1466:	9301      	str	r3, [sp, #4]
    1468:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    146a:	9300      	str	r3, [sp, #0]
    146c:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
    1470:	6839      	ldr	r1, [r7, #0]
    1472:	6878      	ldr	r0, [r7, #4]
    1474:	f7ff f9d6 	bl	824 <gen_out>
    1478:	62f8      	str	r0, [r7, #44]	@ 0x2c
    if ( n == EXBADFORMAT )
    147a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    147c:	f1b3 3fff 	cmp.w	r3, #4294967295
    1480:	d101      	bne.n	1486 <MAIN_STACK_SIZE+0x486>
        return n;
    1482:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    1484:	e0f4      	b.n	1670 <MAIN_STACK_SIZE+0x670>
    count += n;
    1486:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
    1488:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    148a:	4413      	add	r3, r2
    148c:	66fb      	str	r3, [r7, #108]	@ 0x6c

    /* Add any zeros before DP */
    n = gen_out( cons, parg, 0, NULL, 0, pz2, NULL, 0, 0 );
    148e:	2300      	movs	r3, #0
    1490:	9304      	str	r3, [sp, #16]
    1492:	2300      	movs	r3, #0
    1494:	9303      	str	r3, [sp, #12]
    1496:	2300      	movs	r3, #0
    1498:	9302      	str	r3, [sp, #8]
    149a:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
    149c:	9301      	str	r3, [sp, #4]
    149e:	2300      	movs	r3, #0
    14a0:	9300      	str	r3, [sp, #0]
    14a2:	2300      	movs	r3, #0
    14a4:	2200      	movs	r2, #0
    14a6:	6839      	ldr	r1, [r7, #0]
    14a8:	6878      	ldr	r0, [r7, #4]
    14aa:	f7ff f9bb 	bl	824 <gen_out>
    14ae:	62f8      	str	r0, [r7, #44]	@ 0x2c
    if ( n == EXBADFORMAT )
    14b0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    14b2:	f1b3 3fff 	cmp.w	r3, #4294967295
    14b6:	d101      	bne.n	14bc <MAIN_STACK_SIZE+0x4bc>
        return n;
    14b8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    14ba:	e0d9      	b.n	1670 <MAIN_STACK_SIZE+0x670>
    count += n;
    14bc:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
    14be:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    14c0:	4413      	add	r3, r2
    14c2:	66fb      	str	r3, [r7, #108]	@ 0x6c

    /* RIGHT */
    e_n = n_right ? mant_to_char( e_s, mantissa, sigfig, n_right )
                  : 0;
    14c4:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    14c6:	2b00      	cmp	r3, #0
    14c8:	d00c      	beq.n	14e4 <MAIN_STACK_SIZE+0x4e4>
    e_n = n_right ? mant_to_char( e_s, mantissa, sigfig, n_right )
    14ca:	e9d7 2328 	ldrd	r2, r3, [r7, #160]	@ 0xa0
    14ce:	f107 001c 	add.w	r0, r7, #28
    14d2:	6e39      	ldr	r1, [r7, #96]	@ 0x60
    14d4:	9101      	str	r1, [sp, #4]
    14d6:	f8d7 108c 	ldr.w	r1, [r7, #140]	@ 0x8c
    14da:	9100      	str	r1, [sp, #0]
    14dc:	f7ff fbcc 	bl	c78 <mant_to_char>
    14e0:	4603      	mov	r3, r0
    14e2:	e000      	b.n	14e6 <MAIN_STACK_SIZE+0x4e6>
                  : 0;
    14e4:	2300      	movs	r3, #0
    e_n = n_right ? mant_to_char( e_s, mantissa, sigfig, n_right )
    14e6:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84

    n = gen_out( cons, parg, 0, ".", want_dp ? 1 : 0, pz3, e_s, e_n, 0 );
    14ea:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
    14ec:	2b00      	cmp	r3, #0
    14ee:	bf14      	ite	ne
    14f0:	2301      	movne	r3, #1
    14f2:	2300      	moveq	r3, #0
    14f4:	b2db      	uxtb	r3, r3
    14f6:	461a      	mov	r2, r3
    14f8:	2300      	movs	r3, #0
    14fa:	9304      	str	r3, [sp, #16]
    14fc:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
    1500:	9303      	str	r3, [sp, #12]
    1502:	f107 031c 	add.w	r3, r7, #28
    1506:	9302      	str	r3, [sp, #8]
    1508:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
    150a:	9301      	str	r3, [sp, #4]
    150c:	9200      	str	r2, [sp, #0]
    150e:	4b23      	ldr	r3, [pc, #140]	@ (159c <MAIN_STACK_SIZE+0x59c>)
    1510:	2200      	movs	r2, #0
    1512:	6839      	ldr	r1, [r7, #0]
    1514:	6878      	ldr	r0, [r7, #4]
    1516:	f7ff f985 	bl	824 <gen_out>
    151a:	62f8      	str	r0, [r7, #44]	@ 0x2c
    if ( n == EXBADFORMAT )
    151c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    151e:	f1b3 3fff 	cmp.w	r3, #4294967295
    1522:	d101      	bne.n	1528 <MAIN_STACK_SIZE+0x528>
        return n;
    1524:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    1526:	e0a3      	b.n	1670 <MAIN_STACK_SIZE+0x670>
    count += n;
    1528:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
    152a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    152c:	4413      	add	r3, r2
    152e:	66fb      	str	r3, [r7, #108]	@ 0x6c

    /* Trailing zeros, if any */
    n = gen_out( cons, parg, 0, NULL, 0, pz4, NULL, 0, 0 );
    1530:	2300      	movs	r3, #0
    1532:	9304      	str	r3, [sp, #16]
    1534:	2300      	movs	r3, #0
    1536:	9303      	str	r3, [sp, #12]
    1538:	2300      	movs	r3, #0
    153a:	9302      	str	r3, [sp, #8]
    153c:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
    153e:	9301      	str	r3, [sp, #4]
    1540:	2300      	movs	r3, #0
    1542:	9300      	str	r3, [sp, #0]
    1544:	2300      	movs	r3, #0
    1546:	2200      	movs	r2, #0
    1548:	6839      	ldr	r1, [r7, #0]
    154a:	6878      	ldr	r0, [r7, #4]
    154c:	f7ff f96a 	bl	824 <gen_out>
    1550:	62f8      	str	r0, [r7, #44]	@ 0x2c
    if ( n == EXBADFORMAT )
    1552:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    1554:	f1b3 3fff 	cmp.w	r3, #4294967295
    1558:	d101      	bne.n	155e <MAIN_STACK_SIZE+0x55e>
        return n;
    155a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    155c:	e088      	b.n	1670 <MAIN_STACK_SIZE+0x670>
    count += n;
    155e:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
    1560:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    1562:	4413      	add	r3, r2
    1564:	66fb      	str	r3, [r7, #108]	@ 0x6c

    /* EXPONENT */
    if ( n_exp )
    1566:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
    1568:	2b00      	cmp	r3, #0
    156a:	d05d      	beq.n	1628 <MAIN_STACK_SIZE+0x628>
    {
        unsigned int absexp = ABS(exponent);
    156c:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
    1570:	2b00      	cmp	r3, #0
    1572:	bfb8      	it	lt
    1574:	425b      	neglt	r3, r3
    1576:	63bb      	str	r3, [r7, #56]	@ 0x38
        char epfx_s[2];

        /* Exponent prefix comprises the letter 'e' or 'E' and a +/- sign */
        epfx_s[0] = code;
    1578:	7afb      	ldrb	r3, [r7, #11]
    157a:	743b      	strb	r3, [r7, #16]
        epfx_s[1] = ( exponent < 0 ) ? '-' : '+';
    157c:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
    1580:	2b00      	cmp	r3, #0
    1582:	da01      	bge.n	1588 <MAIN_STACK_SIZE+0x588>
    1584:	232d      	movs	r3, #45	@ 0x2d
    1586:	e000      	b.n	158a <MAIN_STACK_SIZE+0x58a>
    1588:	232b      	movs	r3, #43	@ 0x2b
    158a:	747b      	strb	r3, [r7, #17]

        for ( i = n_exp, e_n = 0; i > 0; i--, e_n++, absexp /= 10 )
    158c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
    158e:	65fb      	str	r3, [r7, #92]	@ 0x5c
    1590:	2300      	movs	r3, #0
    1592:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
    1596:	e025      	b.n	15e4 <MAIN_STACK_SIZE+0x5e4>
    1598:	66666667 	.word	0x66666667
    159c:	0000966c 	.word	0x0000966c
            e_s[i-1] = ( absexp % 10 ) + '0';
    15a0:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
    15a2:	4b35      	ldr	r3, [pc, #212]	@ (1678 <MAIN_STACK_SIZE+0x678>)
    15a4:	fba3 2301 	umull	r2, r3, r3, r1
    15a8:	08da      	lsrs	r2, r3, #3
    15aa:	4613      	mov	r3, r2
    15ac:	009b      	lsls	r3, r3, #2
    15ae:	4413      	add	r3, r2
    15b0:	005b      	lsls	r3, r3, #1
    15b2:	1aca      	subs	r2, r1, r3
    15b4:	b2d3      	uxtb	r3, r2
    15b6:	3330      	adds	r3, #48	@ 0x30
    15b8:	b2da      	uxtb	r2, r3
    15ba:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
    15bc:	3b01      	subs	r3, #1
    15be:	b252      	sxtb	r2, r2
    15c0:	3390      	adds	r3, #144	@ 0x90
    15c2:	443b      	add	r3, r7
    15c4:	f803 2c74 	strb.w	r2, [r3, #-116]
        for ( i = n_exp, e_n = 0; i > 0; i--, e_n++, absexp /= 10 )
    15c8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
    15ca:	3b01      	subs	r3, #1
    15cc:	65fb      	str	r3, [r7, #92]	@ 0x5c
    15ce:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
    15d2:	3301      	adds	r3, #1
    15d4:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
    15d8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
    15da:	4a27      	ldr	r2, [pc, #156]	@ (1678 <MAIN_STACK_SIZE+0x678>)
    15dc:	fba2 2303 	umull	r2, r3, r2, r3
    15e0:	08db      	lsrs	r3, r3, #3
    15e2:	63bb      	str	r3, [r7, #56]	@ 0x38
    15e4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
    15e6:	2b00      	cmp	r3, #0
    15e8:	dcda      	bgt.n	15a0 <MAIN_STACK_SIZE+0x5a0>

        n = gen_out( cons, parg, 0, epfx_s, sizeof(epfx_s), 0, e_s, e_n, 0 );
    15ea:	f107 0210 	add.w	r2, r7, #16
    15ee:	2300      	movs	r3, #0
    15f0:	9304      	str	r3, [sp, #16]
    15f2:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
    15f6:	9303      	str	r3, [sp, #12]
    15f8:	f107 031c 	add.w	r3, r7, #28
    15fc:	9302      	str	r3, [sp, #8]
    15fe:	2300      	movs	r3, #0
    1600:	9301      	str	r3, [sp, #4]
    1602:	2302      	movs	r3, #2
    1604:	9300      	str	r3, [sp, #0]
    1606:	4613      	mov	r3, r2
    1608:	2200      	movs	r2, #0
    160a:	6839      	ldr	r1, [r7, #0]
    160c:	6878      	ldr	r0, [r7, #4]
    160e:	f7ff f909 	bl	824 <gen_out>
    1612:	62f8      	str	r0, [r7, #44]	@ 0x2c
        if ( n == EXBADFORMAT )
    1614:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    1616:	f1b3 3fff 	cmp.w	r3, #4294967295
    161a:	d101      	bne.n	1620 <MAIN_STACK_SIZE+0x620>
            return n;
    161c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    161e:	e027      	b.n	1670 <MAIN_STACK_SIZE+0x670>
        count += n;
    1620:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
    1622:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    1624:	4413      	add	r3, r2
    1626:	66fb      	str	r3, [r7, #108]	@ 0x6c
    }

    /* SI multiplier and trailing space */
    n = gen_out( cons, parg, 0, NULL, 0, 0, &si, si ? 1 : 0, ps2 );
    1628:	f997 3013 	ldrsb.w	r3, [r7, #19]
    162c:	2b00      	cmp	r3, #0
    162e:	bf14      	ite	ne
    1630:	2301      	movne	r3, #1
    1632:	2300      	moveq	r3, #0
    1634:	b2db      	uxtb	r3, r3
    1636:	461a      	mov	r2, r3
    1638:	697b      	ldr	r3, [r7, #20]
    163a:	9304      	str	r3, [sp, #16]
    163c:	9203      	str	r2, [sp, #12]
    163e:	f107 0313 	add.w	r3, r7, #19
    1642:	9302      	str	r3, [sp, #8]
    1644:	2300      	movs	r3, #0
    1646:	9301      	str	r3, [sp, #4]
    1648:	2300      	movs	r3, #0
    164a:	9300      	str	r3, [sp, #0]
    164c:	2300      	movs	r3, #0
    164e:	2200      	movs	r2, #0
    1650:	6839      	ldr	r1, [r7, #0]
    1652:	6878      	ldr	r0, [r7, #4]
    1654:	f7ff f8e6 	bl	824 <gen_out>
    1658:	62f8      	str	r0, [r7, #44]	@ 0x2c
    if ( n == EXBADFORMAT )
    165a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    165c:	f1b3 3fff 	cmp.w	r3, #4294967295
    1660:	d101      	bne.n	1666 <MAIN_STACK_SIZE+0x666>
        return n;
    1662:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    1664:	e004      	b.n	1670 <MAIN_STACK_SIZE+0x670>
    count += n;
    1666:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
    1668:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    166a:	4413      	add	r3, r2
    166c:	66fb      	str	r3, [r7, #108]	@ 0x6c

    return count;
    166e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
}
    1670:	4618      	mov	r0, r3
    1672:	3790      	adds	r7, #144	@ 0x90
    1674:	46bd      	mov	sp, r7
    1676:	bd80      	pop	{r7, pc}
    1678:	cccccccd 	.word	0xcccccccd

0000167c <do_conv_fp>:
static int do_conv_fp( T_FormatSpec * pspec,
                       va_list *      ap,
                       char           code,
                       void *      (* cons)(void *, const char *, size_t),
                       void * *       parg )
{
    167c:	b590      	push	{r4, r7, lr}
    167e:	b093      	sub	sp, #76	@ 0x4c
    1680:	af06      	add	r7, sp, #24
    1682:	60f8      	str	r0, [r7, #12]
    1684:	60b9      	str	r1, [r7, #8]
    1686:	603b      	str	r3, [r7, #0]
    1688:	4613      	mov	r3, r2
    168a:	71fb      	strb	r3, [r7, #7]
    unsigned int sign;
    DEC_MANT_REG_TYPE mantissa;
    int exponent;

    /* Do not support long doubles */
    if ( pspec->qual == 'L' )
    168c:	68fb      	ldr	r3, [r7, #12]
    168e:	f993 3014 	ldrsb.w	r3, [r3, #20]
    1692:	2b4c      	cmp	r3, #76	@ 0x4c
    1694:	d102      	bne.n	169c <do_conv_fp+0x20>
        return EXBADFORMAT;
    1696:	f04f 33ff 	mov.w	r3, #4294967295
    169a:	e04d      	b.n	1738 <do_conv_fp+0xbc>

    dv = va_arg( *ap, double );
    169c:	68bb      	ldr	r3, [r7, #8]
    169e:	681b      	ldr	r3, [r3, #0]
    16a0:	3307      	adds	r3, #7
    16a2:	f023 0307 	bic.w	r3, r3, #7
    16a6:	f103 0108 	add.w	r1, r3, #8
    16aa:	68ba      	ldr	r2, [r7, #8]
    16ac:	6011      	str	r1, [r2, #0]
    16ae:	e9d3 2300 	ldrd	r2, r3, [r3]
    16b2:	e9c7 230a 	strd	r2, r3, [r7, #40]	@ 0x28
    radix_convert( dv, &sign, &mantissa, &exponent );
    16b6:	f107 0118 	add.w	r1, r7, #24
    16ba:	f107 0224 	add.w	r2, r7, #36	@ 0x24
    16be:	f107 0314 	add.w	r3, r7, #20
    16c2:	9300      	str	r3, [sp, #0]
    16c4:	460b      	mov	r3, r1
    16c6:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	@ 0x28
    16ca:	f7ff f971 	bl	9b0 <radix_convert>

    /* Infs and NaNs are treated in the same style */
    if ( DEC_FP_IS_NAN( sign, mantissa, exponent )
    16ce:	697b      	ldr	r3, [r7, #20]
    16d0:	f06f 4200 	mvn.w	r2, #2147483648	@ 0x80000000
    16d4:	4293      	cmp	r3, r2
    16d6:	d103      	bne.n	16e0 <do_conv_fp+0x64>
    16d8:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
    16dc:	4313      	orrs	r3, r2
    16de:	d108      	bne.n	16f2 <do_conv_fp+0x76>
      || DEC_FP_IS_INF( sign, mantissa, exponent ) )
    16e0:	697b      	ldr	r3, [r7, #20]
    16e2:	f06f 4200 	mvn.w	r2, #2147483648	@ 0x80000000
    16e6:	4293      	cmp	r3, r2
    16e8:	d115      	bne.n	1716 <do_conv_fp+0x9a>
    16ea:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
    16ee:	4313      	orrs	r3, r2
    16f0:	d111      	bne.n	1716 <do_conv_fp+0x9a>
    {
        return do_conv_infnan( pspec, code, cons, parg, sign, mantissa, exponent );
    16f2:	6a79      	ldr	r1, [r7, #36]	@ 0x24
    16f4:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
    16f8:	6978      	ldr	r0, [r7, #20]
    16fa:	f997 4007 	ldrsb.w	r4, [r7, #7]
    16fe:	9004      	str	r0, [sp, #16]
    1700:	e9cd 2302 	strd	r2, r3, [sp, #8]
    1704:	9100      	str	r1, [sp, #0]
    1706:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
    1708:	683a      	ldr	r2, [r7, #0]
    170a:	4621      	mov	r1, r4
    170c:	68f8      	ldr	r0, [r7, #12]
    170e:	f7ff faff 	bl	d10 <do_conv_infnan>
    1712:	4603      	mov	r3, r0
    1714:	e010      	b.n	1738 <do_conv_fp+0xbc>
    }
    else
    {
        return do_conv_efg( pspec, code, cons, parg, sign, mantissa, exponent );
    1716:	6a79      	ldr	r1, [r7, #36]	@ 0x24
    1718:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
    171c:	6978      	ldr	r0, [r7, #20]
    171e:	f997 4007 	ldrsb.w	r4, [r7, #7]
    1722:	9004      	str	r0, [sp, #16]
    1724:	e9cd 2302 	strd	r2, r3, [sp, #8]
    1728:	9100      	str	r1, [sp, #0]
    172a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
    172c:	683a      	ldr	r2, [r7, #0]
    172e:	4621      	mov	r1, r4
    1730:	68f8      	ldr	r0, [r7, #12]
    1732:	f7ff fc1b 	bl	f6c <do_conv_efg>
    1736:	4603      	mov	r3, r0
    }    
}
    1738:	4618      	mov	r0, r3
    173a:	3734      	adds	r7, #52	@ 0x34
    173c:	46bd      	mov	sp, r7
    173e:	bd90      	pop	{r4, r7, pc}

00001740 <do_conv_k>:
static int do_conv_k( T_FormatSpec * pspec,
                      va_list *      ap,
                      char           code,
                      void *      (* cons)(void *, const char *, size_t),
                      void * *       parg )
{
    1740:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
    1744:	b0aa      	sub	sp, #168	@ 0xa8
    1746:	af06      	add	r7, sp, #24
    1748:	65f8      	str	r0, [r7, #92]	@ 0x5c
    174a:	65b9      	str	r1, [r7, #88]	@ 0x58
    174c:	653b      	str	r3, [r7, #80]	@ 0x50
    174e:	4613      	mov	r3, r2
    1750:	f887 3057 	strb.w	r3, [r7, #87]	@ 0x57
    size_t total_bits = pspec->xp.w_int + pspec->xp.w_frac;
    1754:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
    1756:	6a1a      	ldr	r2, [r3, #32]
    1758:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
    175a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
    175c:	4413      	add	r3, r2
    175e:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
    size_t total_bytes = ( total_bits + 7 ) / 8;
    1762:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
    1766:	3307      	adds	r3, #7
    1768:	08db      	lsrs	r3, r3, #3
    176a:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
    union {
        double d;
        DEC_MANT_REG_TYPE b;
    } u;
	
	u.d = 0.0;
    176e:	f04f 0200 	mov.w	r2, #0
    1772:	f04f 0300 	mov.w	r3, #0
    1776:	e9c7 2318 	strd	r2, r3, [r7, #96]	@ 0x60
	u.b = 0;
    177a:	f04f 0200 	mov.w	r2, #0
    177e:	f04f 0300 	mov.w	r3, #0
    1782:	e9c7 2318 	strd	r2, r3, [r7, #96]	@ 0x60

    if ( total_bytes == 0 )
    1786:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
    178a:	2b00      	cmp	r3, #0
    178c:	d102      	bne.n	1794 <do_conv_k+0x54>
        return EXBADFORMAT;
    178e:	f04f 33ff 	mov.w	r3, #4294967295
    1792:	e0ee      	b.n	1972 <do_conv_k+0x232>
    
    if ( total_bytes <= sizeof( int ) )
    1794:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
    1798:	2b04      	cmp	r3, #4
    179a:	d808      	bhi.n	17ae <do_conv_k+0x6e>
        v = (long)va_arg( *ap, int );
    179c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
    179e:	6819      	ldr	r1, [r3, #0]
    17a0:	1d0a      	adds	r2, r1, #4
    17a2:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
    17a4:	601a      	str	r2, [r3, #0]
    17a6:	680b      	ldr	r3, [r1, #0]
    17a8:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
    17ac:	e007      	b.n	17be <do_conv_k+0x7e>
    else
        v = (long)va_arg( *ap, long );
    17ae:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
    17b0:	6819      	ldr	r1, [r3, #0]
    17b2:	1d0a      	adds	r2, r1, #4
    17b4:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
    17b6:	601a      	str	r2, [r3, #0]
    17b8:	680b      	ldr	r3, [r1, #0]
    17ba:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c

    DEBUG_LOG( "k: val = 0x%8.8lX ", v );
    DEBUG_LOG( "w_int = %zd ", pspec->xp.w_int );
    DEBUG_LOG( "w_frac = %zd ", pspec->xp.w_frac );

    if ( v == 0 ) /* handle zero as special case */
    17be:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
    17c2:	2b00      	cmp	r3, #0
    17c4:	d10a      	bne.n	17dc <do_conv_k+0x9c>
    {
        sign     = 0;
    17c6:	2300      	movs	r3, #0
    17c8:	67fb      	str	r3, [r7, #124]	@ 0x7c
        mantissa = 0;
    17ca:	f04f 0200 	mov.w	r2, #0
    17ce:	f04f 0300 	mov.w	r3, #0
    17d2:	e9c7 231c 	strd	r2, r3, [r7, #112]	@ 0x70
        exponent = 0;
    17d6:	2300      	movs	r3, #0
    17d8:	66fb      	str	r3, [r7, #108]	@ 0x6c
    17da:	e0ba      	b.n	1952 <do_conv_k+0x212>
    else
    {
        int i;

        /* Extract sign bit */
        sign = !!( v & ( 1 << ( total_bits - 1) ) );
    17dc:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
    17e0:	1e5a      	subs	r2, r3, #1
    17e2:	2301      	movs	r3, #1
    17e4:	fa03 f202 	lsl.w	r2, r3, r2
    17e8:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
    17ec:	4013      	ands	r3, r2
    17ee:	2b00      	cmp	r3, #0
    17f0:	bf14      	ite	ne
    17f2:	2301      	movne	r3, #1
    17f4:	2300      	moveq	r3, #0
    17f6:	b2db      	uxtb	r3, r3
    17f8:	67fb      	str	r3, [r7, #124]	@ 0x7c

        /* If the sign bit is set (number is negative) then apply 2's complement
         * sign inversion.  We can use the built-in type sign inversion as long
         * as we then mask out any bits not in the fixed-point type.
         */
        if ( sign )
    17fa:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
    17fc:	2b00      	cmp	r3, #0
    17fe:	d004      	beq.n	180a <do_conv_k+0xca>
            v = -v;
    1800:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
    1804:	425b      	negs	r3, r3
    1806:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c

        /* Mask out any dross from the input value and save for later */
        v &= ( 1 << ( total_bits - 1) ) - 1;
    180a:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
    180e:	1e5a      	subs	r2, r3, #1
    1810:	2301      	movs	r3, #1
    1812:	4093      	lsls	r3, r2
    1814:	1e5a      	subs	r2, r3, #1
    1816:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
    181a:	4013      	ands	r3, r2
    181c:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
        mantissa = (DEC_MANT_REG_TYPE)v;
    1820:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
    1824:	17da      	asrs	r2, r3, #31
    1826:	64bb      	str	r3, [r7, #72]	@ 0x48
    1828:	64fa      	str	r2, [r7, #76]	@ 0x4c
    182a:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	@ 0x48
    182e:	e9c7 231c 	strd	r2, r3, [r7, #112]	@ 0x70

        /* Work out where highest bit is */
        for ( i = -1; v; i++ )
    1832:	f04f 33ff 	mov.w	r3, #4294967295
    1836:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
    183a:	e009      	b.n	1850 <do_conv_k+0x110>
            v >>= 1;
    183c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
    1840:	105b      	asrs	r3, r3, #1
    1842:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
        for ( i = -1; v; i++ )
    1846:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
    184a:	3301      	adds	r3, #1
    184c:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
    1850:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
    1854:	2b00      	cmp	r3, #0
    1856:	d1f1      	bne.n	183c <do_conv_k+0xfc>

        /* i gives index of highest '1' bit, which then gives us the exponent */
        DEBUG_LOG( "i = %d ", i );
        exponent = i - pspec->xp.w_frac;
    1858:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
    185c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
    185e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
    1860:	1ad3      	subs	r3, r2, r3
    1862:	66fb      	str	r3, [r7, #108]	@ 0x6c
        
        /* Shift up the mantissa until the top-most bit pops out of the top
         * of the mantissa, which will then get masked out, which is exactly
         * what we want - in floating point the '1' is implied.
         */
        while ( (mantissa & ~BIN_MANT_MASK) == 0 )
    1864:	e009      	b.n	187a <do_conv_k+0x13a>
            mantissa <<= 1;
    1866:	e9d7 231c 	ldrd	r2, r3, [r7, #112]	@ 0x70
    186a:	1891      	adds	r1, r2, r2
    186c:	6039      	str	r1, [r7, #0]
    186e:	415b      	adcs	r3, r3
    1870:	607b      	str	r3, [r7, #4]
    1872:	e9d7 2300 	ldrd	r2, r3, [r7]
    1876:	e9c7 231c 	strd	r2, r3, [r7, #112]	@ 0x70
        while ( (mantissa & ~BIN_MANT_MASK) == 0 )
    187a:	e9d7 231c 	ldrd	r2, r3, [r7, #112]	@ 0x70
    187e:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
    1882:	d3f0      	bcc.n	1866 <do_conv_k+0x126>

        DEBUG_LOG("mantissa: %llu\n", mantissa);

        /* Now pack everthing into the binary FP */
        BIN_PACK_MANT( u.b, mantissa );
    1884:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
    1888:	2400      	movs	r4, #0
    188a:	ea4f 5513 	mov.w	r5, r3, lsr #20
    188e:	ea4f 5505 	mov.w	r5, r5, lsl #20
    1892:	e9d7 231c 	ldrd	r2, r3, [r7, #112]	@ 0x70
    1896:	4692      	mov	sl, r2
    1898:	f3c3 0b13 	ubfx	fp, r3, #0, #20
    189c:	ea44 030a 	orr.w	r3, r4, sl
    18a0:	643b      	str	r3, [r7, #64]	@ 0x40
    18a2:	ea45 030b 	orr.w	r3, r5, fp
    18a6:	647b      	str	r3, [r7, #68]	@ 0x44
    18a8:	e9d7 3410 	ldrd	r3, r4, [r7, #64]	@ 0x40
    18ac:	e9c7 3418 	strd	r3, r4, [r7, #96]	@ 0x60
        BIN_PACK_EXPO( u.b, exponent );
    18b0:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
    18b4:	63ba      	str	r2, [r7, #56]	@ 0x38
    18b6:	f36f 531e 	bfc	r3, #20, #11
    18ba:	63fb      	str	r3, [r7, #60]	@ 0x3c
    18bc:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
    18be:	17da      	asrs	r2, r3, #31
    18c0:	633b      	str	r3, [r7, #48]	@ 0x30
    18c2:	637a      	str	r2, [r7, #52]	@ 0x34
    18c4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    18c6:	f3c3 080a 	ubfx	r8, r3, #0, #11
    18ca:	f04f 0900 	mov.w	r9, #0
    18ce:	f240 33ff 	movw	r3, #1023	@ 0x3ff
    18d2:	eb18 0303 	adds.w	r3, r8, r3
    18d6:	62bb      	str	r3, [r7, #40]	@ 0x28
    18d8:	f149 0300 	adc.w	r3, r9, #0
    18dc:	62fb      	str	r3, [r7, #44]	@ 0x2c
    18de:	f04f 0200 	mov.w	r2, #0
    18e2:	f04f 0300 	mov.w	r3, #0
    18e6:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
    18e8:	050b      	lsls	r3, r1, #20
    18ea:	2200      	movs	r2, #0
    18ec:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	@ 0x38
    18f0:	4604      	mov	r4, r0
    18f2:	4314      	orrs	r4, r2
    18f4:	623c      	str	r4, [r7, #32]
    18f6:	4319      	orrs	r1, r3
    18f8:	6279      	str	r1, [r7, #36]	@ 0x24
    18fa:	e9d7 3408 	ldrd	r3, r4, [r7, #32]
    18fe:	e9c7 3418 	strd	r3, r4, [r7, #96]	@ 0x60
        BIN_PACK_SIGN( u.b, sign     );
    1902:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
    1906:	61ba      	str	r2, [r7, #24]
    1908:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
    190c:	61fb      	str	r3, [r7, #28]
    190e:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
    1910:	2200      	movs	r2, #0
    1912:	613b      	str	r3, [r7, #16]
    1914:	617a      	str	r2, [r7, #20]
    1916:	f04f 0200 	mov.w	r2, #0
    191a:	f04f 0300 	mov.w	r3, #0
    191e:	6939      	ldr	r1, [r7, #16]
    1920:	07cb      	lsls	r3, r1, #31
    1922:	2200      	movs	r2, #0
    1924:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
    1928:	4604      	mov	r4, r0
    192a:	4314      	orrs	r4, r2
    192c:	60bc      	str	r4, [r7, #8]
    192e:	4319      	orrs	r1, r3
    1930:	60f9      	str	r1, [r7, #12]
    1932:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
    1936:	e9c7 3418 	strd	r3, r4, [r7, #96]	@ 0x60

        /* Convert to decimal components */
        radix_convert( u.d, &sign, &mantissa, &exponent );
    193a:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	@ 0x60
    193e:	f107 0470 	add.w	r4, r7, #112	@ 0x70
    1942:	f107 027c 	add.w	r2, r7, #124	@ 0x7c
    1946:	f107 036c 	add.w	r3, r7, #108	@ 0x6c
    194a:	9300      	str	r3, [sp, #0]
    194c:	4623      	mov	r3, r4
    194e:	f7ff f82f 	bl	9b0 <radix_convert>
    }
    
    return do_conv_efg( pspec, 'f', cons, parg, sign, mantissa, exponent );
    1952:	6ff9      	ldr	r1, [r7, #124]	@ 0x7c
    1954:	e9d7 231c 	ldrd	r2, r3, [r7, #112]	@ 0x70
    1958:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
    195a:	9004      	str	r0, [sp, #16]
    195c:	e9cd 2302 	strd	r2, r3, [sp, #8]
    1960:	9100      	str	r1, [sp, #0]
    1962:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
    1966:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
    1968:	2166      	movs	r1, #102	@ 0x66
    196a:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
    196c:	f7ff fafe 	bl	f6c <do_conv_efg>
    1970:	4603      	mov	r3, r0
}
    1972:	4618      	mov	r0, r3
    1974:	3790      	adds	r7, #144	@ 0x90
    1976:	46bd      	mov	sp, r7
    1978:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

0000197c <do_conv_n>:

    @return 0 as no characters are emitted.
**/
static int do_conv_n( T_FormatSpec * pspec,
                      va_list *      ap )
{
    197c:	b4b0      	push	{r4, r5, r7}
    197e:	b085      	sub	sp, #20
    1980:	af00      	add	r7, sp, #0
    1982:	6078      	str	r0, [r7, #4]
    1984:	6039      	str	r1, [r7, #0]
    void *vp = va_arg( *ap, void * );
    1986:	683b      	ldr	r3, [r7, #0]
    1988:	681b      	ldr	r3, [r3, #0]
    198a:	1d19      	adds	r1, r3, #4
    198c:	683a      	ldr	r2, [r7, #0]
    198e:	6011      	str	r1, [r2, #0]
    1990:	681b      	ldr	r3, [r3, #0]
    1992:	60fb      	str	r3, [r7, #12]

    if ( vp )
    1994:	68fb      	ldr	r3, [r7, #12]
    1996:	2b00      	cmp	r3, #0
    1998:	d048      	beq.n	1a2c <do_conv_n+0xb0>
    {
        if ( pspec->qual == 'h' )
    199a:	687b      	ldr	r3, [r7, #4]
    199c:	f993 3014 	ldrsb.w	r3, [r3, #20]
    19a0:	2b68      	cmp	r3, #104	@ 0x68
    19a2:	d105      	bne.n	19b0 <do_conv_n+0x34>
            *(short *)vp = (short)pspec->nChars;
    19a4:	687b      	ldr	r3, [r7, #4]
    19a6:	681b      	ldr	r3, [r3, #0]
    19a8:	b21a      	sxth	r2, r3
    19aa:	68fb      	ldr	r3, [r7, #12]
    19ac:	801a      	strh	r2, [r3, #0]
    19ae:	e03d      	b.n	1a2c <do_conv_n+0xb0>
        else if ( pspec->qual == DOUBLE_QUAL( 'h' ) )
    19b0:	687b      	ldr	r3, [r7, #4]
    19b2:	f993 3014 	ldrsb.w	r3, [r3, #20]
    19b6:	2b69      	cmp	r3, #105	@ 0x69
    19b8:	d105      	bne.n	19c6 <do_conv_n+0x4a>
            *(signed char *)vp = (signed char)pspec->nChars;
    19ba:	687b      	ldr	r3, [r7, #4]
    19bc:	681b      	ldr	r3, [r3, #0]
    19be:	b25a      	sxtb	r2, r3
    19c0:	68fb      	ldr	r3, [r7, #12]
    19c2:	701a      	strb	r2, [r3, #0]
    19c4:	e032      	b.n	1a2c <do_conv_n+0xb0>
        else if ( pspec->qual == 'l' )
    19c6:	687b      	ldr	r3, [r7, #4]
    19c8:	f993 3014 	ldrsb.w	r3, [r3, #20]
    19cc:	2b6c      	cmp	r3, #108	@ 0x6c
    19ce:	d105      	bne.n	19dc <do_conv_n+0x60>
            *(long *)vp = (long)pspec->nChars;
    19d0:	687b      	ldr	r3, [r7, #4]
    19d2:	681b      	ldr	r3, [r3, #0]
    19d4:	461a      	mov	r2, r3
    19d6:	68fb      	ldr	r3, [r7, #12]
    19d8:	601a      	str	r2, [r3, #0]
    19da:	e027      	b.n	1a2c <do_conv_n+0xb0>
        else if ( pspec->qual == 'j' )
    19dc:	687b      	ldr	r3, [r7, #4]
    19de:	f993 3014 	ldrsb.w	r3, [r3, #20]
    19e2:	2b6a      	cmp	r3, #106	@ 0x6a
    19e4:	d108      	bne.n	19f8 <do_conv_n+0x7c>
            *(intmax_t *)vp = (intmax_t)pspec->nChars;
    19e6:	687b      	ldr	r3, [r7, #4]
    19e8:	681b      	ldr	r3, [r3, #0]
    19ea:	2200      	movs	r2, #0
    19ec:	461c      	mov	r4, r3
    19ee:	4615      	mov	r5, r2
    19f0:	68fb      	ldr	r3, [r7, #12]
    19f2:	e9c3 4500 	strd	r4, r5, [r3]
    19f6:	e019      	b.n	1a2c <do_conv_n+0xb0>
        else if ( pspec->qual == 'z' )
    19f8:	687b      	ldr	r3, [r7, #4]
    19fa:	f993 3014 	ldrsb.w	r3, [r3, #20]
    19fe:	2b7a      	cmp	r3, #122	@ 0x7a
    1a00:	d104      	bne.n	1a0c <do_conv_n+0x90>
            *(size_t *)vp = (size_t)pspec->nChars;
    1a02:	687b      	ldr	r3, [r7, #4]
    1a04:	681a      	ldr	r2, [r3, #0]
    1a06:	68fb      	ldr	r3, [r7, #12]
    1a08:	601a      	str	r2, [r3, #0]
    1a0a:	e00f      	b.n	1a2c <do_conv_n+0xb0>
        else if ( pspec->qual == 't' )
    1a0c:	687b      	ldr	r3, [r7, #4]
    1a0e:	f993 3014 	ldrsb.w	r3, [r3, #20]
    1a12:	2b74      	cmp	r3, #116	@ 0x74
    1a14:	d105      	bne.n	1a22 <do_conv_n+0xa6>
            *(ptrdiff_t *)vp = (ptrdiff_t)pspec->nChars;
    1a16:	687b      	ldr	r3, [r7, #4]
    1a18:	681b      	ldr	r3, [r3, #0]
    1a1a:	461a      	mov	r2, r3
    1a1c:	68fb      	ldr	r3, [r7, #12]
    1a1e:	601a      	str	r2, [r3, #0]
    1a20:	e004      	b.n	1a2c <do_conv_n+0xb0>
        else
            *(int *)vp = (int)pspec->nChars;
    1a22:	687b      	ldr	r3, [r7, #4]
    1a24:	681b      	ldr	r3, [r3, #0]
    1a26:	461a      	mov	r2, r3
    1a28:	68fb      	ldr	r3, [r7, #12]
    1a2a:	601a      	str	r2, [r3, #0]
    }
    return 0;
    1a2c:	2300      	movs	r3, #0
}
    1a2e:	4618      	mov	r0, r3
    1a30:	3714      	adds	r7, #20
    1a32:	46bd      	mov	sp, r7
    1a34:	bcb0      	pop	{r4, r5, r7}
    1a36:	4770      	bx	lr

00001a38 <do_conv_c>:
static int do_conv_c( T_FormatSpec * pspec,
                      va_list *      ap,
                      char           code,
                      void *      (* cons)(void *, const char *, size_t),
                      void * *       parg )
{
    1a38:	b580      	push	{r7, lr}
    1a3a:	b08e      	sub	sp, #56	@ 0x38
    1a3c:	af06      	add	r7, sp, #24
    1a3e:	60f8      	str	r0, [r7, #12]
    1a40:	60b9      	str	r1, [r7, #8]
    1a42:	603b      	str	r3, [r7, #0]
    1a44:	4613      	mov	r3, r2
    1a46:	71fb      	strb	r3, [r7, #7]
    char cc;
    int n = 0;
    1a48:	2300      	movs	r3, #0
    1a4a:	61fb      	str	r3, [r7, #28]
    unsigned int rep;

    if ( code == 'c' )
    1a4c:	f997 3007 	ldrsb.w	r3, [r7, #7]
    1a50:	2b63      	cmp	r3, #99	@ 0x63
    1a52:	d108      	bne.n	1a66 <do_conv_c+0x2e>
        cc = (char)va_arg( *ap, int );
    1a54:	68bb      	ldr	r3, [r7, #8]
    1a56:	681b      	ldr	r3, [r3, #0]
    1a58:	1d19      	adds	r1, r3, #4
    1a5a:	68ba      	ldr	r2, [r7, #8]
    1a5c:	6011      	str	r1, [r2, #0]
    1a5e:	681b      	ldr	r3, [r3, #0]
    1a60:	b25b      	sxtb	r3, r3
    1a62:	74fb      	strb	r3, [r7, #19]
    1a64:	e003      	b.n	1a6e <do_conv_c+0x36>
    else
        cc = pspec->repchar;
    1a66:	68fb      	ldr	r3, [r7, #12]
    1a68:	f993 3015 	ldrsb.w	r3, [r3, #21]
    1a6c:	74fb      	strb	r3, [r7, #19]

    /* apply default precision */
    if ( pspec->prec < 0 )
    1a6e:	68fb      	ldr	r3, [r7, #12]
    1a70:	68db      	ldr	r3, [r3, #12]
    1a72:	2b00      	cmp	r3, #0
    1a74:	da02      	bge.n	1a7c <do_conv_c+0x44>
        pspec->prec = 1;
    1a76:	68fb      	ldr	r3, [r7, #12]
    1a78:	2201      	movs	r2, #1
    1a7a:	60da      	str	r2, [r3, #12]

    rep = MAX( 1, pspec->prec );
    1a7c:	68fb      	ldr	r3, [r7, #12]
    1a7e:	68db      	ldr	r3, [r3, #12]
    1a80:	2b01      	cmp	r3, #1
    1a82:	bfb8      	it	lt
    1a84:	2301      	movlt	r3, #1
    1a86:	61bb      	str	r3, [r7, #24]

    for ( ; rep; rep-- )
    1a88:	e01f      	b.n	1aca <do_conv_c+0x92>
    {
        int r = gen_out( cons, parg, 0, NULL, 0, 0, &cc, 1, 0 );
    1a8a:	2300      	movs	r3, #0
    1a8c:	9304      	str	r3, [sp, #16]
    1a8e:	2301      	movs	r3, #1
    1a90:	9303      	str	r3, [sp, #12]
    1a92:	f107 0313 	add.w	r3, r7, #19
    1a96:	9302      	str	r3, [sp, #8]
    1a98:	2300      	movs	r3, #0
    1a9a:	9301      	str	r3, [sp, #4]
    1a9c:	2300      	movs	r3, #0
    1a9e:	9300      	str	r3, [sp, #0]
    1aa0:	2300      	movs	r3, #0
    1aa2:	2200      	movs	r2, #0
    1aa4:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
    1aa6:	6838      	ldr	r0, [r7, #0]
    1aa8:	f7fe febc 	bl	824 <gen_out>
    1aac:	6178      	str	r0, [r7, #20]
        if ( r == EXBADFORMAT )
    1aae:	697b      	ldr	r3, [r7, #20]
    1ab0:	f1b3 3fff 	cmp.w	r3, #4294967295
    1ab4:	d102      	bne.n	1abc <do_conv_c+0x84>
            return EXBADFORMAT;
    1ab6:	f04f 33ff 	mov.w	r3, #4294967295
    1aba:	e00a      	b.n	1ad2 <do_conv_c+0x9a>
        n += r;
    1abc:	69fa      	ldr	r2, [r7, #28]
    1abe:	697b      	ldr	r3, [r7, #20]
    1ac0:	4413      	add	r3, r2
    1ac2:	61fb      	str	r3, [r7, #28]
    for ( ; rep; rep-- )
    1ac4:	69bb      	ldr	r3, [r7, #24]
    1ac6:	3b01      	subs	r3, #1
    1ac8:	61bb      	str	r3, [r7, #24]
    1aca:	69bb      	ldr	r3, [r7, #24]
    1acc:	2b00      	cmp	r3, #0
    1ace:	d1dc      	bne.n	1a8a <do_conv_c+0x52>
    }

    return n;
    1ad0:	69fb      	ldr	r3, [r7, #28]
}
    1ad2:	4618      	mov	r0, r3
    1ad4:	3720      	adds	r7, #32
    1ad6:	46bd      	mov	sp, r7
    1ad8:	bd80      	pop	{r7, pc}
	...

00001adc <do_conv_s>:
static int do_conv_s( T_FormatSpec * pspec,
                      va_list *      ap,
                      char           code,
                      void *      (* cons)(void *, const char *, size_t),
                      void * *       parg )
{
    1adc:	b580      	push	{r7, lr}
    1ade:	b08e      	sub	sp, #56	@ 0x38
    1ae0:	af06      	add	r7, sp, #24
    1ae2:	60f8      	str	r0, [r7, #12]
    1ae4:	60b9      	str	r1, [r7, #8]
    1ae6:	603b      	str	r3, [r7, #0]
    1ae8:	4613      	mov	r3, r2
    1aea:	71fb      	strb	r3, [r7, #7]
    size_t length = 0;
    1aec:	2300      	movs	r3, #0
    1aee:	61fb      	str	r3, [r7, #28]
    size_t ps1 = 0, ps2 = 0;
    1af0:	2300      	movs	r3, #0
    1af2:	617b      	str	r3, [r7, #20]
    1af4:	2300      	movs	r3, #0
    1af6:	613b      	str	r3, [r7, #16]

    const char *s = va_arg( *ap, const char * );
    1af8:	68bb      	ldr	r3, [r7, #8]
    1afa:	681b      	ldr	r3, [r3, #0]
    1afc:	1d19      	adds	r1, r3, #4
    1afe:	68ba      	ldr	r2, [r7, #8]
    1b00:	6011      	str	r1, [r2, #0]
    1b02:	681b      	ldr	r3, [r3, #0]
    1b04:	61bb      	str	r3, [r7, #24]

    if ( s == NULL )
    1b06:	69bb      	ldr	r3, [r7, #24]
    1b08:	2b00      	cmp	r3, #0
    1b0a:	d101      	bne.n	1b10 <do_conv_s+0x34>
        s = "(null)";
    1b0c:	4b17      	ldr	r3, [pc, #92]	@ (1b6c <do_conv_s+0x90>)
    1b0e:	61bb      	str	r3, [r7, #24]

    length = STRLEN( s );
    1b10:	69b8      	ldr	r0, [r7, #24]
    1b12:	f005 fcae 	bl	7472 <strlen>
    1b16:	61f8      	str	r0, [r7, #28]
    if ( pspec->prec >= 0 )
    1b18:	68fb      	ldr	r3, [r7, #12]
    1b1a:	68db      	ldr	r3, [r3, #12]
    1b1c:	2b00      	cmp	r3, #0
    1b1e:	db07      	blt.n	1b30 <do_conv_s+0x54>
        length = MIN( pspec->prec, length );
    1b20:	68fb      	ldr	r3, [r7, #12]
    1b22:	68db      	ldr	r3, [r3, #12]
    1b24:	461a      	mov	r2, r3
    1b26:	69fb      	ldr	r3, [r7, #28]
    1b28:	4293      	cmp	r3, r2
    1b2a:	bf28      	it	cs
    1b2c:	4613      	movcs	r3, r2
    1b2e:	61fb      	str	r3, [r7, #28]

    calc_space_padding( pspec, length, &ps1, &ps2 );
    1b30:	f107 0310 	add.w	r3, r7, #16
    1b34:	f107 0214 	add.w	r2, r7, #20
    1b38:	69f9      	ldr	r1, [r7, #28]
    1b3a:	68f8      	ldr	r0, [r7, #12]
    1b3c:	f7fe fee6 	bl	90c <calc_space_padding>

    return gen_out( cons, parg, ps1, NULL, 0, 0, s, length, ps2 );
    1b40:	697a      	ldr	r2, [r7, #20]
    1b42:	693b      	ldr	r3, [r7, #16]
    1b44:	9304      	str	r3, [sp, #16]
    1b46:	69fb      	ldr	r3, [r7, #28]
    1b48:	9303      	str	r3, [sp, #12]
    1b4a:	69bb      	ldr	r3, [r7, #24]
    1b4c:	9302      	str	r3, [sp, #8]
    1b4e:	2300      	movs	r3, #0
    1b50:	9301      	str	r3, [sp, #4]
    1b52:	2300      	movs	r3, #0
    1b54:	9300      	str	r3, [sp, #0]
    1b56:	2300      	movs	r3, #0
    1b58:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
    1b5a:	6838      	ldr	r0, [r7, #0]
    1b5c:	f7fe fe62 	bl	824 <gen_out>
    1b60:	4603      	mov	r3, r0
}
    1b62:	4618      	mov	r0, r3
    1b64:	3720      	adds	r7, #32
    1b66:	46bd      	mov	sp, r7
    1b68:	bd80      	pop	{r7, pc}
    1b6a:	bf00      	nop
    1b6c:	00009670 	.word	0x00009670

00001b70 <do_conv_numeric>:
                            va_list *      ap,
                            char           code,
                            void *      (* cons)(void *, const char *, size_t),
                            void * *       parg,
                            unsigned int base )
{
    1b70:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    1b74:	b0cb      	sub	sp, #300	@ 0x12c
    1b76:	af06      	add	r7, sp, #24
    1b78:	f507 7688 	add.w	r6, r7, #272	@ 0x110
    1b7c:	f5a6 7682 	sub.w	r6, r6, #260	@ 0x104
    1b80:	6030      	str	r0, [r6, #0]
    1b82:	f507 7088 	add.w	r0, r7, #272	@ 0x110
    1b86:	f5a0 7084 	sub.w	r0, r0, #264	@ 0x108
    1b8a:	6001      	str	r1, [r0, #0]
    1b8c:	4611      	mov	r1, r2
    1b8e:	f507 7288 	add.w	r2, r7, #272	@ 0x110
    1b92:	f5a2 7288 	sub.w	r2, r2, #272	@ 0x110
    1b96:	6013      	str	r3, [r2, #0]
    1b98:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1b9c:	f2a3 1309 	subw	r3, r3, #265	@ 0x109
    1ba0:	460a      	mov	r2, r1
    1ba2:	701a      	strb	r2, [r3, #0]
    size_t length = 0;
    1ba4:	2300      	movs	r3, #0
    1ba6:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
    size_t numWidth, digitWidth;
    char numBuffer[BUFLEN];
    size_t ps1 = 0, ps2 = 0, pz = 0, pfx_n = 0;
    1baa:	2300      	movs	r3, #0
    1bac:	61bb      	str	r3, [r7, #24]
    1bae:	2300      	movs	r3, #0
    1bb0:	617b      	str	r3, [r7, #20]
    1bb2:	2300      	movs	r3, #0
    1bb4:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    1bb8:	2300      	movs	r3, #0
    1bba:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
    const char * pfx_s = NULL;
    1bbe:	2300      	movs	r3, #0
    1bc0:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    unsigned long uv;
    char prefix[2];
    size_t pfxWidth = 0;
    1bc4:	2300      	movs	r3, #0
    1bc6:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    size_t grp_insertions = 0;
    1bca:	2300      	movs	r3, #0
    1bcc:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
    /* Get the value.
     * Signed values need special handling for negative values and the
     *  extra options for sign output which don't apply to the unsigned
     *  values.
     */
    if ( pspec->flags & F_IS_SIGNED )
    1bd0:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1bd4:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
    1bd8:	681b      	ldr	r3, [r3, #0]
    1bda:	685b      	ldr	r3, [r3, #4]
    1bdc:	f003 0380 	and.w	r3, r3, #128	@ 0x80
    1be0:	2b00      	cmp	r3, #0
    1be2:	f000 80ee 	beq.w	1dc2 <do_conv_numeric+0x252>
    {
        long v;

        if ( pspec->qual == 'l' )
    1be6:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1bea:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
    1bee:	681b      	ldr	r3, [r3, #0]
    1bf0:	f993 3014 	ldrsb.w	r3, [r3, #20]
    1bf4:	2b6c      	cmp	r3, #108	@ 0x6c
    1bf6:	d110      	bne.n	1c1a <do_conv_numeric+0xaa>
            v = (long)va_arg( *ap, long );
    1bf8:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1bfc:	f5a3 7384 	sub.w	r3, r3, #264	@ 0x108
    1c00:	681b      	ldr	r3, [r3, #0]
    1c02:	681b      	ldr	r3, [r3, #0]
    1c04:	1d19      	adds	r1, r3, #4
    1c06:	f507 7288 	add.w	r2, r7, #272	@ 0x110
    1c0a:	f5a2 7284 	sub.w	r2, r2, #264	@ 0x108
    1c0e:	6812      	ldr	r2, [r2, #0]
    1c10:	6011      	str	r1, [r2, #0]
    1c12:	681b      	ldr	r3, [r3, #0]
    1c14:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    1c18:	e063      	b.n	1ce2 <do_conv_numeric+0x172>
        else if ( pspec->qual == 'j' )
    1c1a:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1c1e:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
    1c22:	681b      	ldr	r3, [r3, #0]
    1c24:	f993 3014 	ldrsb.w	r3, [r3, #20]
    1c28:	2b6a      	cmp	r3, #106	@ 0x6a
    1c2a:	d116      	bne.n	1c5a <do_conv_numeric+0xea>
            v = (long)va_arg( *ap, intmax_t );
    1c2c:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1c30:	f5a3 7384 	sub.w	r3, r3, #264	@ 0x108
    1c34:	681b      	ldr	r3, [r3, #0]
    1c36:	681b      	ldr	r3, [r3, #0]
    1c38:	3307      	adds	r3, #7
    1c3a:	f023 0307 	bic.w	r3, r3, #7
    1c3e:	f103 0108 	add.w	r1, r3, #8
    1c42:	f507 7288 	add.w	r2, r7, #272	@ 0x110
    1c46:	f5a2 7284 	sub.w	r2, r2, #264	@ 0x108
    1c4a:	6812      	ldr	r2, [r2, #0]
    1c4c:	6011      	str	r1, [r2, #0]
    1c4e:	e9d3 2300 	ldrd	r2, r3, [r3]
    1c52:	4613      	mov	r3, r2
    1c54:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    1c58:	e043      	b.n	1ce2 <do_conv_numeric+0x172>
        else if ( pspec->qual == 'z' )
    1c5a:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1c5e:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
    1c62:	681b      	ldr	r3, [r3, #0]
    1c64:	f993 3014 	ldrsb.w	r3, [r3, #20]
    1c68:	2b7a      	cmp	r3, #122	@ 0x7a
    1c6a:	d110      	bne.n	1c8e <do_conv_numeric+0x11e>
            v = (long)va_arg( *ap, size_t );
    1c6c:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1c70:	f5a3 7384 	sub.w	r3, r3, #264	@ 0x108
    1c74:	681b      	ldr	r3, [r3, #0]
    1c76:	681b      	ldr	r3, [r3, #0]
    1c78:	1d19      	adds	r1, r3, #4
    1c7a:	f507 7288 	add.w	r2, r7, #272	@ 0x110
    1c7e:	f5a2 7284 	sub.w	r2, r2, #264	@ 0x108
    1c82:	6812      	ldr	r2, [r2, #0]
    1c84:	6011      	str	r1, [r2, #0]
    1c86:	681b      	ldr	r3, [r3, #0]
    1c88:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    1c8c:	e029      	b.n	1ce2 <do_conv_numeric+0x172>
        else if ( pspec->qual == 't' )
    1c8e:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1c92:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
    1c96:	681b      	ldr	r3, [r3, #0]
    1c98:	f993 3014 	ldrsb.w	r3, [r3, #20]
    1c9c:	2b74      	cmp	r3, #116	@ 0x74
    1c9e:	d110      	bne.n	1cc2 <do_conv_numeric+0x152>
            v = (long)va_arg( *ap, ptrdiff_t );
    1ca0:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1ca4:	f5a3 7384 	sub.w	r3, r3, #264	@ 0x108
    1ca8:	681b      	ldr	r3, [r3, #0]
    1caa:	681b      	ldr	r3, [r3, #0]
    1cac:	1d19      	adds	r1, r3, #4
    1cae:	f507 7288 	add.w	r2, r7, #272	@ 0x110
    1cb2:	f5a2 7284 	sub.w	r2, r2, #264	@ 0x108
    1cb6:	6812      	ldr	r2, [r2, #0]
    1cb8:	6011      	str	r1, [r2, #0]
    1cba:	681b      	ldr	r3, [r3, #0]
    1cbc:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    1cc0:	e00f      	b.n	1ce2 <do_conv_numeric+0x172>
        else
            v = (long)va_arg( *ap, int );
    1cc2:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1cc6:	f5a3 7384 	sub.w	r3, r3, #264	@ 0x108
    1cca:	681b      	ldr	r3, [r3, #0]
    1ccc:	681b      	ldr	r3, [r3, #0]
    1cce:	1d19      	adds	r1, r3, #4
    1cd0:	f507 7288 	add.w	r2, r7, #272	@ 0x110
    1cd4:	f5a2 7284 	sub.w	r2, r2, #264	@ 0x108
    1cd8:	6812      	ldr	r2, [r2, #0]
    1cda:	6011      	str	r1, [r2, #0]
    1cdc:	681b      	ldr	r3, [r3, #0]
    1cde:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec

        if ( pspec->qual == 'h' )
    1ce2:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1ce6:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
    1cea:	681b      	ldr	r3, [r3, #0]
    1cec:	f993 3014 	ldrsb.w	r3, [r3, #20]
    1cf0:	2b68      	cmp	r3, #104	@ 0x68
    1cf2:	d104      	bne.n	1cfe <do_conv_numeric+0x18e>
            v = (short)v;
    1cf4:	f8d7 30ec 	ldr.w	r3, [r7, #236]	@ 0xec
    1cf8:	b21b      	sxth	r3, r3
    1cfa:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
        if ( pspec->qual == DOUBLE_QUAL( 'h' ) )
    1cfe:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1d02:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
    1d06:	681b      	ldr	r3, [r3, #0]
    1d08:	f993 3014 	ldrsb.w	r3, [r3, #20]
    1d0c:	2b69      	cmp	r3, #105	@ 0x69
    1d0e:	d104      	bne.n	1d1a <do_conv_numeric+0x1aa>
            v = (signed char)v;
    1d10:	f8d7 30ec 	ldr.w	r3, [r7, #236]	@ 0xec
    1d14:	b25b      	sxtb	r3, r3
    1d16:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec

        /* Get absolute value */
        uv = v < 0 ? -v : v;
    1d1a:	f8d7 30ec 	ldr.w	r3, [r7, #236]	@ 0xec
    1d1e:	2b00      	cmp	r3, #0
    1d20:	bfb8      	it	lt
    1d22:	425b      	neglt	r3, r3
    1d24:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8

        /* Based on original sign and flags work out any prefix */
        prefix[0] = '\0';
    1d28:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1d2c:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
    1d30:	2200      	movs	r2, #0
    1d32:	701a      	strb	r2, [r3, #0]
        if ( v < 0 )
    1d34:	f8d7 30ec 	ldr.w	r3, [r7, #236]	@ 0xec
    1d38:	2b00      	cmp	r3, #0
    1d3a:	da06      	bge.n	1d4a <do_conv_numeric+0x1da>
            prefix[0]     = '-';
    1d3c:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1d40:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
    1d44:	222d      	movs	r2, #45	@ 0x2d
    1d46:	701a      	strb	r2, [r3, #0]
    1d48:	e020      	b.n	1d8c <do_conv_numeric+0x21c>
        else if ( pspec->flags & FPLUS )
    1d4a:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1d4e:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
    1d52:	681b      	ldr	r3, [r3, #0]
    1d54:	685b      	ldr	r3, [r3, #4]
    1d56:	f003 0302 	and.w	r3, r3, #2
    1d5a:	2b00      	cmp	r3, #0
    1d5c:	d006      	beq.n	1d6c <do_conv_numeric+0x1fc>
            prefix[0]     = '+';
    1d5e:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1d62:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
    1d66:	222b      	movs	r2, #43	@ 0x2b
    1d68:	701a      	strb	r2, [r3, #0]
    1d6a:	e00f      	b.n	1d8c <do_conv_numeric+0x21c>
        else if ( pspec->flags & FSPACE )
    1d6c:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1d70:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
    1d74:	681b      	ldr	r3, [r3, #0]
    1d76:	685b      	ldr	r3, [r3, #4]
    1d78:	f003 0301 	and.w	r3, r3, #1
    1d7c:	2b00      	cmp	r3, #0
    1d7e:	d005      	beq.n	1d8c <do_conv_numeric+0x21c>
            prefix[0]     = ' ';
    1d80:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1d84:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
    1d88:	2220      	movs	r2, #32
    1d8a:	701a      	strb	r2, [r3, #0]

        if ( prefix[0] != '\0' )
    1d8c:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1d90:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
    1d94:	f993 3000 	ldrsb.w	r3, [r3]
    1d98:	2b00      	cmp	r3, #0
    1d9a:	f000 80b2 	beq.w	1f02 <do_conv_numeric+0x392>
        {
            pfxWidth      = 1;
    1d9e:	2301      	movs	r3, #1
    1da0:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
            pspec->flags |= FHASH;
    1da4:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1da8:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
    1dac:	681b      	ldr	r3, [r3, #0]
    1dae:	685b      	ldr	r3, [r3, #4]
    1db0:	f043 0208 	orr.w	r2, r3, #8
    1db4:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1db8:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
    1dbc:	681b      	ldr	r3, [r3, #0]
    1dbe:	605a      	str	r2, [r3, #4]
    1dc0:	e09f      	b.n	1f02 <do_conv_numeric+0x392>
        }
    }
    else
    {
        if ( pspec->qual == 'l' )
    1dc2:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1dc6:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
    1dca:	681b      	ldr	r3, [r3, #0]
    1dcc:	f993 3014 	ldrsb.w	r3, [r3, #20]
    1dd0:	2b6c      	cmp	r3, #108	@ 0x6c
    1dd2:	d110      	bne.n	1df6 <do_conv_numeric+0x286>
            uv = (unsigned long)va_arg( *ap, unsigned long );
    1dd4:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1dd8:	f5a3 7384 	sub.w	r3, r3, #264	@ 0x108
    1ddc:	681b      	ldr	r3, [r3, #0]
    1dde:	681b      	ldr	r3, [r3, #0]
    1de0:	1d19      	adds	r1, r3, #4
    1de2:	f507 7288 	add.w	r2, r7, #272	@ 0x110
    1de6:	f5a2 7284 	sub.w	r2, r2, #264	@ 0x108
    1dea:	6812      	ldr	r2, [r2, #0]
    1dec:	6011      	str	r1, [r2, #0]
    1dee:	681b      	ldr	r3, [r3, #0]
    1df0:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    1df4:	e063      	b.n	1ebe <do_conv_numeric+0x34e>
        else if ( pspec->qual == 'j' )
    1df6:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1dfa:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
    1dfe:	681b      	ldr	r3, [r3, #0]
    1e00:	f993 3014 	ldrsb.w	r3, [r3, #20]
    1e04:	2b6a      	cmp	r3, #106	@ 0x6a
    1e06:	d116      	bne.n	1e36 <do_conv_numeric+0x2c6>
            uv = (unsigned long)va_arg( *ap, uintmax_t );
    1e08:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1e0c:	f5a3 7384 	sub.w	r3, r3, #264	@ 0x108
    1e10:	681b      	ldr	r3, [r3, #0]
    1e12:	681b      	ldr	r3, [r3, #0]
    1e14:	3307      	adds	r3, #7
    1e16:	f023 0307 	bic.w	r3, r3, #7
    1e1a:	f103 0108 	add.w	r1, r3, #8
    1e1e:	f507 7288 	add.w	r2, r7, #272	@ 0x110
    1e22:	f5a2 7284 	sub.w	r2, r2, #264	@ 0x108
    1e26:	6812      	ldr	r2, [r2, #0]
    1e28:	6011      	str	r1, [r2, #0]
    1e2a:	e9d3 2300 	ldrd	r2, r3, [r3]
    1e2e:	4613      	mov	r3, r2
    1e30:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    1e34:	e043      	b.n	1ebe <do_conv_numeric+0x34e>
        else if ( pspec->qual == 'z' )
    1e36:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1e3a:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
    1e3e:	681b      	ldr	r3, [r3, #0]
    1e40:	f993 3014 	ldrsb.w	r3, [r3, #20]
    1e44:	2b7a      	cmp	r3, #122	@ 0x7a
    1e46:	d110      	bne.n	1e6a <do_conv_numeric+0x2fa>
            uv = (unsigned long)va_arg( *ap, size_t );
    1e48:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1e4c:	f5a3 7384 	sub.w	r3, r3, #264	@ 0x108
    1e50:	681b      	ldr	r3, [r3, #0]
    1e52:	681b      	ldr	r3, [r3, #0]
    1e54:	1d19      	adds	r1, r3, #4
    1e56:	f507 7288 	add.w	r2, r7, #272	@ 0x110
    1e5a:	f5a2 7284 	sub.w	r2, r2, #264	@ 0x108
    1e5e:	6812      	ldr	r2, [r2, #0]
    1e60:	6011      	str	r1, [r2, #0]
    1e62:	681b      	ldr	r3, [r3, #0]
    1e64:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    1e68:	e029      	b.n	1ebe <do_conv_numeric+0x34e>
        else if ( pspec->qual == 't' )
    1e6a:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1e6e:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
    1e72:	681b      	ldr	r3, [r3, #0]
    1e74:	f993 3014 	ldrsb.w	r3, [r3, #20]
    1e78:	2b74      	cmp	r3, #116	@ 0x74
    1e7a:	d110      	bne.n	1e9e <do_conv_numeric+0x32e>
            uv = (unsigned long)va_arg( *ap, ptrdiff_t );
    1e7c:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1e80:	f5a3 7384 	sub.w	r3, r3, #264	@ 0x108
    1e84:	681b      	ldr	r3, [r3, #0]
    1e86:	681b      	ldr	r3, [r3, #0]
    1e88:	1d19      	adds	r1, r3, #4
    1e8a:	f507 7288 	add.w	r2, r7, #272	@ 0x110
    1e8e:	f5a2 7284 	sub.w	r2, r2, #264	@ 0x108
    1e92:	6812      	ldr	r2, [r2, #0]
    1e94:	6011      	str	r1, [r2, #0]
    1e96:	681b      	ldr	r3, [r3, #0]
    1e98:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    1e9c:	e00f      	b.n	1ebe <do_conv_numeric+0x34e>
        else
            uv = (unsigned long)va_arg( *ap, unsigned int );
    1e9e:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1ea2:	f5a3 7384 	sub.w	r3, r3, #264	@ 0x108
    1ea6:	681b      	ldr	r3, [r3, #0]
    1ea8:	681b      	ldr	r3, [r3, #0]
    1eaa:	1d19      	adds	r1, r3, #4
    1eac:	f507 7288 	add.w	r2, r7, #272	@ 0x110
    1eb0:	f5a2 7284 	sub.w	r2, r2, #264	@ 0x108
    1eb4:	6812      	ldr	r2, [r2, #0]
    1eb6:	6011      	str	r1, [r2, #0]
    1eb8:	681b      	ldr	r3, [r3, #0]
    1eba:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8

        if ( pspec->qual == 'h' )
    1ebe:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1ec2:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
    1ec6:	681b      	ldr	r3, [r3, #0]
    1ec8:	f993 3014 	ldrsb.w	r3, [r3, #20]
    1ecc:	2b68      	cmp	r3, #104	@ 0x68
    1ece:	d104      	bne.n	1eda <do_conv_numeric+0x36a>
            uv = (unsigned short)uv;
    1ed0:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
    1ed4:	b29b      	uxth	r3, r3
    1ed6:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
        if ( pspec->qual == DOUBLE_QUAL( 'h' ) )
    1eda:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1ede:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
    1ee2:	681b      	ldr	r3, [r3, #0]
    1ee4:	f993 3014 	ldrsb.w	r3, [r3, #20]
    1ee8:	2b69      	cmp	r3, #105	@ 0x69
    1eea:	d104      	bne.n	1ef6 <do_conv_numeric+0x386>
            uv = (unsigned char)uv;
    1eec:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
    1ef0:	b2db      	uxtb	r3, r3
    1ef2:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8

        prefix[0] = '0';
    1ef6:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1efa:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
    1efe:	2230      	movs	r2, #48	@ 0x30
    1f00:	701a      	strb	r2, [r3, #0]
    }

    if ( code == 'o' && uv )
    1f02:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1f06:	f2a3 1309 	subw	r3, r3, #265	@ 0x109
    1f0a:	f993 3000 	ldrsb.w	r3, [r3]
    1f0e:	2b6f      	cmp	r3, #111	@ 0x6f
    1f10:	d106      	bne.n	1f20 <do_conv_numeric+0x3b0>
    1f12:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
    1f16:	2b00      	cmp	r3, #0
    1f18:	d002      	beq.n	1f20 <do_conv_numeric+0x3b0>
        pfxWidth = 1;
    1f1a:	2301      	movs	r3, #1
    1f1c:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4

    if ( code == 'x' || code == 'X' || code == 'b' )
    1f20:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1f24:	f2a3 1309 	subw	r3, r3, #265	@ 0x109
    1f28:	f993 3000 	ldrsb.w	r3, [r3]
    1f2c:	2b78      	cmp	r3, #120	@ 0x78
    1f2e:	d00f      	beq.n	1f50 <do_conv_numeric+0x3e0>
    1f30:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1f34:	f2a3 1309 	subw	r3, r3, #265	@ 0x109
    1f38:	f993 3000 	ldrsb.w	r3, [r3]
    1f3c:	2b58      	cmp	r3, #88	@ 0x58
    1f3e:	d007      	beq.n	1f50 <do_conv_numeric+0x3e0>
    1f40:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1f44:	f2a3 1309 	subw	r3, r3, #265	@ 0x109
    1f48:	f993 3000 	ldrsb.w	r3, [r3]
    1f4c:	2b62      	cmp	r3, #98	@ 0x62
    1f4e:	d132      	bne.n	1fb6 <do_conv_numeric+0x446>
    {
        /* if non-zero or bang flag, add prefix for hex and binary */
        if ( ( pspec->flags & FBANG ) || uv )
    1f50:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1f54:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
    1f58:	681b      	ldr	r3, [r3, #0]
    1f5a:	685b      	ldr	r3, [r3, #4]
    1f5c:	f003 0320 	and.w	r3, r3, #32
    1f60:	2b00      	cmp	r3, #0
    1f62:	d103      	bne.n	1f6c <do_conv_numeric+0x3fc>
    1f64:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
    1f68:	2b00      	cmp	r3, #0
    1f6a:	d00c      	beq.n	1f86 <do_conv_numeric+0x416>
        {
            prefix[1] = code;
    1f6c:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1f70:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
    1f74:	f507 7288 	add.w	r2, r7, #272	@ 0x110
    1f78:	f2a2 1209 	subw	r2, r2, #265	@ 0x109
    1f7c:	7812      	ldrb	r2, [r2, #0]
    1f7e:	705a      	strb	r2, [r3, #1]
            pfxWidth  = 2;
    1f80:	2302      	movs	r3, #2
    1f82:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
        }

        /* Bang flag forces lower-case */
        if ( pspec->flags & FBANG )
    1f86:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1f8a:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
    1f8e:	681b      	ldr	r3, [r3, #0]
    1f90:	685b      	ldr	r3, [r3, #4]
    1f92:	f003 0320 	and.w	r3, r3, #32
    1f96:	2b00      	cmp	r3, #0
    1f98:	d00d      	beq.n	1fb6 <do_conv_numeric+0x446>
            prefix[1] |= 0x20;
    1f9a:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1f9e:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
    1fa2:	f993 3001 	ldrsb.w	r3, [r3, #1]
    1fa6:	f043 0320 	orr.w	r3, r3, #32
    1faa:	b25a      	sxtb	r2, r3
    1fac:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1fb0:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
    1fb4:	705a      	strb	r2, [r3, #1]
    }

    if ( pspec->flags & FHASH )
    1fb6:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    1fba:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
    1fbe:	681b      	ldr	r3, [r3, #0]
    1fc0:	685b      	ldr	r3, [r3, #4]
    1fc2:	f003 0308 	and.w	r3, r3, #8
    1fc6:	2b00      	cmp	r3, #0
    1fc8:	d00e      	beq.n	1fe8 <do_conv_numeric+0x478>
    {
        length += pfxWidth;
    1fca:	f8d7 210c 	ldr.w	r2, [r7, #268]	@ 0x10c
    1fce:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
    1fd2:	4413      	add	r3, r2
    1fd4:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
        pfx_s = prefix;
    1fd8:	f107 0310 	add.w	r3, r7, #16
    1fdc:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
        pfx_n = pfxWidth;
    1fe0:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
    1fe4:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
     * We compute the remainder in the obvious way.
     *
     * For the other cases we can implement the necessary math through
     *  bit ops - masking and shifting.
     */
    if ( base == 10 )
    1fe8:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
    1fec:	2b0a      	cmp	r3, #10
    1fee:	d150      	bne.n	2092 <do_conv_numeric+0x522>
    {
        for( numWidth = 0; uv; )
    1ff0:	2300      	movs	r3, #0
    1ff2:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
    1ff6:	e047      	b.n	2088 <do_conv_numeric+0x518>
        {
#if defined(CONFIG_USE_INLINE_DIV10)
            unsigned long long div_a = uv * 0xCCCCCCCDULL;
    1ff8:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
    1ffc:	2200      	movs	r2, #0
    1ffe:	4698      	mov	r8, r3
    2000:	4691      	mov	r9, r2
    2002:	4baf      	ldr	r3, [pc, #700]	@ (22c0 <do_conv_numeric+0x750>)
    2004:	fb03 f209 	mul.w	r2, r3, r9
    2008:	2300      	movs	r3, #0
    200a:	fb03 f308 	mul.w	r3, r3, r8
    200e:	4413      	add	r3, r2
    2010:	4aab      	ldr	r2, [pc, #684]	@ (22c0 <do_conv_numeric+0x750>)
    2012:	fba8 4502 	umull	r4, r5, r8, r2
    2016:	442b      	add	r3, r5
    2018:	461d      	mov	r5, r3
    201a:	e9c7 452c 	strd	r4, r5, [r7, #176]	@ 0xb0
    201e:	e9c7 452c 	strd	r4, r5, [r7, #176]	@ 0xb0
            unsigned long div_uv = (div_a >> 32) >> 3;
    2022:	e9d7 012c 	ldrd	r0, r1, [r7, #176]	@ 0xb0
    2026:	f04f 0200 	mov.w	r2, #0
    202a:	f04f 0300 	mov.w	r3, #0
    202e:	08ca      	lsrs	r2, r1, #3
    2030:	2300      	movs	r3, #0
    2032:	4613      	mov	r3, r2
    2034:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
            unsigned long div_5uv = div_uv + (div_uv << 2);
    2038:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
    203c:	009b      	lsls	r3, r3, #2
    203e:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
    2042:	4413      	add	r3, r2
    2044:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
            unsigned long div_rem = uv - (div_5uv << 1);
    2048:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
    204c:	005b      	lsls	r3, r3, #1
    204e:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
    2052:	1ad3      	subs	r3, r2, r3
    2054:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
#else
            unsigned long div_uv  = uv / 10;
            unsigned long div_rem = uv % 10;
#endif

            ++numWidth;
    2058:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
    205c:	3301      	adds	r3, #1
    205e:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
            numBuffer[sizeof(numBuffer) - numWidth] = '0' + div_rem;
    2062:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
    2066:	b2db      	uxtb	r3, r3
    2068:	3330      	adds	r3, #48	@ 0x30
    206a:	b2da      	uxtb	r2, r3
    206c:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
    2070:	f1c3 0382 	rsb	r3, r3, #130	@ 0x82
    2074:	b252      	sxtb	r2, r2
    2076:	f503 7388 	add.w	r3, r3, #272	@ 0x110
    207a:	443b      	add	r3, r7
    207c:	f803 2cf4 	strb.w	r2, [r3, #-244]
            uv = div_uv;
    2080:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
    2084:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
        for( numWidth = 0; uv; )
    2088:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
    208c:	2b00      	cmp	r3, #0
    208e:	d1b3      	bne.n	1ff8 <do_conv_numeric+0x488>
    2090:	e0ac      	b.n	21ec <do_conv_numeric+0x67c>
        }
    }
     /* Special-case for bases 2, 8 or 16 for the dedicated conversion
      * specifiers %b, %o and %x/%X.
      */
    else if ( base == 2 || base == 8 || base == 16 )
    2092:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
    2096:	2b02      	cmp	r3, #2
    2098:	d007      	beq.n	20aa <do_conv_numeric+0x53a>
    209a:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
    209e:	2b08      	cmp	r3, #8
    20a0:	d003      	beq.n	20aa <do_conv_numeric+0x53a>
    20a2:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
    20a6:	2b10      	cmp	r3, #16
    20a8:	d15b      	bne.n	2162 <do_conv_numeric+0x5f2>
    {
        unsigned int mask  = base - 1;
    20aa:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
    20ae:	3b01      	subs	r3, #1
    20b0:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
        unsigned int shift = base == 16 ? 4
                                        : base == 8 ? 3 : 1;
    20b4:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
    20b8:	2b10      	cmp	r3, #16
    20ba:	d007      	beq.n	20cc <do_conv_numeric+0x55c>
    20bc:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
    20c0:	2b08      	cmp	r3, #8
    20c2:	d101      	bne.n	20c8 <do_conv_numeric+0x558>
    20c4:	2303      	movs	r3, #3
    20c6:	e002      	b.n	20ce <do_conv_numeric+0x55e>
    20c8:	2301      	movs	r3, #1
    20ca:	e000      	b.n	20ce <do_conv_numeric+0x55e>
    20cc:	2304      	movs	r3, #4
        unsigned int shift = base == 16 ? 4
    20ce:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc

        for( numWidth = 0; uv; uv >>= shift )
    20d2:	2300      	movs	r3, #0
    20d4:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
    20d8:	e03e      	b.n	2158 <do_conv_numeric+0x5e8>
        {
            char cc = digits[uv & mask];
    20da:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
    20de:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
    20e2:	4013      	ands	r3, r2
    20e4:	4a77      	ldr	r2, [pc, #476]	@ (22c4 <do_conv_numeric+0x754>)
    20e6:	5cd3      	ldrb	r3, [r2, r3]
    20e8:	f887 30eb 	strb.w	r3, [r7, #235]	@ 0xeb

            /* convert to lower case? */
            if ( code == 'x' || code == 'i' || code == 'u' )
    20ec:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    20f0:	f2a3 1309 	subw	r3, r3, #265	@ 0x109
    20f4:	f993 3000 	ldrsb.w	r3, [r3]
    20f8:	2b78      	cmp	r3, #120	@ 0x78
    20fa:	d00f      	beq.n	211c <do_conv_numeric+0x5ac>
    20fc:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    2100:	f2a3 1309 	subw	r3, r3, #265	@ 0x109
    2104:	f993 3000 	ldrsb.w	r3, [r3]
    2108:	2b69      	cmp	r3, #105	@ 0x69
    210a:	d007      	beq.n	211c <do_conv_numeric+0x5ac>
    210c:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    2110:	f2a3 1309 	subw	r3, r3, #265	@ 0x109
    2114:	f993 3000 	ldrsb.w	r3, [r3]
    2118:	2b75      	cmp	r3, #117	@ 0x75
    211a:	d105      	bne.n	2128 <do_conv_numeric+0x5b8>
                cc |= 0x20;
    211c:	f897 30eb 	ldrb.w	r3, [r7, #235]	@ 0xeb
    2120:	f043 0320 	orr.w	r3, r3, #32
    2124:	f887 30eb 	strb.w	r3, [r7, #235]	@ 0xeb

            ++numWidth;
    2128:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
    212c:	3301      	adds	r3, #1
    212e:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
            numBuffer[sizeof(numBuffer) - numWidth] = cc;
    2132:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
    2136:	f1c3 0382 	rsb	r3, r3, #130	@ 0x82
    213a:	f503 7388 	add.w	r3, r3, #272	@ 0x110
    213e:	443b      	add	r3, r7
    2140:	f897 20eb 	ldrb.w	r2, [r7, #235]	@ 0xeb
    2144:	f803 2cf4 	strb.w	r2, [r3, #-244]
        for( numWidth = 0; uv; uv >>= shift )
    2148:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
    214c:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
    2150:	fa22 f303 	lsr.w	r3, r2, r3
    2154:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    2158:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
    215c:	2b00      	cmp	r3, #0
    215e:	d1bc      	bne.n	20da <do_conv_numeric+0x56a>
    {
    2160:	e044      	b.n	21ec <do_conv_numeric+0x67c>
        }
    }
    else /* all other bases */
    {
       for ( numWidth = 0; uv; uv /= base )
    2162:	2300      	movs	r3, #0
    2164:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
    2168:	e03c      	b.n	21e4 <do_conv_numeric+0x674>
       {
          char cc = digits[uv % base];
    216a:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
    216e:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
    2172:	fbb3 f2f2 	udiv	r2, r3, r2
    2176:	f8d7 1134 	ldr.w	r1, [r7, #308]	@ 0x134
    217a:	fb01 f202 	mul.w	r2, r1, r2
    217e:	1a9b      	subs	r3, r3, r2
    2180:	4a50      	ldr	r2, [pc, #320]	@ (22c4 <do_conv_numeric+0x754>)
    2182:	5cd3      	ldrb	r3, [r2, r3]
    2184:	f887 30ea 	strb.w	r3, [r7, #234]	@ 0xea

          /* convert to lower case? */
          if ( code == 'i' || code == 'u' )
    2188:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    218c:	f2a3 1309 	subw	r3, r3, #265	@ 0x109
    2190:	f993 3000 	ldrsb.w	r3, [r3]
    2194:	2b69      	cmp	r3, #105	@ 0x69
    2196:	d007      	beq.n	21a8 <do_conv_numeric+0x638>
    2198:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    219c:	f2a3 1309 	subw	r3, r3, #265	@ 0x109
    21a0:	f993 3000 	ldrsb.w	r3, [r3]
    21a4:	2b75      	cmp	r3, #117	@ 0x75
    21a6:	d105      	bne.n	21b4 <do_conv_numeric+0x644>
             cc |= 0x20;
    21a8:	f897 30ea 	ldrb.w	r3, [r7, #234]	@ 0xea
    21ac:	f043 0320 	orr.w	r3, r3, #32
    21b0:	f887 30ea 	strb.w	r3, [r7, #234]	@ 0xea

          ++numWidth;
    21b4:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
    21b8:	3301      	adds	r3, #1
    21ba:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
          numBuffer[sizeof(numBuffer) - numWidth] = cc;
    21be:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
    21c2:	f1c3 0382 	rsb	r3, r3, #130	@ 0x82
    21c6:	f503 7388 	add.w	r3, r3, #272	@ 0x110
    21ca:	443b      	add	r3, r7
    21cc:	f897 20ea 	ldrb.w	r2, [r7, #234]	@ 0xea
    21d0:	f803 2cf4 	strb.w	r2, [r3, #-244]
       for ( numWidth = 0; uv; uv /= base )
    21d4:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
    21d8:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
    21dc:	fbb2 f3f3 	udiv	r3, r2, r3
    21e0:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    21e4:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
    21e8:	2b00      	cmp	r3, #0
    21ea:	d1be      	bne.n	216a <do_conv_numeric+0x5fa>
       }
    }

    if ( pspec->grouping.len )
    21ec:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    21f0:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
    21f4:	681b      	ldr	r3, [r3, #0]
    21f6:	69db      	ldr	r3, [r3, #28]
    21f8:	2b00      	cmp	r3, #0
    21fa:	f000 811c 	beq.w	2436 <do_conv_numeric+0x8c6>
    {
#if defined(CONFIG_HAVE_ALT_PTR)
        enum ptr_mode mode  = pspec->grouping.mode;
#endif
        const void *  ptr   = pspec->grouping.ptr;
    21fe:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    2202:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
    2206:	681b      	ldr	r3, [r3, #0]
    2208:	699b      	ldr	r3, [r3, #24]
    220a:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
        size_t        glen  = pspec->grouping.len;
    220e:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    2212:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
    2216:	681b      	ldr	r3, [r3, #0]
    2218:	69db      	ldr	r3, [r3, #28]
    221a:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
        char          grp;
        int           wid   = 0;
    221e:	2300      	movs	r3, #0
    2220:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
        unsigned int  decade;
        size_t        d_rem = numWidth;
    2224:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
    2228:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
        size_t        idx   = sizeof(numBuffer) - numWidth;
    222c:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
    2230:	f1c3 0382 	rsb	r3, r3, #130	@ 0x82
    2234:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
        size_t        s, n;

        MOVE_VOID_PTR( ptr, glen - 1 );
    2238:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
    223c:	3b01      	subs	r3, #1
    223e:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
    2242:	4413      	add	r3, r2
    2244:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4

        while ( d_rem )
    2248:	e0e6      	b.n	2418 <do_conv_numeric+0x8a8>
        {
            if ( glen )
    224a:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
    224e:	2b00      	cmp	r3, #0
    2250:	f000 8085 	beq.w	235e <do_conv_numeric+0x7ee>
            {
                grp = READ_CHAR( mode, ptr );
    2254:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
    2258:	781b      	ldrb	r3, [r3, #0]
    225a:	f887 30df 	strb.w	r3, [r7, #223]	@ 0xdf

                if ( grp == '-' )
    225e:	f997 30df 	ldrsb.w	r3, [r7, #223]	@ 0xdf
    2262:	2b2d      	cmp	r3, #45	@ 0x2d
    2264:	f000 80de 	beq.w	2424 <do_conv_numeric+0x8b4>
                    break;

                if ( grp == '*' )
    2268:	f997 30df 	ldrsb.w	r3, [r7, #223]	@ 0xdf
    226c:	2b2a      	cmp	r3, #42	@ 0x2a
    226e:	d11f      	bne.n	22b0 <do_conv_numeric+0x740>
                {
                    wid = (int)va_arg( *ap, int );
    2270:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    2274:	f5a3 7384 	sub.w	r3, r3, #264	@ 0x108
    2278:	681b      	ldr	r3, [r3, #0]
    227a:	681b      	ldr	r3, [r3, #0]
    227c:	1d19      	adds	r1, r3, #4
    227e:	f507 7288 	add.w	r2, r7, #272	@ 0x110
    2282:	f5a2 7284 	sub.w	r2, r2, #264	@ 0x108
    2286:	6812      	ldr	r2, [r2, #0]
    2288:	6011      	str	r1, [r2, #0]
    228a:	681b      	ldr	r3, [r3, #0]
    228c:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
                    if ( wid < 0 )
    2290:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
    2294:	2b00      	cmp	r3, #0
    2296:	f2c0 80c7 	blt.w	2428 <do_conv_numeric+0x8b8>
                        break;

                    DEC_VOID_PTR(ptr);
    229a:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
    229e:	3b01      	subs	r3, #1
    22a0:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
                    --glen;
    22a4:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
    22a8:	3b01      	subs	r3, #1
    22aa:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    22ae:	e043      	b.n	2338 <do_conv_numeric+0x7c8>
                }
                else
                {
                    for ( wid = 0, decade = 1;
    22b0:	2300      	movs	r3, #0
    22b2:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
    22b6:	2301      	movs	r3, #1
    22b8:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
    22bc:	e023      	b.n	2306 <do_conv_numeric+0x796>
    22be:	bf00      	nop
    22c0:	cccccccd 	.word	0xcccccccd
    22c4:	00009680 	.word	0x00009680
                          glen != 0
                             && ( grp = READ_CHAR( mode, ptr ) ) != '\0'
                             && ISDIGIT( grp );
                          DEC_VOID_PTR(ptr), --glen )
                    {
                        wid += decade * ( grp - '0' );
    22c8:	f997 30df 	ldrsb.w	r3, [r7, #223]	@ 0xdf
    22cc:	3b30      	subs	r3, #48	@ 0x30
    22ce:	461a      	mov	r2, r3
    22d0:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
    22d4:	fb03 f202 	mul.w	r2, r3, r2
    22d8:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
    22dc:	4413      	add	r3, r2
    22de:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
                        decade *= 10;
    22e2:	f8d7 20d4 	ldr.w	r2, [r7, #212]	@ 0xd4
    22e6:	4613      	mov	r3, r2
    22e8:	009b      	lsls	r3, r3, #2
    22ea:	4413      	add	r3, r2
    22ec:	005b      	lsls	r3, r3, #1
    22ee:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
                          DEC_VOID_PTR(ptr), --glen )
    22f2:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
    22f6:	3b01      	subs	r3, #1
    22f8:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    22fc:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
    2300:	3b01      	subs	r3, #1
    2302:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
                             && ISDIGIT( grp );
    2306:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
    230a:	2b00      	cmp	r3, #0
    230c:	d014      	beq.n	2338 <do_conv_numeric+0x7c8>
                             && ( grp = READ_CHAR( mode, ptr ) ) != '\0'
    230e:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
    2312:	781b      	ldrb	r3, [r3, #0]
    2314:	f887 30df 	strb.w	r3, [r7, #223]	@ 0xdf
    2318:	f997 30df 	ldrsb.w	r3, [r7, #223]	@ 0xdf
    231c:	2b00      	cmp	r3, #0
    231e:	d00b      	beq.n	2338 <do_conv_numeric+0x7c8>
                             && ISDIGIT( grp );
    2320:	f997 30df 	ldrsb.w	r3, [r7, #223]	@ 0xdf
    2324:	3301      	adds	r3, #1
    2326:	4a87      	ldr	r2, [pc, #540]	@ (2544 <do_conv_numeric+0x9d4>)
    2328:	4413      	add	r3, r2
    232a:	f993 3000 	ldrsb.w	r3, [r3]
    232e:	b2db      	uxtb	r3, r3
    2330:	f003 0304 	and.w	r3, r3, #4
    2334:	2b00      	cmp	r3, #0
    2336:	d1c7      	bne.n	22c8 <do_conv_numeric+0x758>
                    }
                }

                if ( !glen )
    2338:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
    233c:	2b00      	cmp	r3, #0
    233e:	d075      	beq.n	242c <do_conv_numeric+0x8bc>
                    break;

                grp = READ_CHAR( mode, ptr );
    2340:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
    2344:	781b      	ldrb	r3, [r3, #0]
    2346:	f887 30df 	strb.w	r3, [r7, #223]	@ 0xdf
                DEC_VOID_PTR(ptr);
    234a:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
    234e:	3b01      	subs	r3, #1
    2350:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
                --glen;
    2354:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
    2358:	3b01      	subs	r3, #1
    235a:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
            }

            if ( wid )
    235e:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
    2362:	2b00      	cmp	r3, #0
    2364:	d054      	beq.n	2410 <do_conv_numeric+0x8a0>
            {
                if ( d_rem <= wid )
    2366:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
    236a:	f8d7 20d0 	ldr.w	r2, [r7, #208]	@ 0xd0
    236e:	429a      	cmp	r2, r3
    2370:	d95e      	bls.n	2430 <do_conv_numeric+0x8c0>
                    break;

                for ( s = idx, n = d_rem - wid; n; n--, s++ )
    2372:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
    2376:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
    237a:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
    237e:	f8d7 20d0 	ldr.w	r2, [r7, #208]	@ 0xd0
    2382:	1ad3      	subs	r3, r2, r3
    2384:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
    2388:	e018      	b.n	23bc <do_conv_numeric+0x84c>
                    numBuffer[s-1] = numBuffer[s];
    238a:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
    238e:	3b01      	subs	r3, #1
    2390:	f107 011c 	add.w	r1, r7, #28
    2394:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
    2398:	440a      	add	r2, r1
    239a:	f992 2000 	ldrsb.w	r2, [r2]
    239e:	f503 7388 	add.w	r3, r3, #272	@ 0x110
    23a2:	443b      	add	r3, r7
    23a4:	f803 2cf4 	strb.w	r2, [r3, #-244]
                for ( s = idx, n = d_rem - wid; n; n--, s++ )
    23a8:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
    23ac:	3b01      	subs	r3, #1
    23ae:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
    23b2:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
    23b6:	3301      	adds	r3, #1
    23b8:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
    23bc:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
    23c0:	2b00      	cmp	r3, #0
    23c2:	d1e2      	bne.n	238a <do_conv_numeric+0x81a>

                idx--;
    23c4:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
    23c8:	3b01      	subs	r3, #1
    23ca:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
                numBuffer[idx + d_rem - wid] = grp;
    23ce:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
    23d2:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
    23d6:	441a      	add	r2, r3
    23d8:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
    23dc:	1ad3      	subs	r3, r2, r3
    23de:	f503 7388 	add.w	r3, r3, #272	@ 0x110
    23e2:	443b      	add	r3, r7
    23e4:	f897 20df 	ldrb.w	r2, [r7, #223]	@ 0xdf
    23e8:	f803 2cf4 	strb.w	r2, [r3, #-244]
                numWidth++;
    23ec:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
    23f0:	3301      	adds	r3, #1
    23f2:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
                grp_insertions++;
    23f6:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
    23fa:	3301      	adds	r3, #1
    23fc:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0

                d_rem -= wid;
    2400:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
    2404:	f8d7 20d0 	ldr.w	r2, [r7, #208]	@ 0xd0
    2408:	1ad3      	subs	r3, r2, r3
    240a:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
    240e:	e003      	b.n	2418 <do_conv_numeric+0x8a8>
            }
            else if ( !glen )
    2410:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
    2414:	2b00      	cmp	r3, #0
    2416:	d00d      	beq.n	2434 <do_conv_numeric+0x8c4>
        while ( d_rem )
    2418:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
    241c:	2b00      	cmp	r3, #0
    241e:	f47f af14 	bne.w	224a <do_conv_numeric+0x6da>
    2422:	e008      	b.n	2436 <do_conv_numeric+0x8c6>
                    break;
    2424:	bf00      	nop
    2426:	e006      	b.n	2436 <do_conv_numeric+0x8c6>
                        break;
    2428:	bf00      	nop
    242a:	e004      	b.n	2436 <do_conv_numeric+0x8c6>
                    break;
    242c:	bf00      	nop
    242e:	e002      	b.n	2436 <do_conv_numeric+0x8c6>
                    break;
    2430:	bf00      	nop
    2432:	e000      	b.n	2436 <do_conv_numeric+0x8c6>
                break;
    2434:	bf00      	nop
        }
    }

    digitWidth = numWidth;
    2436:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
    243a:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0

    /* apply default precision */
    if ( pspec->prec < 0 )
    243e:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    2442:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
    2446:	681b      	ldr	r3, [r3, #0]
    2448:	68db      	ldr	r3, [r3, #12]
    244a:	2b00      	cmp	r3, #0
    244c:	da07      	bge.n	245e <do_conv_numeric+0x8ee>
        pspec->prec = 1;
    244e:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    2452:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
    2456:	681b      	ldr	r3, [r3, #0]
    2458:	2201      	movs	r2, #1
    245a:	60da      	str	r2, [r3, #12]
    245c:	e00d      	b.n	247a <do_conv_numeric+0x90a>
    else
        pspec->flags &= ~FZERO; /* Ignore if precision specified */
    245e:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    2462:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
    2466:	681b      	ldr	r3, [r3, #0]
    2468:	685b      	ldr	r3, [r3, #4]
    246a:	f023 0210 	bic.w	r2, r3, #16
    246e:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    2472:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
    2476:	681b      	ldr	r3, [r3, #0]
    2478:	605a      	str	r2, [r3, #4]

    numWidth = MAX( numWidth, pspec->prec + grp_insertions );
    247a:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    247e:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
    2482:	681b      	ldr	r3, [r3, #0]
    2484:	68db      	ldr	r3, [r3, #12]
    2486:	461a      	mov	r2, r3
    2488:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
    248c:	4413      	add	r3, r2
    248e:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
    2492:	4293      	cmp	r3, r2
    2494:	bf38      	it	cc
    2496:	4613      	movcc	r3, r2
    2498:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
    length  += numWidth;
    249c:	f8d7 210c 	ldr.w	r2, [r7, #268]	@ 0x10c
    24a0:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
    24a4:	4413      	add	r3, r2
    24a6:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c

    calc_space_padding( pspec, length, &ps1, &ps2 );
    24aa:	f107 0314 	add.w	r3, r7, #20
    24ae:	f107 0218 	add.w	r2, r7, #24
    24b2:	f507 7188 	add.w	r1, r7, #272	@ 0x110
    24b6:	f5a1 7082 	sub.w	r0, r1, #260	@ 0x104
    24ba:	f8d7 110c 	ldr.w	r1, [r7, #268]	@ 0x10c
    24be:	6800      	ldr	r0, [r0, #0]
    24c0:	f7fe fa24 	bl	90c <calc_space_padding>

    /* Convert space padding into zero padding if we have the ZERO flag */
    pz = numWidth - digitWidth;
    24c4:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
    24c8:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
    24cc:	1ad3      	subs	r3, r2, r3
    24ce:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    if ( pspec->flags & FZERO )
    24d2:	f507 7388 	add.w	r3, r7, #272	@ 0x110
    24d6:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
    24da:	681b      	ldr	r3, [r3, #0]
    24dc:	685b      	ldr	r3, [r3, #4]
    24de:	f003 0310 	and.w	r3, r3, #16
    24e2:	2b00      	cmp	r3, #0
    24e4:	d007      	beq.n	24f6 <do_conv_numeric+0x986>
    {
        pz += ps1;
    24e6:	69bb      	ldr	r3, [r7, #24]
    24e8:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
    24ec:	4413      	add	r3, r2
    24ee:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
        ps1 = 0;
    24f2:	2300      	movs	r3, #0
    24f4:	61bb      	str	r3, [r7, #24]
    }

    return gen_out( cons, parg,
    24f6:	69b9      	ldr	r1, [r7, #24]
                    ps1,
                    pfx_s, pfx_n,
                    pz,
                    &numBuffer[sizeof(numBuffer) - digitWidth], digitWidth,
    24f8:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
    24fc:	f1c3 0382 	rsb	r3, r3, #130	@ 0x82
    2500:	f107 021c 	add.w	r2, r7, #28
    2504:	4413      	add	r3, r2
    return gen_out( cons, parg,
    2506:	697a      	ldr	r2, [r7, #20]
    2508:	f507 7088 	add.w	r0, r7, #272	@ 0x110
    250c:	f5a0 7088 	sub.w	r0, r0, #272	@ 0x110
    2510:	9204      	str	r2, [sp, #16]
    2512:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
    2516:	9203      	str	r2, [sp, #12]
    2518:	9302      	str	r3, [sp, #8]
    251a:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
    251e:	9301      	str	r3, [sp, #4]
    2520:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
    2524:	9300      	str	r3, [sp, #0]
    2526:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
    252a:	460a      	mov	r2, r1
    252c:	f8d7 1130 	ldr.w	r1, [r7, #304]	@ 0x130
    2530:	6800      	ldr	r0, [r0, #0]
    2532:	f7fe f977 	bl	824 <gen_out>
    2536:	4603      	mov	r3, r0
                    ps2 );
}
    2538:	4618      	mov	r0, r3
    253a:	f507 778a 	add.w	r7, r7, #276	@ 0x114
    253e:	46bd      	mov	sp, r7
    2540:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    2544:	0000b878 	.word	0x0000b878

00002548 <do_conv>:
static int do_conv( T_FormatSpec * pspec,
                    va_list *      ap,
                    char           code,
                    void *      (* cons)(void *, const char *, size_t),
                    void * *       parg )
{
    2548:	b580      	push	{r7, lr}
    254a:	b08c      	sub	sp, #48	@ 0x30
    254c:	af06      	add	r7, sp, #24
    254e:	60f8      	str	r0, [r7, #12]
    2550:	60b9      	str	r1, [r7, #8]
    2552:	603b      	str	r3, [r7, #0]
    2554:	4613      	mov	r3, r2
    2556:	71fb      	strb	r3, [r7, #7]
    unsigned int base = 0;
    2558:	2300      	movs	r3, #0
    255a:	617b      	str	r3, [r7, #20]

    if ( code == 'n' )
    255c:	f997 3007 	ldrsb.w	r3, [r7, #7]
    2560:	2b6e      	cmp	r3, #110	@ 0x6e
    2562:	d105      	bne.n	2570 <do_conv+0x28>
        return do_conv_n( pspec, ap );
    2564:	68b9      	ldr	r1, [r7, #8]
    2566:	68f8      	ldr	r0, [r7, #12]
    2568:	f7ff fa08 	bl	197c <do_conv_n>
    256c:	4603      	mov	r3, r0
    256e:	e0dd      	b.n	272c <do_conv+0x1e4>

    if ( code == '%' )
    2570:	f997 3007 	ldrsb.w	r3, [r7, #7]
    2574:	2b25      	cmp	r3, #37	@ 0x25
    2576:	d111      	bne.n	259c <do_conv+0x54>
        return gen_out( cons, parg, 0, NULL, 0, 0, &code, 1, 0 );
    2578:	2300      	movs	r3, #0
    257a:	9304      	str	r3, [sp, #16]
    257c:	2301      	movs	r3, #1
    257e:	9303      	str	r3, [sp, #12]
    2580:	1dfb      	adds	r3, r7, #7
    2582:	9302      	str	r3, [sp, #8]
    2584:	2300      	movs	r3, #0
    2586:	9301      	str	r3, [sp, #4]
    2588:	2300      	movs	r3, #0
    258a:	9300      	str	r3, [sp, #0]
    258c:	2300      	movs	r3, #0
    258e:	2200      	movs	r2, #0
    2590:	6a39      	ldr	r1, [r7, #32]
    2592:	6838      	ldr	r0, [r7, #0]
    2594:	f7fe f946 	bl	824 <gen_out>
    2598:	4603      	mov	r3, r0
    259a:	e0c7      	b.n	272c <do_conv+0x1e4>

    if ( code == 'c' || code == 'C' )
    259c:	f997 3007 	ldrsb.w	r3, [r7, #7]
    25a0:	2b63      	cmp	r3, #99	@ 0x63
    25a2:	d003      	beq.n	25ac <do_conv+0x64>
    25a4:	f997 3007 	ldrsb.w	r3, [r7, #7]
    25a8:	2b43      	cmp	r3, #67	@ 0x43
    25aa:	d10a      	bne.n	25c2 <do_conv+0x7a>
        return do_conv_c( pspec, ap, code, cons, parg );
    25ac:	f997 2007 	ldrsb.w	r2, [r7, #7]
    25b0:	6a3b      	ldr	r3, [r7, #32]
    25b2:	9300      	str	r3, [sp, #0]
    25b4:	683b      	ldr	r3, [r7, #0]
    25b6:	68b9      	ldr	r1, [r7, #8]
    25b8:	68f8      	ldr	r0, [r7, #12]
    25ba:	f7ff fa3d 	bl	1a38 <do_conv_c>
    25be:	4603      	mov	r3, r0
    25c0:	e0b4      	b.n	272c <do_conv+0x1e4>

    if ( code == 's' )
    25c2:	f997 3007 	ldrsb.w	r3, [r7, #7]
    25c6:	2b73      	cmp	r3, #115	@ 0x73
    25c8:	d10a      	bne.n	25e0 <do_conv+0x98>
#if defined(CONFIG_HAVE_ALT_PTR)
        if ( pspec->flags & FHASH )
            return do_conv_s_alt( pspec, ap, code, cons, parg );
        else
#endif
            return do_conv_s( pspec, ap, code, cons, parg );
    25ca:	f997 2007 	ldrsb.w	r2, [r7, #7]
    25ce:	6a3b      	ldr	r3, [r7, #32]
    25d0:	9300      	str	r3, [sp, #0]
    25d2:	683b      	ldr	r3, [r7, #0]
    25d4:	68b9      	ldr	r1, [r7, #8]
    25d6:	68f8      	ldr	r0, [r7, #12]
    25d8:	f7ff fa80 	bl	1adc <do_conv_s>
    25dc:	4603      	mov	r3, r0
    25de:	e0a5      	b.n	272c <do_conv+0x1e4>
    }

    if ( code == 'e' || code == 'E'
    25e0:	f997 3007 	ldrsb.w	r3, [r7, #7]
    25e4:	2b65      	cmp	r3, #101	@ 0x65
    25e6:	d013      	beq.n	2610 <do_conv+0xc8>
    25e8:	f997 3007 	ldrsb.w	r3, [r7, #7]
    25ec:	2b45      	cmp	r3, #69	@ 0x45
    25ee:	d00f      	beq.n	2610 <do_conv+0xc8>
      || code == 'f' || code == 'F'
    25f0:	f997 3007 	ldrsb.w	r3, [r7, #7]
    25f4:	2b66      	cmp	r3, #102	@ 0x66
    25f6:	d00b      	beq.n	2610 <do_conv+0xc8>
    25f8:	f997 3007 	ldrsb.w	r3, [r7, #7]
    25fc:	2b46      	cmp	r3, #70	@ 0x46
    25fe:	d007      	beq.n	2610 <do_conv+0xc8>
      || code == 'g' || code == 'G' )
    2600:	f997 3007 	ldrsb.w	r3, [r7, #7]
    2604:	2b67      	cmp	r3, #103	@ 0x67
    2606:	d003      	beq.n	2610 <do_conv+0xc8>
    2608:	f997 3007 	ldrsb.w	r3, [r7, #7]
    260c:	2b47      	cmp	r3, #71	@ 0x47
    260e:	d10a      	bne.n	2626 <do_conv+0xde>
        return do_conv_fp( pspec, ap, code, cons, parg );
    2610:	f997 2007 	ldrsb.w	r2, [r7, #7]
    2614:	6a3b      	ldr	r3, [r7, #32]
    2616:	9300      	str	r3, [sp, #0]
    2618:	683b      	ldr	r3, [r7, #0]
    261a:	68b9      	ldr	r1, [r7, #8]
    261c:	68f8      	ldr	r0, [r7, #12]
    261e:	f7ff f82d 	bl	167c <do_conv_fp>
    2622:	4603      	mov	r3, r0
    2624:	e082      	b.n	272c <do_conv+0x1e4>

    if ( code == 'k' )
    2626:	f997 3007 	ldrsb.w	r3, [r7, #7]
    262a:	2b6b      	cmp	r3, #107	@ 0x6b
    262c:	d10a      	bne.n	2644 <do_conv+0xfc>
        return do_conv_k( pspec, ap, code, cons, parg );
    262e:	f997 2007 	ldrsb.w	r2, [r7, #7]
    2632:	6a3b      	ldr	r3, [r7, #32]
    2634:	9300      	str	r3, [sp, #0]
    2636:	683b      	ldr	r3, [r7, #0]
    2638:	68b9      	ldr	r1, [r7, #8]
    263a:	68f8      	ldr	r0, [r7, #12]
    263c:	f7ff f880 	bl	1740 <do_conv_k>
    2640:	4603      	mov	r3, r0
    2642:	e073      	b.n	272c <do_conv+0x1e4>
    /* The '%p' conversion is a meta-conversion, which we convert to a
     *  pre-defined format.  In this case we convert it to "%!#N.NX"
     *  where N is double the machine-word size, as each byte converts into
     *  two characters.
     */
    if ( code == 'p' )
    2644:	f997 3007 	ldrsb.w	r3, [r7, #7]
    2648:	2b70      	cmp	r3, #112	@ 0x70
    264a:	d10d      	bne.n	2668 <do_conv+0x120>
    {
        code          = 'X';
    264c:	2358      	movs	r3, #88	@ 0x58
    264e:	71fb      	strb	r3, [r7, #7]
        pspec->qual   = ( sizeof(int *) > sizeof( int ) ) ? 'l' : 0;
    2650:	68fb      	ldr	r3, [r7, #12]
    2652:	2200      	movs	r2, #0
    2654:	751a      	strb	r2, [r3, #20]
        pspec->flags  = FHASH | FBANG;
    2656:	68fb      	ldr	r3, [r7, #12]
    2658:	2228      	movs	r2, #40	@ 0x28
    265a:	605a      	str	r2, [r3, #4]
        pspec->width  = sizeof( int * ) * 2;
    265c:	68fb      	ldr	r3, [r7, #12]
    265e:	2208      	movs	r2, #8
    2660:	609a      	str	r2, [r3, #8]
        pspec->prec   = sizeof( int * ) * 2;
    2662:	68fb      	ldr	r3, [r7, #12]
    2664:	2208      	movs	r2, #8
    2666:	60da      	str	r2, [r3, #12]

    /* The '%d' and '%i' conversions are both decimal (base 10) and the '#'
     *  flag is ignored.  We set the F_IS_SIGNED internal flag to guide later
     *  processing.
     */
    if ( code == 'd' || code == 'i' || code == 'I' )
    2668:	f997 3007 	ldrsb.w	r3, [r7, #7]
    266c:	2b64      	cmp	r3, #100	@ 0x64
    266e:	d007      	beq.n	2680 <do_conv+0x138>
    2670:	f997 3007 	ldrsb.w	r3, [r7, #7]
    2674:	2b69      	cmp	r3, #105	@ 0x69
    2676:	d003      	beq.n	2680 <do_conv+0x138>
    2678:	f997 3007 	ldrsb.w	r3, [r7, #7]
    267c:	2b49      	cmp	r3, #73	@ 0x49
    267e:	d11c      	bne.n	26ba <do_conv+0x172>
    {
        pspec->flags |= F_IS_SIGNED;
    2680:	68fb      	ldr	r3, [r7, #12]
    2682:	685b      	ldr	r3, [r3, #4]
    2684:	f043 0280 	orr.w	r2, r3, #128	@ 0x80
    2688:	68fb      	ldr	r3, [r7, #12]
    268a:	605a      	str	r2, [r3, #4]
        base = 10;
    268c:	230a      	movs	r3, #10
    268e:	617b      	str	r3, [r7, #20]
        pspec->flags &= ~FHASH;
    2690:	68fb      	ldr	r3, [r7, #12]
    2692:	685b      	ldr	r3, [r3, #4]
    2694:	f023 0208 	bic.w	r2, r3, #8
    2698:	68fb      	ldr	r3, [r7, #12]
    269a:	605a      	str	r2, [r3, #4]

        if ( ( code == 'i' || code == 'I' ) && pspec->base )
    269c:	f997 3007 	ldrsb.w	r3, [r7, #7]
    26a0:	2b69      	cmp	r3, #105	@ 0x69
    26a2:	d003      	beq.n	26ac <do_conv+0x164>
    26a4:	f997 3007 	ldrsb.w	r3, [r7, #7]
    26a8:	2b49      	cmp	r3, #73	@ 0x49
    26aa:	d106      	bne.n	26ba <do_conv+0x172>
    26ac:	68fb      	ldr	r3, [r7, #12]
    26ae:	691b      	ldr	r3, [r3, #16]
    26b0:	2b00      	cmp	r3, #0
    26b2:	d002      	beq.n	26ba <do_conv+0x172>
           base = pspec->base;
    26b4:	68fb      	ldr	r3, [r7, #12]
    26b6:	691b      	ldr	r3, [r3, #16]
    26b8:	617b      	str	r3, [r7, #20]
    }

    if ( code == 'x' || code == 'X' )
    26ba:	f997 3007 	ldrsb.w	r3, [r7, #7]
    26be:	2b78      	cmp	r3, #120	@ 0x78
    26c0:	d003      	beq.n	26ca <do_conv+0x182>
    26c2:	f997 3007 	ldrsb.w	r3, [r7, #7]
    26c6:	2b58      	cmp	r3, #88	@ 0x58
    26c8:	d101      	bne.n	26ce <do_conv+0x186>
        base = 16;
    26ca:	2310      	movs	r3, #16
    26cc:	617b      	str	r3, [r7, #20]

    if ( code == 'u' || code == 'U' )
    26ce:	f997 3007 	ldrsb.w	r3, [r7, #7]
    26d2:	2b75      	cmp	r3, #117	@ 0x75
    26d4:	d003      	beq.n	26de <do_conv+0x196>
    26d6:	f997 3007 	ldrsb.w	r3, [r7, #7]
    26da:	2b55      	cmp	r3, #85	@ 0x55
    26dc:	d108      	bne.n	26f0 <do_conv+0x1a8>
       base = pspec->base ? pspec->base : 10;
    26de:	68fb      	ldr	r3, [r7, #12]
    26e0:	691b      	ldr	r3, [r3, #16]
    26e2:	2b00      	cmp	r3, #0
    26e4:	d002      	beq.n	26ec <do_conv+0x1a4>
    26e6:	68fb      	ldr	r3, [r7, #12]
    26e8:	691b      	ldr	r3, [r3, #16]
    26ea:	e000      	b.n	26ee <do_conv+0x1a6>
    26ec:	230a      	movs	r3, #10
    26ee:	617b      	str	r3, [r7, #20]

    if ( code == 'o' )
    26f0:	f997 3007 	ldrsb.w	r3, [r7, #7]
    26f4:	2b6f      	cmp	r3, #111	@ 0x6f
    26f6:	d101      	bne.n	26fc <do_conv+0x1b4>
        base = 8;
    26f8:	2308      	movs	r3, #8
    26fa:	617b      	str	r3, [r7, #20]

    if ( code == 'b' )
    26fc:	f997 3007 	ldrsb.w	r3, [r7, #7]
    2700:	2b62      	cmp	r3, #98	@ 0x62
    2702:	d101      	bne.n	2708 <do_conv+0x1c0>
        base = 2;
    2704:	2302      	movs	r3, #2
    2706:	617b      	str	r3, [r7, #20]

    if ( base > 1 )
    2708:	697b      	ldr	r3, [r7, #20]
    270a:	2b01      	cmp	r3, #1
    270c:	d90c      	bls.n	2728 <do_conv+0x1e0>
        return do_conv_numeric( pspec, ap, code, cons, parg, base );
    270e:	f997 2007 	ldrsb.w	r2, [r7, #7]
    2712:	697b      	ldr	r3, [r7, #20]
    2714:	9301      	str	r3, [sp, #4]
    2716:	6a3b      	ldr	r3, [r7, #32]
    2718:	9300      	str	r3, [sp, #0]
    271a:	683b      	ldr	r3, [r7, #0]
    271c:	68b9      	ldr	r1, [r7, #8]
    271e:	68f8      	ldr	r0, [r7, #12]
    2720:	f7ff fa26 	bl	1b70 <do_conv_numeric>
    2724:	4603      	mov	r3, r0
    2726:	e001      	b.n	272c <do_conv+0x1e4>

    return EXBADFORMAT;
    2728:	f04f 33ff 	mov.w	r3, #4294967295
}
    272c:	4618      	mov	r0, r3
    272e:	3718      	adds	r7, #24
    2730:	46bd      	mov	sp, r7
    2732:	bd80      	pop	{r7, pc}

00002734 <format>:
**/
int format( void *    (* cons) (void *, const char * , size_t),
            void *       arg,
            const char * fmt,
            va_list      apx )
{
    2734:	b580      	push	{r7, lr}
    2736:	b09c      	sub	sp, #112	@ 0x70
    2738:	af02      	add	r7, sp, #8
    273a:	60f8      	str	r0, [r7, #12]
    273c:	60b9      	str	r1, [r7, #8]
    273e:	607a      	str	r2, [r7, #4]
    2740:	603b      	str	r3, [r7, #0]
    T_FormatSpec fspec;
#if defined(CONFIG_HAVE_ALT_PTR)
    enum ptr_mode  mode = NORMAL_PTR;
#endif
    char           c;
    const void   * ptr = (const void *)fmt;
    2742:	687b      	ldr	r3, [r7, #4]
    2744:	663b      	str	r3, [r7, #96]	@ 0x60
    va_list        ap;
    
    /* Setup varargs -- must va_end( ap ) before exit !! */
    va_copy( ap, apx );
    2746:	683b      	ldr	r3, [r7, #0]
    2748:	613b      	str	r3, [r7, #16]

    if ( fmt == NULL )
    274a:	687b      	ldr	r3, [r7, #4]
    274c:	2b00      	cmp	r3, #0
    274e:	f000 828c 	beq.w	2c6a <format+0x536>
        goto exit_badformat;

    fspec.nChars = 0;
    2752:	2300      	movs	r3, #0
    2754:	617b      	str	r3, [r7, #20]

    while ( ( c = READ_CHAR( mode, ptr ) ) )
    2756:	e27d      	b.n	2c54 <format+0x520>
#if defined(CONFIG_HAVE_ALT_PTR)
        if ( mode == NORMAL_PTR )
#endif
        {
            unsigned int n;
            const char *s = (const char *)ptr;
    2758:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    275a:	65fb      	str	r3, [r7, #92]	@ 0x5c

            /* For normal RAM-based strings we scan over as many input chars
             *  as we can to minimise calls to emit().
             */
            for ( ; *s && *s != '%'; s++ )
    275c:	e002      	b.n	2764 <format+0x30>
    275e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
    2760:	3301      	adds	r3, #1
    2762:	65fb      	str	r3, [r7, #92]	@ 0x5c
    2764:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
    2766:	f993 3000 	ldrsb.w	r3, [r3]
    276a:	2b00      	cmp	r3, #0
    276c:	d004      	beq.n	2778 <format+0x44>
    276e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
    2770:	f993 3000 	ldrsb.w	r3, [r3]
    2774:	2b25      	cmp	r3, #37	@ 0x25
    2776:	d1f2      	bne.n	275e <format+0x2a>
                ;

            n = s - (const char *)ptr;
    2778:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
    277a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    277c:	1ad3      	subs	r3, r2, r3
    277e:	64fb      	str	r3, [r7, #76]	@ 0x4c
            if ( n > 0 )
    2780:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
    2782:	2b00      	cmp	r3, #0
    2784:	d00e      	beq.n	27a4 <format+0x70>
            {
                if ( emit( (const char *)ptr, n, cons, &arg ) < 0 )
    2786:	f107 0308 	add.w	r3, r7, #8
    278a:	68fa      	ldr	r2, [r7, #12]
    278c:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
    278e:	6e38      	ldr	r0, [r7, #96]	@ 0x60
    2790:	f7fe f806 	bl	7a0 <emit>
    2794:	4603      	mov	r3, r0
    2796:	2b00      	cmp	r3, #0
    2798:	f2c0 8269 	blt.w	2c6e <format+0x53a>
                    goto exit_badformat;

                fspec.nChars += n;
    279c:	697a      	ldr	r2, [r7, #20]
    279e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
    27a0:	4413      	add	r3, r2
    27a2:	617b      	str	r3, [r7, #20]
            }
            ptr = (const void *)s;
    27a4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
    27a6:	663b      	str	r3, [r7, #96]	@ 0x60
                ptr++;
            }
        }
#endif

        if ( READ_CHAR( mode, ptr ) )
    27a8:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    27aa:	f993 3000 	ldrsb.w	r3, [r3]
    27ae:	2b00      	cmp	r3, #0
    27b0:	f000 8250 	beq.w	2c54 <format+0x520>
            int nn;
            static const char fchar[] = {" +-#0!^"};
            static const unsigned int fbit[] = {
                FSPACE, FPLUS, FMINUS, FHASH, FZERO, FBANG, FCARET, 0};

            INC_VOID_PTR(ptr);    /* skip the % sign */
    27b4:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    27b6:	3301      	adds	r3, #1
    27b8:	663b      	str	r3, [r7, #96]	@ 0x60

            /* process conversion flags */
            for ( fspec.flags = 0;
    27ba:	2300      	movs	r3, #0
    27bc:	61bb      	str	r3, [r7, #24]
    27be:	e00b      	b.n	27d8 <format+0xa4>
                  (c = READ_CHAR( mode, ptr )) && (t = STRCHR(fchar, c)) != NULL;
                  INC_VOID_PTR(ptr) )
            {
                fspec.flags |= fbit[t - fchar];
    27c0:	69ba      	ldr	r2, [r7, #24]
    27c2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
    27c4:	49a6      	ldr	r1, [pc, #664]	@ (2a60 <format+0x32c>)
    27c6:	1a5b      	subs	r3, r3, r1
    27c8:	49a6      	ldr	r1, [pc, #664]	@ (2a64 <format+0x330>)
    27ca:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
    27ce:	4313      	orrs	r3, r2
    27d0:	61bb      	str	r3, [r7, #24]
                  INC_VOID_PTR(ptr) )
    27d2:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    27d4:	3301      	adds	r3, #1
    27d6:	663b      	str	r3, [r7, #96]	@ 0x60
                  (c = READ_CHAR( mode, ptr )) && (t = STRCHR(fchar, c)) != NULL;
    27d8:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    27da:	781b      	ldrb	r3, [r3, #0]
    27dc:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
    27e0:	f997 3067 	ldrsb.w	r3, [r7, #103]	@ 0x67
    27e4:	2b00      	cmp	r3, #0
    27e6:	d009      	beq.n	27fc <format+0xc8>
    27e8:	f997 3067 	ldrsb.w	r3, [r7, #103]	@ 0x67
    27ec:	4619      	mov	r1, r3
    27ee:	489c      	ldr	r0, [pc, #624]	@ (2a60 <format+0x32c>)
    27f0:	f004 fd54 	bl	729c <strchr>
    27f4:	64b8      	str	r0, [r7, #72]	@ 0x48
    27f6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
    27f8:	2b00      	cmp	r3, #0
    27fa:	d1e1      	bne.n	27c0 <format+0x8c>
            }

            /* process width */
            if ( READ_CHAR( mode, ptr ) == '*' )
    27fc:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    27fe:	f993 3000 	ldrsb.w	r3, [r3]
    2802:	2b2a      	cmp	r3, #42	@ 0x2a
    2804:	d112      	bne.n	282c <format+0xf8>
            {
                fspec.width = va_arg( ap, int );
    2806:	693b      	ldr	r3, [r7, #16]
    2808:	1d1a      	adds	r2, r3, #4
    280a:	613a      	str	r2, [r7, #16]
    280c:	681b      	ldr	r3, [r3, #0]
    280e:	61fb      	str	r3, [r7, #28]
                if ( fspec.width < 0 )
    2810:	69fb      	ldr	r3, [r7, #28]
    2812:	2b00      	cmp	r3, #0
    2814:	da06      	bge.n	2824 <format+0xf0>
                {
                    fspec.width = -fspec.width;
    2816:	69fb      	ldr	r3, [r7, #28]
    2818:	425b      	negs	r3, r3
    281a:	61fb      	str	r3, [r7, #28]
                    fspec.flags |= FMINUS;
    281c:	69bb      	ldr	r3, [r7, #24]
    281e:	f043 0304 	orr.w	r3, r3, #4
    2822:	61bb      	str	r3, [r7, #24]
                }
                INC_VOID_PTR(ptr);
    2824:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    2826:	3301      	adds	r3, #1
    2828:	663b      	str	r3, [r7, #96]	@ 0x60
    282a:	e028      	b.n	287e <format+0x14a>
            }
            else
            {
                for ( fspec.width = 0;
    282c:	2300      	movs	r3, #0
    282e:	61fb      	str	r3, [r7, #28]
    2830:	e00d      	b.n	284e <format+0x11a>
                      ( c = READ_CHAR( mode, ptr ) ) && ISDIGIT( c ) && fspec.width < MAXWIDTH;
                      INC_VOID_PTR(ptr) )
                {
                    fspec.width = fspec.width * 10 + c - '0';
    2832:	69fa      	ldr	r2, [r7, #28]
    2834:	4613      	mov	r3, r2
    2836:	009b      	lsls	r3, r3, #2
    2838:	4413      	add	r3, r2
    283a:	005b      	lsls	r3, r3, #1
    283c:	461a      	mov	r2, r3
    283e:	f997 3067 	ldrsb.w	r3, [r7, #103]	@ 0x67
    2842:	4413      	add	r3, r2
    2844:	3b30      	subs	r3, #48	@ 0x30
    2846:	61fb      	str	r3, [r7, #28]
                      INC_VOID_PTR(ptr) )
    2848:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    284a:	3301      	adds	r3, #1
    284c:	663b      	str	r3, [r7, #96]	@ 0x60
                      ( c = READ_CHAR( mode, ptr ) ) && ISDIGIT( c ) && fspec.width < MAXWIDTH;
    284e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    2850:	781b      	ldrb	r3, [r3, #0]
    2852:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
    2856:	f997 3067 	ldrsb.w	r3, [r7, #103]	@ 0x67
    285a:	2b00      	cmp	r3, #0
    285c:	d00f      	beq.n	287e <format+0x14a>
    285e:	f997 3067 	ldrsb.w	r3, [r7, #103]	@ 0x67
    2862:	3301      	adds	r3, #1
    2864:	4a80      	ldr	r2, [pc, #512]	@ (2a68 <format+0x334>)
    2866:	4413      	add	r3, r2
    2868:	f993 3000 	ldrsb.w	r3, [r3]
    286c:	b2db      	uxtb	r3, r3
    286e:	f003 0304 	and.w	r3, r3, #4
    2872:	2b00      	cmp	r3, #0
    2874:	d003      	beq.n	287e <format+0x14a>
    2876:	69fb      	ldr	r3, [r7, #28]
    2878:	f5b3 7ffa 	cmp.w	r3, #500	@ 0x1f4
    287c:	dbd9      	blt.n	2832 <format+0xfe>
                }
            }

            if ( fspec.width > MAXWIDTH )
    287e:	69fb      	ldr	r3, [r7, #28]
    2880:	f5b3 7ffa 	cmp.w	r3, #500	@ 0x1f4
    2884:	f300 81f5 	bgt.w	2c72 <format+0x53e>
                goto exit_badformat;

            /* process precision */
            if ( READ_CHAR( mode, ptr ) != '.' )
    2888:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    288a:	f993 3000 	ldrsb.w	r3, [r3]
    288e:	2b2e      	cmp	r3, #46	@ 0x2e
    2890:	d003      	beq.n	289a <format+0x166>
                fspec.prec = -1; /* precision is missing */
    2892:	f04f 33ff 	mov.w	r3, #4294967295
    2896:	623b      	str	r3, [r7, #32]
    2898:	e043      	b.n	2922 <format+0x1ee>
            else if ( READ_CHAR( mode, INC_VOID_PTR(ptr) ) == '*' )
    289a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    289c:	3301      	adds	r3, #1
    289e:	663b      	str	r3, [r7, #96]	@ 0x60
    28a0:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    28a2:	f993 3000 	ldrsb.w	r3, [r3]
    28a6:	2b2a      	cmp	r3, #42	@ 0x2a
    28a8:	d10d      	bne.n	28c6 <format+0x192>
            {
                fspec.prec = va_arg( ap, int );
    28aa:	693b      	ldr	r3, [r7, #16]
    28ac:	1d1a      	adds	r2, r3, #4
    28ae:	613a      	str	r2, [r7, #16]
    28b0:	681b      	ldr	r3, [r3, #0]
    28b2:	623b      	str	r3, [r7, #32]

                if ( fspec.prec > MAXPREC )
    28b4:	6a3b      	ldr	r3, [r7, #32]
    28b6:	f5b3 7ffa 	cmp.w	r3, #500	@ 0x1f4
    28ba:	f300 81dc 	bgt.w	2c76 <format+0x542>
                    goto exit_badformat;

                INC_VOID_PTR(ptr);
    28be:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    28c0:	3301      	adds	r3, #1
    28c2:	663b      	str	r3, [r7, #96]	@ 0x60
    28c4:	e02d      	b.n	2922 <format+0x1ee>
            }
            else
            {
                for ( fspec.prec = 0;
    28c6:	2300      	movs	r3, #0
    28c8:	623b      	str	r3, [r7, #32]
    28ca:	e00d      	b.n	28e8 <format+0x1b4>
                      ( c = READ_CHAR( mode, ptr ) ) && ISDIGIT( c ) && fspec.prec < MAXPREC;
                      INC_VOID_PTR(ptr) )
                {
                    fspec.prec = fspec.prec * 10 + c - '0';
    28cc:	6a3a      	ldr	r2, [r7, #32]
    28ce:	4613      	mov	r3, r2
    28d0:	009b      	lsls	r3, r3, #2
    28d2:	4413      	add	r3, r2
    28d4:	005b      	lsls	r3, r3, #1
    28d6:	461a      	mov	r2, r3
    28d8:	f997 3067 	ldrsb.w	r3, [r7, #103]	@ 0x67
    28dc:	4413      	add	r3, r2
    28de:	3b30      	subs	r3, #48	@ 0x30
    28e0:	623b      	str	r3, [r7, #32]
                      INC_VOID_PTR(ptr) )
    28e2:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    28e4:	3301      	adds	r3, #1
    28e6:	663b      	str	r3, [r7, #96]	@ 0x60
                      ( c = READ_CHAR( mode, ptr ) ) && ISDIGIT( c ) && fspec.prec < MAXPREC;
    28e8:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    28ea:	781b      	ldrb	r3, [r3, #0]
    28ec:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
    28f0:	f997 3067 	ldrsb.w	r3, [r7, #103]	@ 0x67
    28f4:	2b00      	cmp	r3, #0
    28f6:	d00f      	beq.n	2918 <format+0x1e4>
    28f8:	f997 3067 	ldrsb.w	r3, [r7, #103]	@ 0x67
    28fc:	3301      	adds	r3, #1
    28fe:	4a5a      	ldr	r2, [pc, #360]	@ (2a68 <format+0x334>)
    2900:	4413      	add	r3, r2
    2902:	f993 3000 	ldrsb.w	r3, [r3]
    2906:	b2db      	uxtb	r3, r3
    2908:	f003 0304 	and.w	r3, r3, #4
    290c:	2b00      	cmp	r3, #0
    290e:	d003      	beq.n	2918 <format+0x1e4>
    2910:	6a3b      	ldr	r3, [r7, #32]
    2912:	f5b3 7ffa 	cmp.w	r3, #500	@ 0x1f4
    2916:	dbd9      	blt.n	28cc <format+0x198>
                }
                if ( fspec.prec > MAXPREC )
    2918:	6a3b      	ldr	r3, [r7, #32]
    291a:	f5b3 7ffa 	cmp.w	r3, #500	@ 0x1f4
    291e:	f300 81ac 	bgt.w	2c7a <format+0x546>
                    goto exit_badformat;
            }

            /* process base */
            if ( READ_CHAR( mode, ptr ) != ':' )
    2922:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    2924:	f993 3000 	ldrsb.w	r3, [r3]
    2928:	2b3a      	cmp	r3, #58	@ 0x3a
    292a:	d002      	beq.n	2932 <format+0x1fe>
                fspec.base = 0;
    292c:	2300      	movs	r3, #0
    292e:	627b      	str	r3, [r7, #36]	@ 0x24
    2930:	e048      	b.n	29c4 <format+0x290>
            else if ( READ_CHAR( mode, INC_VOID_PTR(ptr) ) == '*' )
    2932:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    2934:	3301      	adds	r3, #1
    2936:	663b      	str	r3, [r7, #96]	@ 0x60
    2938:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    293a:	f993 3000 	ldrsb.w	r3, [r3]
    293e:	2b2a      	cmp	r3, #42	@ 0x2a
    2940:	d114      	bne.n	296c <format+0x238>
            {
                int v = va_arg( ap, int );
    2942:	693b      	ldr	r3, [r7, #16]
    2944:	1d1a      	adds	r2, r3, #4
    2946:	613a      	str	r2, [r7, #16]
    2948:	681b      	ldr	r3, [r3, #0]
    294a:	647b      	str	r3, [r7, #68]	@ 0x44

                if ( v < 0 )
    294c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
    294e:	2b00      	cmp	r3, #0
    2950:	da02      	bge.n	2958 <format+0x224>
                    fspec.base = 0;
    2952:	2300      	movs	r3, #0
    2954:	627b      	str	r3, [r7, #36]	@ 0x24
    2956:	e005      	b.n	2964 <format+0x230>
                else if ( v > MAXBASE )
    2958:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
    295a:	2b24      	cmp	r3, #36	@ 0x24
    295c:	f300 818f 	bgt.w	2c7e <format+0x54a>
                    goto exit_badformat;
                else
                    fspec.base = (unsigned int)v;
    2960:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
    2962:	627b      	str	r3, [r7, #36]	@ 0x24

                INC_VOID_PTR(ptr);
    2964:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    2966:	3301      	adds	r3, #1
    2968:	663b      	str	r3, [r7, #96]	@ 0x60
    296a:	e02b      	b.n	29c4 <format+0x290>
            }
            else
            {
                for ( fspec.base = 0;
    296c:	2300      	movs	r3, #0
    296e:	627b      	str	r3, [r7, #36]	@ 0x24
    2970:	e00d      	b.n	298e <format+0x25a>
                      ( c = READ_CHAR( mode, ptr ) ) && ISDIGIT( c ) && fspec.base < MAXBASE;
                      INC_VOID_PTR(ptr) )
                {
                    fspec.base = fspec.base * 10 + c - '0';
    2972:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
    2974:	4613      	mov	r3, r2
    2976:	009b      	lsls	r3, r3, #2
    2978:	4413      	add	r3, r2
    297a:	005b      	lsls	r3, r3, #1
    297c:	461a      	mov	r2, r3
    297e:	f997 3067 	ldrsb.w	r3, [r7, #103]	@ 0x67
    2982:	4413      	add	r3, r2
    2984:	3b30      	subs	r3, #48	@ 0x30
    2986:	627b      	str	r3, [r7, #36]	@ 0x24
                      INC_VOID_PTR(ptr) )
    2988:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    298a:	3301      	adds	r3, #1
    298c:	663b      	str	r3, [r7, #96]	@ 0x60
                      ( c = READ_CHAR( mode, ptr ) ) && ISDIGIT( c ) && fspec.base < MAXBASE;
    298e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    2990:	781b      	ldrb	r3, [r3, #0]
    2992:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
    2996:	f997 3067 	ldrsb.w	r3, [r7, #103]	@ 0x67
    299a:	2b00      	cmp	r3, #0
    299c:	d00e      	beq.n	29bc <format+0x288>
    299e:	f997 3067 	ldrsb.w	r3, [r7, #103]	@ 0x67
    29a2:	3301      	adds	r3, #1
    29a4:	4a30      	ldr	r2, [pc, #192]	@ (2a68 <format+0x334>)
    29a6:	4413      	add	r3, r2
    29a8:	f993 3000 	ldrsb.w	r3, [r3]
    29ac:	b2db      	uxtb	r3, r3
    29ae:	f003 0304 	and.w	r3, r3, #4
    29b2:	2b00      	cmp	r3, #0
    29b4:	d002      	beq.n	29bc <format+0x288>
    29b6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    29b8:	2b23      	cmp	r3, #35	@ 0x23
    29ba:	ddda      	ble.n	2972 <format+0x23e>
                }
                if ( fspec.base > MAXBASE )
    29bc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    29be:	2b24      	cmp	r3, #36	@ 0x24
    29c0:	f300 815f 	bgt.w	2c82 <format+0x54e>
                    goto exit_badformat; 
            }

            /* default fixed-point format is 16p16 */
            fspec.xp.w_int  = 16;
    29c4:	2310      	movs	r3, #16
    29c6:	637b      	str	r3, [r7, #52]	@ 0x34
            fspec.xp.w_frac = 16;
    29c8:	2310      	movs	r3, #16
    29ca:	63bb      	str	r3, [r7, #56]	@ 0x38

            /* test for grouping qualifier */
            fspec.grouping.len = 0;
    29cc:	2300      	movs	r3, #0
    29ce:	633b      	str	r3, [r7, #48]	@ 0x30
            fspec.grouping.ptr = NULL;
    29d0:	2300      	movs	r3, #0
    29d2:	62fb      	str	r3, [r7, #44]	@ 0x2c
#if defined(CONFIG_HAVE_ALT_PTR)
            fspec.grouping.mode = NORMAL_PTR;
#endif
            c = READ_CHAR( mode, ptr );
    29d4:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    29d6:	781b      	ldrb	r3, [r3, #0]
    29d8:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
            if ( c == '[' )
    29dc:	f997 3067 	ldrsb.w	r3, [r7, #103]	@ 0x67
    29e0:	2b5b      	cmp	r3, #91	@ 0x5b
    29e2:	d124      	bne.n	2a2e <format+0x2fa>
            {
                size_t gplen = 0;
    29e4:	2300      	movs	r3, #0
    29e6:	65bb      	str	r3, [r7, #88]	@ 0x58

                /* skip over opening brace */
                INC_VOID_PTR(ptr);
    29e8:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    29ea:	3301      	adds	r3, #1
    29ec:	663b      	str	r3, [r7, #96]	@ 0x60

                /* set the pointer mode */
#if defined(CONFIG_HAVE_ALT_PTR)
                fspec.grouping.mode = mode;
#endif
                fspec.grouping.ptr  = ptr;
    29ee:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    29f0:	62fb      	str	r3, [r7, #44]	@ 0x2c

                /* scan to end of grouping string */
                while ( ( c = READ_CHAR( mode, ptr ) ) && c != ']' )
    29f2:	e005      	b.n	2a00 <format+0x2cc>
                {
                    INC_VOID_PTR(ptr);
    29f4:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    29f6:	3301      	adds	r3, #1
    29f8:	663b      	str	r3, [r7, #96]	@ 0x60
                    ++gplen;
    29fa:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
    29fc:	3301      	adds	r3, #1
    29fe:	65bb      	str	r3, [r7, #88]	@ 0x58
                while ( ( c = READ_CHAR( mode, ptr ) ) && c != ']' )
    2a00:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    2a02:	781b      	ldrb	r3, [r3, #0]
    2a04:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
    2a08:	f997 3067 	ldrsb.w	r3, [r7, #103]	@ 0x67
    2a0c:	2b00      	cmp	r3, #0
    2a0e:	d003      	beq.n	2a18 <format+0x2e4>
    2a10:	f997 3067 	ldrsb.w	r3, [r7, #103]	@ 0x67
    2a14:	2b5d      	cmp	r3, #93	@ 0x5d
    2a16:	d1ed      	bne.n	29f4 <format+0x2c0>
                }
                if ( c == '\0' )
    2a18:	f997 3067 	ldrsb.w	r3, [r7, #103]	@ 0x67
    2a1c:	2b00      	cmp	r3, #0
    2a1e:	f000 8132 	beq.w	2c86 <format+0x552>
                    goto exit_badformat;

                /* skip over closing brace */
                INC_VOID_PTR(ptr);
    2a22:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    2a24:	3301      	adds	r3, #1
    2a26:	663b      	str	r3, [r7, #96]	@ 0x60

                /* record the grouping spec length */
                fspec.grouping.len = gplen;
    2a28:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
    2a2a:	633b      	str	r3, [r7, #48]	@ 0x30
    2a2c:	e09c      	b.n	2b68 <format+0x434>
            }
            else if ( c == '{' ) /* fixed-point specifier */
    2a2e:	f997 3067 	ldrsb.w	r3, [r7, #103]	@ 0x67
    2a32:	2b7b      	cmp	r3, #123	@ 0x7b
    2a34:	f040 8098 	bne.w	2b68 <format+0x434>
            {
                size_t p, q;

                /* skip over opening brace */
                INC_VOID_PTR( ptr );
    2a38:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    2a3a:	3301      	adds	r3, #1
    2a3c:	663b      	str	r3, [r7, #96]	@ 0x60

                /* get integer width */
                if ( READ_CHAR( mode, ptr ) == '*' )
    2a3e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    2a40:	f993 3000 	ldrsb.w	r3, [r3]
    2a44:	2b2a      	cmp	r3, #42	@ 0x2a
    2a46:	d108      	bne.n	2a5a <format+0x326>
                {
                    p = va_arg( ap, int );
    2a48:	693b      	ldr	r3, [r7, #16]
    2a4a:	1d1a      	adds	r2, r3, #4
    2a4c:	613a      	str	r2, [r7, #16]
    2a4e:	681b      	ldr	r3, [r3, #0]
    2a50:	657b      	str	r3, [r7, #84]	@ 0x54
                    p = MAX( 0, p );

                    INC_VOID_PTR( ptr );
    2a52:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    2a54:	3301      	adds	r3, #1
    2a56:	663b      	str	r3, [r7, #96]	@ 0x60
    2a58:	e02d      	b.n	2ab6 <format+0x382>
                }
                else
                {
                    for ( p = 0;
    2a5a:	2300      	movs	r3, #0
    2a5c:	657b      	str	r3, [r7, #84]	@ 0x54
    2a5e:	e013      	b.n	2a88 <format+0x354>
    2a60:	000096a8 	.word	0x000096a8
    2a64:	000096b0 	.word	0x000096b0
    2a68:	0000b878 	.word	0x0000b878
                         ( c = READ_CHAR( mode, ptr ) ) && ISDIGIT( c ) && p < MAX_XP_INT;
                         INC_VOID_PTR( ptr ) )
                    {
                        p = p * 10 + c - '0';
    2a6c:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
    2a6e:	4613      	mov	r3, r2
    2a70:	009b      	lsls	r3, r3, #2
    2a72:	4413      	add	r3, r2
    2a74:	005b      	lsls	r3, r3, #1
    2a76:	461a      	mov	r2, r3
    2a78:	f997 3067 	ldrsb.w	r3, [r7, #103]	@ 0x67
    2a7c:	4413      	add	r3, r2
    2a7e:	3b30      	subs	r3, #48	@ 0x30
    2a80:	657b      	str	r3, [r7, #84]	@ 0x54
                         INC_VOID_PTR( ptr ) )
    2a82:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    2a84:	3301      	adds	r3, #1
    2a86:	663b      	str	r3, [r7, #96]	@ 0x60
                         ( c = READ_CHAR( mode, ptr ) ) && ISDIGIT( c ) && p < MAX_XP_INT;
    2a88:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    2a8a:	781b      	ldrb	r3, [r3, #0]
    2a8c:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
    2a90:	f997 3067 	ldrsb.w	r3, [r7, #103]	@ 0x67
    2a94:	2b00      	cmp	r3, #0
    2a96:	d00e      	beq.n	2ab6 <format+0x382>
    2a98:	f997 3067 	ldrsb.w	r3, [r7, #103]	@ 0x67
    2a9c:	3301      	adds	r3, #1
    2a9e:	4a84      	ldr	r2, [pc, #528]	@ (2cb0 <format+0x57c>)
    2aa0:	4413      	add	r3, r2
    2aa2:	f993 3000 	ldrsb.w	r3, [r3]
    2aa6:	b2db      	uxtb	r3, r3
    2aa8:	f003 0304 	and.w	r3, r3, #4
    2aac:	2b00      	cmp	r3, #0
    2aae:	d002      	beq.n	2ab6 <format+0x382>
    2ab0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
    2ab2:	2b1f      	cmp	r3, #31
    2ab4:	d9da      	bls.n	2a6c <format+0x338>
                    }
                }

                if ( p > MAX_XP_INT )
    2ab6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
    2ab8:	2b20      	cmp	r3, #32
    2aba:	f200 80e6 	bhi.w	2c8a <format+0x556>
                    goto exit_badformat;

                /* get fractional width */
                if ( READ_CHAR( mode, ptr ) != '.' )
    2abe:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    2ac0:	f993 3000 	ldrsb.w	r3, [r3]
    2ac4:	2b2e      	cmp	r3, #46	@ 0x2e
    2ac6:	f040 80e2 	bne.w	2c8e <format+0x55a>
                    goto exit_badformat; /* fractional width is missing */
                else if ( READ_CHAR( mode, INC_VOID_PTR(ptr) ) == '*' )
    2aca:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    2acc:	3301      	adds	r3, #1
    2ace:	663b      	str	r3, [r7, #96]	@ 0x60
    2ad0:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    2ad2:	f993 3000 	ldrsb.w	r3, [r3]
    2ad6:	2b2a      	cmp	r3, #42	@ 0x2a
    2ad8:	d108      	bne.n	2aec <format+0x3b8>
                {
                    q = va_arg( ap, int );
    2ada:	693b      	ldr	r3, [r7, #16]
    2adc:	1d1a      	adds	r2, r3, #4
    2ade:	613a      	str	r2, [r7, #16]
    2ae0:	681b      	ldr	r3, [r3, #0]
    2ae2:	653b      	str	r3, [r7, #80]	@ 0x50
                    q = MAX( 0, q );

                    INC_VOID_PTR( ptr );
    2ae4:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    2ae6:	3301      	adds	r3, #1
    2ae8:	663b      	str	r3, [r7, #96]	@ 0x60
    2aea:	e027      	b.n	2b3c <format+0x408>
                }
                else
                {
                    for ( q = 0;
    2aec:	2300      	movs	r3, #0
    2aee:	653b      	str	r3, [r7, #80]	@ 0x50
    2af0:	e00d      	b.n	2b0e <format+0x3da>
                         ( c = READ_CHAR( mode, ptr ) ) && ISDIGIT( c ) && q < MAX_XP_FRAC;
                         INC_VOID_PTR( ptr ) )
                    {
                        q = q * 10 + c - '0';
    2af2:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
    2af4:	4613      	mov	r3, r2
    2af6:	009b      	lsls	r3, r3, #2
    2af8:	4413      	add	r3, r2
    2afa:	005b      	lsls	r3, r3, #1
    2afc:	461a      	mov	r2, r3
    2afe:	f997 3067 	ldrsb.w	r3, [r7, #103]	@ 0x67
    2b02:	4413      	add	r3, r2
    2b04:	3b30      	subs	r3, #48	@ 0x30
    2b06:	653b      	str	r3, [r7, #80]	@ 0x50
                         INC_VOID_PTR( ptr ) )
    2b08:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    2b0a:	3301      	adds	r3, #1
    2b0c:	663b      	str	r3, [r7, #96]	@ 0x60
                         ( c = READ_CHAR( mode, ptr ) ) && ISDIGIT( c ) && q < MAX_XP_FRAC;
    2b0e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    2b10:	781b      	ldrb	r3, [r3, #0]
    2b12:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
    2b16:	f997 3067 	ldrsb.w	r3, [r7, #103]	@ 0x67
    2b1a:	2b00      	cmp	r3, #0
    2b1c:	d00e      	beq.n	2b3c <format+0x408>
    2b1e:	f997 3067 	ldrsb.w	r3, [r7, #103]	@ 0x67
    2b22:	3301      	adds	r3, #1
    2b24:	4a62      	ldr	r2, [pc, #392]	@ (2cb0 <format+0x57c>)
    2b26:	4413      	add	r3, r2
    2b28:	f993 3000 	ldrsb.w	r3, [r3]
    2b2c:	b2db      	uxtb	r3, r3
    2b2e:	f003 0304 	and.w	r3, r3, #4
    2b32:	2b00      	cmp	r3, #0
    2b34:	d002      	beq.n	2b3c <format+0x408>
    2b36:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
    2b38:	2b1f      	cmp	r3, #31
    2b3a:	d9da      	bls.n	2af2 <format+0x3be>
                    }
                }

                if ( c == '\0' )
    2b3c:	f997 3067 	ldrsb.w	r3, [r7, #103]	@ 0x67
    2b40:	2b00      	cmp	r3, #0
    2b42:	f000 80a6 	beq.w	2c92 <format+0x55e>
                    goto exit_badformat;

                /* skip over closing brace */
                INC_VOID_PTR( ptr );
    2b46:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    2b48:	3301      	adds	r3, #1
    2b4a:	663b      	str	r3, [r7, #96]	@ 0x60

                if ( q > MAX_XP_FRAC )
    2b4c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
    2b4e:	2b20      	cmp	r3, #32
    2b50:	f200 80a1 	bhi.w	2c96 <format+0x562>
                    goto exit_badformat;

                if ( p + q >= MAX_XP_WIDTH )
    2b54:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
    2b56:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
    2b58:	4413      	add	r3, r2
    2b5a:	2b1f      	cmp	r3, #31
    2b5c:	f200 809d 	bhi.w	2c9a <format+0x566>
                    goto exit_badformat;

                fspec.xp.w_int  = p;
    2b60:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
    2b62:	637b      	str	r3, [r7, #52]	@ 0x34
                fspec.xp.w_frac = q;
    2b64:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
    2b66:	63bb      	str	r3, [r7, #56]	@ 0x38
            }

            /* test for length qualifier */
            c = READ_CHAR( mode, ptr );
    2b68:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    2b6a:	781b      	ldrb	r3, [r3, #0]
    2b6c:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
            fspec.qual = ( c && STRCHR( "hljztL", c ) ) ? (INC_VOID_PTR(ptr), c) : '\0';
    2b70:	f997 3067 	ldrsb.w	r3, [r7, #103]	@ 0x67
    2b74:	2b00      	cmp	r3, #0
    2b76:	d00e      	beq.n	2b96 <format+0x462>
    2b78:	f997 3067 	ldrsb.w	r3, [r7, #103]	@ 0x67
    2b7c:	4619      	mov	r1, r3
    2b7e:	484d      	ldr	r0, [pc, #308]	@ (2cb4 <format+0x580>)
    2b80:	f004 fb8c 	bl	729c <strchr>
    2b84:	4603      	mov	r3, r0
    2b86:	2b00      	cmp	r3, #0
    2b88:	d005      	beq.n	2b96 <format+0x462>
    2b8a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    2b8c:	3301      	adds	r3, #1
    2b8e:	663b      	str	r3, [r7, #96]	@ 0x60
    2b90:	f997 3067 	ldrsb.w	r3, [r7, #103]	@ 0x67
    2b94:	e000      	b.n	2b98 <format+0x464>
    2b96:	2300      	movs	r3, #0
    2b98:	f887 3028 	strb.w	r3, [r7, #40]	@ 0x28

            /* catch double qualifiers */
            if ( fspec.qual && (c = READ_CHAR( mode, ptr )) && c == fspec.qual )
    2b9c:	f997 3028 	ldrsb.w	r3, [r7, #40]	@ 0x28
    2ba0:	2b00      	cmp	r3, #0
    2ba2:	d017      	beq.n	2bd4 <format+0x4a0>
    2ba4:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    2ba6:	781b      	ldrb	r3, [r3, #0]
    2ba8:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
    2bac:	f997 3067 	ldrsb.w	r3, [r7, #103]	@ 0x67
    2bb0:	2b00      	cmp	r3, #0
    2bb2:	d00f      	beq.n	2bd4 <format+0x4a0>
    2bb4:	f997 3028 	ldrsb.w	r3, [r7, #40]	@ 0x28
    2bb8:	f997 2067 	ldrsb.w	r2, [r7, #103]	@ 0x67
    2bbc:	429a      	cmp	r2, r3
    2bbe:	d109      	bne.n	2bd4 <format+0x4a0>
            {
                fspec.qual = DOUBLE_QUAL( fspec.qual );
    2bc0:	f997 3028 	ldrsb.w	r3, [r7, #40]	@ 0x28
    2bc4:	f043 0301 	orr.w	r3, r3, #1
    2bc8:	b25b      	sxtb	r3, r3
    2bca:	f887 3028 	strb.w	r3, [r7, #40]	@ 0x28
                INC_VOID_PTR(ptr);
    2bce:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    2bd0:	3301      	adds	r3, #1
    2bd2:	663b      	str	r3, [r7, #96]	@ 0x60
            }

            /* Continuation */
            c = READ_CHAR( mode, ptr );
    2bd4:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    2bd6:	781b      	ldrb	r3, [r3, #0]
    2bd8:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
            if ( c == '\0' )
    2bdc:	f997 3067 	ldrsb.w	r3, [r7, #103]	@ 0x67
    2be0:	2b00      	cmp	r3, #0
    2be2:	d105      	bne.n	2bf0 <format+0x4bc>
                }
                else
                {
                    mode = NORMAL_PTR;
#endif
                    ptr = va_arg( ap, const char * );
    2be4:	693b      	ldr	r3, [r7, #16]
    2be6:	1d1a      	adds	r2, r3, #4
    2be8:	613a      	str	r2, [r7, #16]
    2bea:	681b      	ldr	r3, [r3, #0]
    2bec:	663b      	str	r3, [r7, #96]	@ 0x60
#if defined(CONFIG_HAVE_ALT_PTR)
                }
#endif
                continue;
    2bee:	e031      	b.n	2c54 <format+0x520>
            }

            convspec = c;
    2bf0:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
    2bf4:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43

            if ( convspec == 'C' )
    2bf8:	f997 3043 	ldrsb.w	r3, [r7, #67]	@ 0x43
    2bfc:	2b43      	cmp	r3, #67	@ 0x43
    2bfe:	d10f      	bne.n	2c20 <format+0x4ec>
            {
                c = READ_CHAR( mode, INC_VOID_PTR(ptr) );
    2c00:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    2c02:	3301      	adds	r3, #1
    2c04:	663b      	str	r3, [r7, #96]	@ 0x60
    2c06:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    2c08:	781b      	ldrb	r3, [r3, #0]
    2c0a:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
                if ( c == '\0' )
    2c0e:	f997 3067 	ldrsb.w	r3, [r7, #103]	@ 0x67
    2c12:	2b00      	cmp	r3, #0
    2c14:	d043      	beq.n	2c9e <format+0x56a>
                    goto exit_badformat;
                fspec.repchar = c;
    2c16:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
    2c1a:	f887 3029 	strb.w	r3, [r7, #41]	@ 0x29
    2c1e:	e002      	b.n	2c26 <format+0x4f2>
            }
            else
            {
                fspec.repchar = '\0';
    2c20:	2300      	movs	r3, #0
    2c22:	f887 3029 	strb.w	r3, [r7, #41]	@ 0x29
            }

            /* now process the conversion type */
            nn = do_conv( &fspec, &ap, convspec, cons, &arg );
    2c26:	f997 2043 	ldrsb.w	r2, [r7, #67]	@ 0x43
    2c2a:	f107 0110 	add.w	r1, r7, #16
    2c2e:	f107 0014 	add.w	r0, r7, #20
    2c32:	f107 0308 	add.w	r3, r7, #8
    2c36:	9300      	str	r3, [sp, #0]
    2c38:	68fb      	ldr	r3, [r7, #12]
    2c3a:	f7ff fc85 	bl	2548 <do_conv>
    2c3e:	63f8      	str	r0, [r7, #60]	@ 0x3c
            if ( nn < 0 )
    2c40:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
    2c42:	2b00      	cmp	r3, #0
    2c44:	db2d      	blt.n	2ca2 <format+0x56e>
                goto exit_badformat;
            else
                fspec.nChars += (unsigned int)nn;
    2c46:	697a      	ldr	r2, [r7, #20]
    2c48:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
    2c4a:	4413      	add	r3, r2
    2c4c:	617b      	str	r3, [r7, #20]

            INC_VOID_PTR(ptr);
    2c4e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    2c50:	3301      	adds	r3, #1
    2c52:	663b      	str	r3, [r7, #96]	@ 0x60
    while ( ( c = READ_CHAR( mode, ptr ) ) )
    2c54:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
    2c56:	781b      	ldrb	r3, [r3, #0]
    2c58:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
    2c5c:	f997 3067 	ldrsb.w	r3, [r7, #103]	@ 0x67
    2c60:	2b00      	cmp	r3, #0
    2c62:	f47f ad79 	bne.w	2758 <format+0x24>
        }
    }

    va_end( ap );
    return fspec.nChars;
    2c66:	697b      	ldr	r3, [r7, #20]
    2c68:	e01e      	b.n	2ca8 <format+0x574>
        goto exit_badformat;
    2c6a:	bf00      	nop
    2c6c:	e01a      	b.n	2ca4 <format+0x570>
                    goto exit_badformat;
    2c6e:	bf00      	nop
    2c70:	e018      	b.n	2ca4 <format+0x570>
                goto exit_badformat;
    2c72:	bf00      	nop
    2c74:	e016      	b.n	2ca4 <format+0x570>
                    goto exit_badformat;
    2c76:	bf00      	nop
    2c78:	e014      	b.n	2ca4 <format+0x570>
                    goto exit_badformat;
    2c7a:	bf00      	nop
    2c7c:	e012      	b.n	2ca4 <format+0x570>
                    goto exit_badformat;
    2c7e:	bf00      	nop
    2c80:	e010      	b.n	2ca4 <format+0x570>
                    goto exit_badformat; 
    2c82:	bf00      	nop
    2c84:	e00e      	b.n	2ca4 <format+0x570>
                    goto exit_badformat;
    2c86:	bf00      	nop
    2c88:	e00c      	b.n	2ca4 <format+0x570>
                    goto exit_badformat;
    2c8a:	bf00      	nop
    2c8c:	e00a      	b.n	2ca4 <format+0x570>
                    goto exit_badformat; /* fractional width is missing */
    2c8e:	bf00      	nop
    2c90:	e008      	b.n	2ca4 <format+0x570>
                    goto exit_badformat;
    2c92:	bf00      	nop
    2c94:	e006      	b.n	2ca4 <format+0x570>
                    goto exit_badformat;
    2c96:	bf00      	nop
    2c98:	e004      	b.n	2ca4 <format+0x570>
                    goto exit_badformat;
    2c9a:	bf00      	nop
    2c9c:	e002      	b.n	2ca4 <format+0x570>
                    goto exit_badformat;
    2c9e:	bf00      	nop
    2ca0:	e000      	b.n	2ca4 <format+0x570>
                goto exit_badformat;
    2ca2:	bf00      	nop

exit_badformat:
    va_end( ap );
    return EXBADFORMAT;
    2ca4:	f04f 33ff 	mov.w	r3, #4294967295
}
    2ca8:	4618      	mov	r0, r3
    2caa:	3768      	adds	r7, #104	@ 0x68
    2cac:	46bd      	mov	sp, r7
    2cae:	bd80      	pop	{r7, pc}
    2cb0:	0000b878 	.word	0x0000b878
    2cb4:	00009678 	.word	0x00009678

00002cb8 <hard_fault_handler_c>:
#endif
  	
	//We're gonna wanna figure out how to send this out all uarts...should be a binary crash packet of some sort on the binary uarts...
	
	void hard_fault_handler_c (unsigned int * hardfault_args)
	{
    2cb8:	b580      	push	{r7, lr}
    2cba:	b08c      	sub	sp, #48	@ 0x30
    2cbc:	af00      	add	r7, sp, #0
    2cbe:	6078      	str	r0, [r7, #4]
		unsigned int stacked_r12;
		unsigned int stacked_lr;
		unsigned int stacked_pc;
		unsigned int stacked_psr;
		
	    formatf ("\n\n!MajorCrashSegFaultHandler()!\n");
    2cc0:	4830      	ldr	r0, [pc, #192]	@ (2d84 <hard_fault_handler_c+0xcc>)
    2cc2:	f002 fb1d 	bl	5300 <formatf>
		
		stacked_r0 = ((unsigned long) hardfault_args[0]);
    2cc6:	687b      	ldr	r3, [r7, #4]
    2cc8:	681b      	ldr	r3, [r3, #0]
    2cca:	62fb      	str	r3, [r7, #44]	@ 0x2c
		stacked_r1 = ((unsigned long) hardfault_args[1]);
    2ccc:	687b      	ldr	r3, [r7, #4]
    2cce:	685b      	ldr	r3, [r3, #4]
    2cd0:	62bb      	str	r3, [r7, #40]	@ 0x28
		stacked_r2 = ((unsigned long) hardfault_args[2]);
    2cd2:	687b      	ldr	r3, [r7, #4]
    2cd4:	689b      	ldr	r3, [r3, #8]
    2cd6:	627b      	str	r3, [r7, #36]	@ 0x24
		stacked_r3 = ((unsigned long) hardfault_args[3]);
    2cd8:	687b      	ldr	r3, [r7, #4]
    2cda:	68db      	ldr	r3, [r3, #12]
    2cdc:	623b      	str	r3, [r7, #32]

		stacked_r12 = ((unsigned long) hardfault_args[4]);
    2cde:	687b      	ldr	r3, [r7, #4]
    2ce0:	691b      	ldr	r3, [r3, #16]
    2ce2:	61fb      	str	r3, [r7, #28]
		stacked_lr = ((unsigned long) hardfault_args[5]);
    2ce4:	687b      	ldr	r3, [r7, #4]
    2ce6:	695b      	ldr	r3, [r3, #20]
    2ce8:	61bb      	str	r3, [r7, #24]
		stacked_pc = ((unsigned long) hardfault_args[6]);
    2cea:	687b      	ldr	r3, [r7, #4]
    2cec:	699b      	ldr	r3, [r3, #24]
    2cee:	617b      	str	r3, [r7, #20]
		stacked_psr = ((unsigned long) hardfault_args[7]);
    2cf0:	687b      	ldr	r3, [r7, #4]
    2cf2:	69db      	ldr	r3, [r3, #28]
    2cf4:	613b      	str	r3, [r7, #16]

		formatf ("R0 = %x\n", stacked_r0);
    2cf6:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
    2cf8:	4823      	ldr	r0, [pc, #140]	@ (2d88 <hard_fault_handler_c+0xd0>)
    2cfa:	f002 fb01 	bl	5300 <formatf>
		formatf ("R1 = %x\n", stacked_r1);
    2cfe:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
    2d00:	4822      	ldr	r0, [pc, #136]	@ (2d8c <hard_fault_handler_c+0xd4>)
    2d02:	f002 fafd 	bl	5300 <formatf>
		formatf ("R2 = %x\n", stacked_r2);
    2d06:	6a79      	ldr	r1, [r7, #36]	@ 0x24
    2d08:	4821      	ldr	r0, [pc, #132]	@ (2d90 <hard_fault_handler_c+0xd8>)
    2d0a:	f002 faf9 	bl	5300 <formatf>
		formatf ("R3 = %x\n", stacked_r3);
    2d0e:	6a39      	ldr	r1, [r7, #32]
    2d10:	4820      	ldr	r0, [pc, #128]	@ (2d94 <hard_fault_handler_c+0xdc>)
    2d12:	f002 faf5 	bl	5300 <formatf>
		formatf ("R12 = %x\n", stacked_r12);
    2d16:	69f9      	ldr	r1, [r7, #28]
    2d18:	481f      	ldr	r0, [pc, #124]	@ (2d98 <hard_fault_handler_c+0xe0>)
    2d1a:	f002 faf1 	bl	5300 <formatf>
		formatf ("LR [R14] = %x  subroutine call return address\n", stacked_lr);
    2d1e:	69b9      	ldr	r1, [r7, #24]
    2d20:	481e      	ldr	r0, [pc, #120]	@ (2d9c <hard_fault_handler_c+0xe4>)
    2d22:	f002 faed 	bl	5300 <formatf>
		formatf ("PC [R15] = %x  program counter\n", stacked_pc);
    2d26:	6979      	ldr	r1, [r7, #20]
    2d28:	481d      	ldr	r0, [pc, #116]	@ (2da0 <hard_fault_handler_c+0xe8>)
    2d2a:	f002 fae9 	bl	5300 <formatf>
		formatf ("PSR = %x\n", stacked_psr);
    2d2e:	6939      	ldr	r1, [r7, #16]
    2d30:	481c      	ldr	r0, [pc, #112]	@ (2da4 <hard_fault_handler_c+0xec>)
    2d32:	f002 fae5 	bl	5300 <formatf>
		formatf ("BFAR = %x\n", ((volatile unsigned long *)(0xE000ED38))[0]);
    2d36:	4b1c      	ldr	r3, [pc, #112]	@ (2da8 <hard_fault_handler_c+0xf0>)
    2d38:	681b      	ldr	r3, [r3, #0]
    2d3a:	4619      	mov	r1, r3
    2d3c:	481b      	ldr	r0, [pc, #108]	@ (2dac <hard_fault_handler_c+0xf4>)
    2d3e:	f002 fadf 	bl	5300 <formatf>
		formatf ("CFSR = %x\n", ((volatile unsigned long *)(0xE000ED28))[0]);
    2d42:	4b1b      	ldr	r3, [pc, #108]	@ (2db0 <hard_fault_handler_c+0xf8>)
    2d44:	681b      	ldr	r3, [r3, #0]
    2d46:	4619      	mov	r1, r3
    2d48:	481a      	ldr	r0, [pc, #104]	@ (2db4 <hard_fault_handler_c+0xfc>)
    2d4a:	f002 fad9 	bl	5300 <formatf>
		formatf ("HFSR = %x\n", ((volatile unsigned long *)(0xE000ED2C))[0]);
    2d4e:	4b1a      	ldr	r3, [pc, #104]	@ (2db8 <hard_fault_handler_c+0x100>)
    2d50:	681b      	ldr	r3, [r3, #0]
    2d52:	4619      	mov	r1, r3
    2d54:	4819      	ldr	r0, [pc, #100]	@ (2dbc <hard_fault_handler_c+0x104>)
    2d56:	f002 fad3 	bl	5300 <formatf>
		formatf ("DFSR = %x\n", ((volatile unsigned long *)(0xE000ED30))[0]);
    2d5a:	4b19      	ldr	r3, [pc, #100]	@ (2dc0 <hard_fault_handler_c+0x108>)
    2d5c:	681b      	ldr	r3, [r3, #0]
    2d5e:	4619      	mov	r1, r3
    2d60:	4818      	ldr	r0, [pc, #96]	@ (2dc4 <hard_fault_handler_c+0x10c>)
    2d62:	f002 facd 	bl	5300 <formatf>
		formatf ("AFSR = %x\n", ((volatile unsigned long *)(0xE000ED3C))[0]);
    2d66:	4b18      	ldr	r3, [pc, #96]	@ (2dc8 <hard_fault_handler_c+0x110>)
    2d68:	681b      	ldr	r3, [r3, #0]
    2d6a:	4619      	mov	r1, r3
    2d6c:	4817      	ldr	r0, [pc, #92]	@ (2dcc <hard_fault_handler_c+0x114>)
    2d6e:	f002 fac7 	bl	5300 <formatf>
		//~ while (1); //we really don't wanna lock up in flight!
		//debug
		//while(1) { Process(); }
		
		//Just attempt to reboot and recover...
		void (*boot)() = 0;
    2d72:	2300      	movs	r3, #0
    2d74:	60fb      	str	r3, [r7, #12]
		boot();
    2d76:	68fb      	ldr	r3, [r7, #12]
    2d78:	4798      	blx	r3
	}
    2d7a:	bf00      	nop
    2d7c:	3730      	adds	r7, #48	@ 0x30
    2d7e:	46bd      	mov	sp, r7
    2d80:	bd80      	pop	{r7, pc}
    2d82:	bf00      	nop
    2d84:	000096d0 	.word	0x000096d0
    2d88:	000096f4 	.word	0x000096f4
    2d8c:	00009700 	.word	0x00009700
    2d90:	0000970c 	.word	0x0000970c
    2d94:	00009718 	.word	0x00009718
    2d98:	00009724 	.word	0x00009724
    2d9c:	00009730 	.word	0x00009730
    2da0:	00009760 	.word	0x00009760
    2da4:	00009780 	.word	0x00009780
    2da8:	e000ed38 	.word	0xe000ed38
    2dac:	0000978c 	.word	0x0000978c
    2db0:	e000ed28 	.word	0xe000ed28
    2db4:	00009798 	.word	0x00009798
    2db8:	e000ed2c 	.word	0xe000ed2c
    2dbc:	000097a4 	.word	0x000097a4
    2dc0:	e000ed30 	.word	0xe000ed30
    2dc4:	000097b0 	.word	0x000097b0
    2dc8:	e000ed3c 	.word	0xe000ed3c
    2dcc:	000097bc 	.word	0x000097bc

00002dd0 <bus_fault_handler_c>:
	
		void bus_fault_handler_c (unsigned int * hardfault_args)
	{
    2dd0:	b580      	push	{r7, lr}
    2dd2:	b086      	sub	sp, #24
    2dd4:	af00      	add	r7, sp, #0
    2dd6:	6078      	str	r0, [r7, #4]
		unsigned int stacked_lr;
		unsigned int stacked_pc;
		
		formatf ("\n\n\n!BusFault!\n");
    2dd8:	480c      	ldr	r0, [pc, #48]	@ (2e0c <bus_fault_handler_c+0x3c>)
    2dda:	f002 fa91 	bl	5300 <formatf>
		
		stacked_pc = ((unsigned long) hardfault_args[6]);
    2dde:	687b      	ldr	r3, [r7, #4]
    2de0:	699b      	ldr	r3, [r3, #24]
    2de2:	617b      	str	r3, [r7, #20]
		stacked_lr = ((unsigned long) hardfault_args[5]);
    2de4:	687b      	ldr	r3, [r7, #4]
    2de6:	695b      	ldr	r3, [r3, #20]
    2de8:	613b      	str	r3, [r7, #16]

		formatf ("PC [R15] = %x\n", stacked_pc);
    2dea:	6979      	ldr	r1, [r7, #20]
    2dec:	4808      	ldr	r0, [pc, #32]	@ (2e10 <bus_fault_handler_c+0x40>)
    2dee:	f002 fa87 	bl	5300 <formatf>
		formatf ("LR [R14] = %x\n", stacked_lr);
    2df2:	6939      	ldr	r1, [r7, #16]
    2df4:	4807      	ldr	r0, [pc, #28]	@ (2e14 <bus_fault_handler_c+0x44>)
    2df6:	f002 fa83 	bl	5300 <formatf>
		
		//while(1) { Process(); }
		
		//Flight: just attempt to reboot and recover...
		void (*boot)() = 0;
    2dfa:	2300      	movs	r3, #0
    2dfc:	60fb      	str	r3, [r7, #12]
		boot();
    2dfe:	68fb      	ldr	r3, [r7, #12]
    2e00:	4798      	blx	r3
	}
    2e02:	bf00      	nop
    2e04:	3718      	adds	r7, #24
    2e06:	46bd      	mov	sp, r7
    2e08:	bd80      	pop	{r7, pc}
    2e0a:	bf00      	nop
    2e0c:	000097c8 	.word	0x000097c8
    2e10:	000097d8 	.word	0x000097d8
    2e14:	000097e8 	.word	0x000097e8

00002e18 <usage_fault_handler_c>:
	
	void usage_fault_handler_c (unsigned int * hardfault_args)
	{
    2e18:	b580      	push	{r7, lr}
    2e1a:	b086      	sub	sp, #24
    2e1c:	af00      	add	r7, sp, #0
    2e1e:	6078      	str	r0, [r7, #4]
		unsigned int stacked_lr;
		unsigned int stacked_pc;
		
		formatf ("\n\n\n!UsageFault!\n");
    2e20:	480c      	ldr	r0, [pc, #48]	@ (2e54 <usage_fault_handler_c+0x3c>)
    2e22:	f002 fa6d 	bl	5300 <formatf>
		
		stacked_pc = ((unsigned long) hardfault_args[6]);
    2e26:	687b      	ldr	r3, [r7, #4]
    2e28:	699b      	ldr	r3, [r3, #24]
    2e2a:	617b      	str	r3, [r7, #20]
		stacked_lr = ((unsigned long) hardfault_args[5]);
    2e2c:	687b      	ldr	r3, [r7, #4]
    2e2e:	695b      	ldr	r3, [r3, #20]
    2e30:	613b      	str	r3, [r7, #16]

		formatf ("PC [R15] = %x\n", stacked_pc);
    2e32:	6979      	ldr	r1, [r7, #20]
    2e34:	4808      	ldr	r0, [pc, #32]	@ (2e58 <usage_fault_handler_c+0x40>)
    2e36:	f002 fa63 	bl	5300 <formatf>
		formatf ("LR [R14] = %x\n", stacked_lr);
    2e3a:	6939      	ldr	r1, [r7, #16]
    2e3c:	4807      	ldr	r0, [pc, #28]	@ (2e5c <usage_fault_handler_c+0x44>)
    2e3e:	f002 fa5f 	bl	5300 <formatf>
		
		//while(1) { Process(); }
		
		//Flight: just attempt to reboot and recover...
		void (*boot)() = 0;
    2e42:	2300      	movs	r3, #0
    2e44:	60fb      	str	r3, [r7, #12]
		boot();
    2e46:	68fb      	ldr	r3, [r7, #12]
    2e48:	4798      	blx	r3
	}
    2e4a:	bf00      	nop
    2e4c:	3718      	adds	r7, #24
    2e4e:	46bd      	mov	sp, r7
    2e50:	bd80      	pop	{r7, pc}
    2e52:	bf00      	nop
    2e54:	000097f8 	.word	0x000097f8
    2e58:	000097d8 	.word	0x000097d8
    2e5c:	000097e8 	.word	0x000097e8

00002e60 <Cmd::Cmd(char const*, char const*, signed char (*)(char const*, char const*, unsigned int, void const*))>:
	char const* Name; ///The acutal command
	char const* Help; ///Any instructions for the command we'd like users to see
	uint8_t Strlen; ///Embbed the lenght of 'Name' in the struct so we're not always calling the strlen() function
	int8_t (*Response)(char const*, char const*, const size_t, const void*); ///callback function to excecute this command when it's located.

	Cmd(const char* name, const char* help, int8_t (*resp)(char const*, char const*, const size_t, const void*) )
    2e60:	b580      	push	{r7, lr}
    2e62:	b084      	sub	sp, #16
    2e64:	af00      	add	r7, sp, #0
    2e66:	60f8      	str	r0, [r7, #12]
    2e68:	60b9      	str	r1, [r7, #8]
    2e6a:	607a      	str	r2, [r7, #4]
    2e6c:	603b      	str	r3, [r7, #0]
		: Name(name), Help(help), Strlen(0), Response(resp)
    2e6e:	68fb      	ldr	r3, [r7, #12]
    2e70:	68ba      	ldr	r2, [r7, #8]
    2e72:	601a      	str	r2, [r3, #0]
    2e74:	68fb      	ldr	r3, [r7, #12]
    2e76:	687a      	ldr	r2, [r7, #4]
    2e78:	605a      	str	r2, [r3, #4]
    2e7a:	68fb      	ldr	r3, [r7, #12]
    2e7c:	2200      	movs	r2, #0
    2e7e:	721a      	strb	r2, [r3, #8]
    2e80:	68fb      	ldr	r3, [r7, #12]
    2e82:	683a      	ldr	r2, [r7, #0]
    2e84:	60da      	str	r2, [r3, #12]
	{
		Strlen = strlen(Name);
    2e86:	68fb      	ldr	r3, [r7, #12]
    2e88:	681b      	ldr	r3, [r3, #0]
    2e8a:	4618      	mov	r0, r3
    2e8c:	f004 faf1 	bl	7472 <strlen>
    2e90:	4603      	mov	r3, r0
    2e92:	b2da      	uxtb	r2, r3
    2e94:	68fb      	ldr	r3, [r7, #12]
    2e96:	721a      	strb	r2, [r3, #8]
	}
    2e98:	68fb      	ldr	r3, [r7, #12]
    2e9a:	4618      	mov	r0, r3
    2e9c:	3710      	adds	r7, #16
    2e9e:	46bd      	mov	sp, r7
    2ea0:	bd80      	pop	{r7, pc}
	...

00002ea4 <__static_initialization_and_destruction_0()>:
		DMLongPixelsCommand
    ),
};

//Calculate the number of commands instanciated in the system - links with CmdSystem.cpp.o
const uint8_t NumAsciiCmds = sizeof(AsciiCmds) / sizeof(AsciiCmds[0]);
    2ea4:	b598      	push	{r3, r4, r7, lr}
    2ea6:	af00      	add	r7, sp, #0
};
    2ea8:	4c43      	ldr	r4, [pc, #268]	@ (2fb8 <__static_initialization_and_destruction_0()+0x114>)
    2eaa:	4b44      	ldr	r3, [pc, #272]	@ (2fbc <__static_initialization_and_destruction_0()+0x118>)
    2eac:	4a44      	ldr	r2, [pc, #272]	@ (2fc0 <__static_initialization_and_destruction_0()+0x11c>)
    2eae:	4945      	ldr	r1, [pc, #276]	@ (2fc4 <__static_initialization_and_destruction_0()+0x120>)
    2eb0:	4620      	mov	r0, r4
    2eb2:	f7ff ffd5 	bl	2e60 <Cmd::Cmd(char const*, char const*, signed char (*)(char const*, char const*, unsigned int, void const*))>
    2eb6:	3410      	adds	r4, #16
    2eb8:	4b43      	ldr	r3, [pc, #268]	@ (2fc8 <__static_initialization_and_destruction_0()+0x124>)
    2eba:	4a44      	ldr	r2, [pc, #272]	@ (2fcc <__static_initialization_and_destruction_0()+0x128>)
    2ebc:	4944      	ldr	r1, [pc, #272]	@ (2fd0 <__static_initialization_and_destruction_0()+0x12c>)
    2ebe:	4620      	mov	r0, r4
    2ec0:	f7ff ffce 	bl	2e60 <Cmd::Cmd(char const*, char const*, signed char (*)(char const*, char const*, unsigned int, void const*))>
    2ec4:	3410      	adds	r4, #16
    2ec6:	4b43      	ldr	r3, [pc, #268]	@ (2fd4 <__static_initialization_and_destruction_0()+0x130>)
    2ec8:	4a43      	ldr	r2, [pc, #268]	@ (2fd8 <__static_initialization_and_destruction_0()+0x134>)
    2eca:	4944      	ldr	r1, [pc, #272]	@ (2fdc <__static_initialization_and_destruction_0()+0x138>)
    2ecc:	4620      	mov	r0, r4
    2ece:	f7ff ffc7 	bl	2e60 <Cmd::Cmd(char const*, char const*, signed char (*)(char const*, char const*, unsigned int, void const*))>
    2ed2:	3410      	adds	r4, #16
    2ed4:	4b3c      	ldr	r3, [pc, #240]	@ (2fc8 <__static_initialization_and_destruction_0()+0x124>)
    2ed6:	4a42      	ldr	r2, [pc, #264]	@ (2fe0 <__static_initialization_and_destruction_0()+0x13c>)
    2ed8:	4942      	ldr	r1, [pc, #264]	@ (2fe4 <__static_initialization_and_destruction_0()+0x140>)
    2eda:	4620      	mov	r0, r4
    2edc:	f7ff ffc0 	bl	2e60 <Cmd::Cmd(char const*, char const*, signed char (*)(char const*, char const*, unsigned int, void const*))>
    2ee0:	3410      	adds	r4, #16
    2ee2:	4b3c      	ldr	r3, [pc, #240]	@ (2fd4 <__static_initialization_and_destruction_0()+0x130>)
    2ee4:	4a40      	ldr	r2, [pc, #256]	@ (2fe8 <__static_initialization_and_destruction_0()+0x144>)
    2ee6:	4941      	ldr	r1, [pc, #260]	@ (2fec <__static_initialization_and_destruction_0()+0x148>)
    2ee8:	4620      	mov	r0, r4
    2eea:	f7ff ffb9 	bl	2e60 <Cmd::Cmd(char const*, char const*, signed char (*)(char const*, char const*, unsigned int, void const*))>
    2eee:	3410      	adds	r4, #16
    2ef0:	4b3f      	ldr	r3, [pc, #252]	@ (2ff0 <__static_initialization_and_destruction_0()+0x14c>)
    2ef2:	4a40      	ldr	r2, [pc, #256]	@ (2ff4 <__static_initialization_and_destruction_0()+0x150>)
    2ef4:	4940      	ldr	r1, [pc, #256]	@ (2ff8 <__static_initialization_and_destruction_0()+0x154>)
    2ef6:	4620      	mov	r0, r4
    2ef8:	f7ff ffb2 	bl	2e60 <Cmd::Cmd(char const*, char const*, signed char (*)(char const*, char const*, unsigned int, void const*))>
    2efc:	3410      	adds	r4, #16
    2efe:	4b3c      	ldr	r3, [pc, #240]	@ (2ff0 <__static_initialization_and_destruction_0()+0x14c>)
    2f00:	4a3e      	ldr	r2, [pc, #248]	@ (2ffc <__static_initialization_and_destruction_0()+0x158>)
    2f02:	493f      	ldr	r1, [pc, #252]	@ (3000 <__static_initialization_and_destruction_0()+0x15c>)
    2f04:	4620      	mov	r0, r4
    2f06:	f7ff ffab 	bl	2e60 <Cmd::Cmd(char const*, char const*, signed char (*)(char const*, char const*, unsigned int, void const*))>
    2f0a:	3410      	adds	r4, #16
    2f0c:	4b3d      	ldr	r3, [pc, #244]	@ (3004 <__static_initialization_and_destruction_0()+0x160>)
    2f0e:	4a3e      	ldr	r2, [pc, #248]	@ (3008 <__static_initialization_and_destruction_0()+0x164>)
    2f10:	493e      	ldr	r1, [pc, #248]	@ (300c <__static_initialization_and_destruction_0()+0x168>)
    2f12:	4620      	mov	r0, r4
    2f14:	f7ff ffa4 	bl	2e60 <Cmd::Cmd(char const*, char const*, signed char (*)(char const*, char const*, unsigned int, void const*))>
    2f18:	3410      	adds	r4, #16
    2f1a:	4b3a      	ldr	r3, [pc, #232]	@ (3004 <__static_initialization_and_destruction_0()+0x160>)
    2f1c:	4a3c      	ldr	r2, [pc, #240]	@ (3010 <__static_initialization_and_destruction_0()+0x16c>)
    2f1e:	493d      	ldr	r1, [pc, #244]	@ (3014 <__static_initialization_and_destruction_0()+0x170>)
    2f20:	4620      	mov	r0, r4
    2f22:	f7ff ff9d 	bl	2e60 <Cmd::Cmd(char const*, char const*, signed char (*)(char const*, char const*, unsigned int, void const*))>
    2f26:	3410      	adds	r4, #16
    2f28:	4b3b      	ldr	r3, [pc, #236]	@ (3018 <__static_initialization_and_destruction_0()+0x174>)
    2f2a:	4a3c      	ldr	r2, [pc, #240]	@ (301c <__static_initialization_and_destruction_0()+0x178>)
    2f2c:	493c      	ldr	r1, [pc, #240]	@ (3020 <__static_initialization_and_destruction_0()+0x17c>)
    2f2e:	4620      	mov	r0, r4
    2f30:	f7ff ff96 	bl	2e60 <Cmd::Cmd(char const*, char const*, signed char (*)(char const*, char const*, unsigned int, void const*))>
    2f34:	3410      	adds	r4, #16
    2f36:	4b3b      	ldr	r3, [pc, #236]	@ (3024 <__static_initialization_and_destruction_0()+0x180>)
    2f38:	4a3b      	ldr	r2, [pc, #236]	@ (3028 <__static_initialization_and_destruction_0()+0x184>)
    2f3a:	493c      	ldr	r1, [pc, #240]	@ (302c <__static_initialization_and_destruction_0()+0x188>)
    2f3c:	4620      	mov	r0, r4
    2f3e:	f7ff ff8f 	bl	2e60 <Cmd::Cmd(char const*, char const*, signed char (*)(char const*, char const*, unsigned int, void const*))>
    2f42:	3410      	adds	r4, #16
    2f44:	4b37      	ldr	r3, [pc, #220]	@ (3024 <__static_initialization_and_destruction_0()+0x180>)
    2f46:	4a3a      	ldr	r2, [pc, #232]	@ (3030 <__static_initialization_and_destruction_0()+0x18c>)
    2f48:	493a      	ldr	r1, [pc, #232]	@ (3034 <__static_initialization_and_destruction_0()+0x190>)
    2f4a:	4620      	mov	r0, r4
    2f4c:	f7ff ff88 	bl	2e60 <Cmd::Cmd(char const*, char const*, signed char (*)(char const*, char const*, unsigned int, void const*))>
    2f50:	3410      	adds	r4, #16
    2f52:	4b39      	ldr	r3, [pc, #228]	@ (3038 <__static_initialization_and_destruction_0()+0x194>)
    2f54:	4a39      	ldr	r2, [pc, #228]	@ (303c <__static_initialization_and_destruction_0()+0x198>)
    2f56:	493a      	ldr	r1, [pc, #232]	@ (3040 <__static_initialization_and_destruction_0()+0x19c>)
    2f58:	4620      	mov	r0, r4
    2f5a:	f7ff ff81 	bl	2e60 <Cmd::Cmd(char const*, char const*, signed char (*)(char const*, char const*, unsigned int, void const*))>
    2f5e:	3410      	adds	r4, #16
    2f60:	4b38      	ldr	r3, [pc, #224]	@ (3044 <__static_initialization_and_destruction_0()+0x1a0>)
    2f62:	4a39      	ldr	r2, [pc, #228]	@ (3048 <__static_initialization_and_destruction_0()+0x1a4>)
    2f64:	4939      	ldr	r1, [pc, #228]	@ (304c <__static_initialization_and_destruction_0()+0x1a8>)
    2f66:	4620      	mov	r0, r4
    2f68:	f7ff ff7a 	bl	2e60 <Cmd::Cmd(char const*, char const*, signed char (*)(char const*, char const*, unsigned int, void const*))>
    2f6c:	3410      	adds	r4, #16
    2f6e:	4b38      	ldr	r3, [pc, #224]	@ (3050 <__static_initialization_and_destruction_0()+0x1ac>)
    2f70:	4a38      	ldr	r2, [pc, #224]	@ (3054 <__static_initialization_and_destruction_0()+0x1b0>)
    2f72:	4939      	ldr	r1, [pc, #228]	@ (3058 <__static_initialization_and_destruction_0()+0x1b4>)
    2f74:	4620      	mov	r0, r4
    2f76:	f7ff ff73 	bl	2e60 <Cmd::Cmd(char const*, char const*, signed char (*)(char const*, char const*, unsigned int, void const*))>
    2f7a:	3410      	adds	r4, #16
    2f7c:	4b37      	ldr	r3, [pc, #220]	@ (305c <__static_initialization_and_destruction_0()+0x1b8>)
    2f7e:	4a38      	ldr	r2, [pc, #224]	@ (3060 <__static_initialization_and_destruction_0()+0x1bc>)
    2f80:	4938      	ldr	r1, [pc, #224]	@ (3064 <__static_initialization_and_destruction_0()+0x1c0>)
    2f82:	4620      	mov	r0, r4
    2f84:	f7ff ff6c 	bl	2e60 <Cmd::Cmd(char const*, char const*, signed char (*)(char const*, char const*, unsigned int, void const*))>
    2f88:	3410      	adds	r4, #16
    2f8a:	4b37      	ldr	r3, [pc, #220]	@ (3068 <__static_initialization_and_destruction_0()+0x1c4>)
    2f8c:	4a37      	ldr	r2, [pc, #220]	@ (306c <__static_initialization_and_destruction_0()+0x1c8>)
    2f8e:	4938      	ldr	r1, [pc, #224]	@ (3070 <__static_initialization_and_destruction_0()+0x1cc>)
    2f90:	4620      	mov	r0, r4
    2f92:	f7ff ff65 	bl	2e60 <Cmd::Cmd(char const*, char const*, signed char (*)(char const*, char const*, unsigned int, void const*))>
    2f96:	3410      	adds	r4, #16
    2f98:	4b36      	ldr	r3, [pc, #216]	@ (3074 <__static_initialization_and_destruction_0()+0x1d0>)
    2f9a:	4a37      	ldr	r2, [pc, #220]	@ (3078 <__static_initialization_and_destruction_0()+0x1d4>)
    2f9c:	4937      	ldr	r1, [pc, #220]	@ (307c <__static_initialization_and_destruction_0()+0x1d8>)
    2f9e:	4620      	mov	r0, r4
    2fa0:	f7ff ff5e 	bl	2e60 <Cmd::Cmd(char const*, char const*, signed char (*)(char const*, char const*, unsigned int, void const*))>
    2fa4:	f104 0010 	add.w	r0, r4, #16
    2fa8:	4b35      	ldr	r3, [pc, #212]	@ (3080 <__static_initialization_and_destruction_0()+0x1dc>)
    2faa:	4a36      	ldr	r2, [pc, #216]	@ (3084 <__static_initialization_and_destruction_0()+0x1e0>)
    2fac:	4936      	ldr	r1, [pc, #216]	@ (3088 <__static_initialization_and_destruction_0()+0x1e4>)
    2fae:	f7ff ff57 	bl	2e60 <Cmd::Cmd(char const*, char const*, signed char (*)(char const*, char const*, unsigned int, void const*))>
const uint8_t NumAsciiCmds = sizeof(AsciiCmds) / sizeof(AsciiCmds[0]);
    2fb2:	bf00      	nop
    2fb4:	bd98      	pop	{r3, r4, r7, pc}
    2fb6:	bf00      	nop
    2fb8:	200000d0 	.word	0x200000d0
    2fbc:	00003285 	.word	0x00003285
    2fc0:	0000980c 	.word	0x0000980c
    2fc4:	00009844 	.word	0x00009844
    2fc8:	000032ed 	.word	0x000032ed
    2fcc:	0000984c 	.word	0x0000984c
    2fd0:	00009860 	.word	0x00009860
    2fd4:	000033b5 	.word	0x000033b5
    2fd8:	0000986c 	.word	0x0000986c
    2fdc:	00009888 	.word	0x00009888
    2fe0:	00009894 	.word	0x00009894
    2fe4:	000098ac 	.word	0x000098ac
    2fe8:	000098b0 	.word	0x000098b0
    2fec:	000098d0 	.word	0x000098d0
    2ff0:	00003441 	.word	0x00003441
    2ff4:	000098d4 	.word	0x000098d4
    2ff8:	00009920 	.word	0x00009920
    2ffc:	00009928 	.word	0x00009928
    3000:	00009974 	.word	0x00009974
    3004:	00003649 	.word	0x00003649
    3008:	00009978 	.word	0x00009978
    300c:	000099ac 	.word	0x000099ac
    3010:	000099b4 	.word	0x000099b4
    3014:	000099e8 	.word	0x000099e8
    3018:	000037c9 	.word	0x000037c9
    301c:	000099ec 	.word	0x000099ec
    3020:	00009a20 	.word	0x00009a20
    3024:	00003829 	.word	0x00003829
    3028:	00009a28 	.word	0x00009a28
    302c:	00009a44 	.word	0x00009a44
    3030:	00009a4c 	.word	0x00009a4c
    3034:	00009a68 	.word	0x00009a68
    3038:	00003969 	.word	0x00003969
    303c:	00009a6c 	.word	0x00009a6c
    3040:	00009abc 	.word	0x00009abc
    3044:	00003afd 	.word	0x00003afd
    3048:	00009acc 	.word	0x00009acc
    304c:	00009b0c 	.word	0x00009b0c
    3050:	00003b49 	.word	0x00003b49
    3054:	00009b1c 	.word	0x00009b1c
    3058:	00009b64 	.word	0x00009b64
    305c:	00003cb5 	.word	0x00003cb5
    3060:	00009b74 	.word	0x00009b74
    3064:	00009bcc 	.word	0x00009bcc
    3068:	00003d75 	.word	0x00003d75
    306c:	00009bd8 	.word	0x00009bd8
    3070:	00009c28 	.word	0x00009c28
    3074:	00003eed 	.word	0x00003eed
    3078:	00009c38 	.word	0x00009c38
    307c:	00009c88 	.word	0x00009c88
    3080:	000040c1 	.word	0x000040c1
    3084:	00009c94 	.word	0x00009c94
    3088:	00009ce0 	.word	0x00009ce0

0000308c <_GLOBAL__sub_I_AsciiCmds>:
    308c:	b580      	push	{r7, lr}
    308e:	af00      	add	r7, sp, #0
    3090:	f7ff ff08 	bl	2ea4 <__static_initialization_and_destruction_0()>
    3094:	bd80      	pop	{r7, pc}

00003096 <AdcAccumulator::AdcAccumulator()>:

    } __attribute__((__packed__));

    //static const int32_t AdcFullScale = 0x7FFFFFFFL; //2^32 - 1; must divide accumulator by numaccums first obviously

    AdcAccumulator() { all = 0; }
    3096:	b480      	push	{r7}
    3098:	b083      	sub	sp, #12
    309a:	af00      	add	r7, sp, #0
    309c:	6078      	str	r0, [r7, #4]
    309e:	687b      	ldr	r3, [r7, #4]
    30a0:	2200      	movs	r2, #0
    30a2:	701a      	strb	r2, [r3, #0]
    30a4:	2200      	movs	r2, #0
    30a6:	705a      	strb	r2, [r3, #1]
    30a8:	2200      	movs	r2, #0
    30aa:	709a      	strb	r2, [r3, #2]
    30ac:	2200      	movs	r2, #0
    30ae:	70da      	strb	r2, [r3, #3]
    30b0:	2200      	movs	r2, #0
    30b2:	711a      	strb	r2, [r3, #4]
    30b4:	2200      	movs	r2, #0
    30b6:	715a      	strb	r2, [r3, #5]
    30b8:	2200      	movs	r2, #0
    30ba:	719a      	strb	r2, [r3, #6]
    30bc:	2200      	movs	r2, #0
    30be:	71da      	strb	r2, [r3, #7]
    30c0:	687b      	ldr	r3, [r7, #4]
    30c2:	4618      	mov	r0, r3
    30c4:	370c      	adds	r7, #12
    30c6:	46bd      	mov	sp, r7
    30c8:	bc80      	pop	{r7}
    30ca:	4770      	bx	lr

000030cc <CGraphVersionPayload::formatf() const>:
struct CGraphVersionPayload
{
	uint32_t SerialNum;
	uint32_t ProcessorFirmwareBuildNum;
	uint32_t FPGAFirmwareBuildNum;
	void formatf() const { ::printf("CGraphVersionPayload: SerialNum: 0x%lX, ProcessorFirmwareBuildNum: %lu, FPGAFirmwareBuildNum: %lu", (long)SerialNum, (unsigned long)ProcessorFirmwareBuildNum, (unsigned long)FPGAFirmwareBuildNum); }
    30cc:	b580      	push	{r7, lr}
    30ce:	b082      	sub	sp, #8
    30d0:	af00      	add	r7, sp, #0
    30d2:	6078      	str	r0, [r7, #4]
    30d4:	687b      	ldr	r3, [r7, #4]
    30d6:	681b      	ldr	r3, [r3, #0]
    30d8:	4619      	mov	r1, r3
    30da:	687b      	ldr	r3, [r7, #4]
    30dc:	685a      	ldr	r2, [r3, #4]
    30de:	687b      	ldr	r3, [r7, #4]
    30e0:	689b      	ldr	r3, [r3, #8]
    30e2:	4803      	ldr	r0, [pc, #12]	@ (30f0 <CGraphVersionPayload::formatf() const+0x24>)
    30e4:	f003 ff22 	bl	6f2c <iprintf>
    30e8:	bf00      	nop
    30ea:	3708      	adds	r7, #8
    30ec:	46bd      	mov	sp, r7
    30ee:	bd80      	pop	{r7, pc}
    30f0:	00009cf0 	.word	0x00009cf0

000030f4 <CGraphDMMappingPayload::CGraphDMMappingPayload(unsigned long, unsigned long, unsigned long)>:
	uint8_t ControllerBoardIndex; // 0 ... DMMaxControllerBoards - 1
	uint8_t DacIndex; // 0 ... DMMDacsPerControllerBoard - 1
	uint8_t DacChannel; // 0 ... DMActuatorsPerDac - 1
	
	CGraphDMMappingPayload() : ControllerBoardIndex(0), DacIndex(0), DacChannel(0) { }
	CGraphDMMappingPayload(unsigned long bi, unsigned long di, unsigned long dc) : ControllerBoardIndex(bi), DacIndex(di), DacChannel(dc) { }
    30f4:	b480      	push	{r7}
    30f6:	b085      	sub	sp, #20
    30f8:	af00      	add	r7, sp, #0
    30fa:	60f8      	str	r0, [r7, #12]
    30fc:	60b9      	str	r1, [r7, #8]
    30fe:	607a      	str	r2, [r7, #4]
    3100:	603b      	str	r3, [r7, #0]
    3102:	68bb      	ldr	r3, [r7, #8]
    3104:	b2da      	uxtb	r2, r3
    3106:	68fb      	ldr	r3, [r7, #12]
    3108:	701a      	strb	r2, [r3, #0]
    310a:	687b      	ldr	r3, [r7, #4]
    310c:	b2da      	uxtb	r2, r3
    310e:	68fb      	ldr	r3, [r7, #12]
    3110:	705a      	strb	r2, [r3, #1]
    3112:	683b      	ldr	r3, [r7, #0]
    3114:	b2da      	uxtb	r2, r3
    3116:	68fb      	ldr	r3, [r7, #12]
    3118:	709a      	strb	r2, [r3, #2]
    311a:	68fb      	ldr	r3, [r7, #12]
    311c:	4618      	mov	r0, r3
    311e:	3714      	adds	r7, #20
    3120:	46bd      	mov	sp, r7
    3122:	bc80      	pop	{r7}
    3124:	4770      	bx	lr
	...

00003128 <CGraphDMMappingPayload::formatf() const>:
	
	void formatf() const { ::printf("CGraphDMMappingPayload: ControllerBoardIndex: %lu, DacIndex: %lu, DacChannel: %lu", (unsigned long)ControllerBoardIndex, (unsigned long)DacIndex, (unsigned long)DacChannel); }
    3128:	b580      	push	{r7, lr}
    312a:	b082      	sub	sp, #8
    312c:	af00      	add	r7, sp, #0
    312e:	6078      	str	r0, [r7, #4]
    3130:	687b      	ldr	r3, [r7, #4]
    3132:	781b      	ldrb	r3, [r3, #0]
    3134:	4619      	mov	r1, r3
    3136:	687b      	ldr	r3, [r7, #4]
    3138:	785b      	ldrb	r3, [r3, #1]
    313a:	461a      	mov	r2, r3
    313c:	687b      	ldr	r3, [r7, #4]
    313e:	789b      	ldrb	r3, [r3, #2]
    3140:	4803      	ldr	r0, [pc, #12]	@ (3150 <CGraphDMMappingPayload::formatf() const+0x28>)
    3142:	f003 fef3 	bl	6f2c <iprintf>
    3146:	bf00      	nop
    3148:	3708      	adds	r7, #8
    314a:	46bd      	mov	sp, r7
    314c:	bd80      	pop	{r7, pc}
    314e:	bf00      	nop
    3150:	00009d54 	.word	0x00009d54

00003154 <CGraphDMMappings::formatf() const>:
				}
			}
		}
	}
	
	void formatf() const 
    3154:	b580      	push	{r7, lr}
    3156:	b084      	sub	sp, #16
    3158:	af00      	add	r7, sp, #0
    315a:	6078      	str	r0, [r7, #4]
	{ 
		for (size_t i = 0; i < DMMaxActuators; i++)
    315c:	2300      	movs	r3, #0
    315e:	60fb      	str	r3, [r7, #12]
    3160:	e00e      	b.n	3180 <CGraphDMMappings::formatf() const+0x2c>
		{
			Mappings[i].formatf();
    3162:	68fa      	ldr	r2, [r7, #12]
    3164:	4613      	mov	r3, r2
    3166:	005b      	lsls	r3, r3, #1
    3168:	4413      	add	r3, r2
    316a:	687a      	ldr	r2, [r7, #4]
    316c:	4413      	add	r3, r2
    316e:	4618      	mov	r0, r3
    3170:	f7ff ffda 	bl	3128 <CGraphDMMappingPayload::formatf() const>
			::printf("\n");
    3174:	200a      	movs	r0, #10
    3176:	f003 ff1f 	bl	6fb8 <putchar>
		for (size_t i = 0; i < DMMaxActuators; i++)
    317a:	68fb      	ldr	r3, [r7, #12]
    317c:	3301      	adds	r3, #1
    317e:	60fb      	str	r3, [r7, #12]
    3180:	68fb      	ldr	r3, [r7, #12]
    3182:	f5b3 7f70 	cmp.w	r3, #960	@ 0x3c0
    3186:	d3ec      	bcc.n	3162 <CGraphDMMappings::formatf() const+0xe>
		}
	}
    3188:	bf00      	nop
    318a:	bf00      	nop
    318c:	3710      	adds	r7, #16
    318e:	46bd      	mov	sp, r7
    3190:	bd80      	pop	{r7, pc}
	...

00003194 <BinaryUart::formatf() const>:
			for(size_t i = 0; i < PktLen; i++) { printf("%.2X:", TxBuffer[i]); }
			printf("\n\n");
		}
	}

	void formatf() const
    3194:	b580      	push	{r7, lr}
    3196:	b084      	sub	sp, #16
    3198:	af00      	add	r7, sp, #0
    319a:	6078      	str	r0, [r7, #4]
	{
		::formatf("\n\nBinaryUart(%u, %c, %u): :", RxCount, InPacket?'Y':'N', PacketStart);
    319c:	687b      	ldr	r3, [r7, #4]
    319e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    31a2:	899b      	ldrh	r3, [r3, #12]
    31a4:	4619      	mov	r1, r3
    31a6:	687b      	ldr	r3, [r7, #4]
    31a8:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    31ac:	f893 3021 	ldrb.w	r3, [r3, #33]	@ 0x21
    31b0:	2b00      	cmp	r3, #0
    31b2:	d001      	beq.n	31b8 <BinaryUart::formatf() const+0x24>
    31b4:	2259      	movs	r2, #89	@ 0x59
    31b6:	e000      	b.n	31ba <BinaryUart::formatf() const+0x26>
    31b8:	224e      	movs	r2, #78	@ 0x4e
    31ba:	687b      	ldr	r3, [r7, #4]
    31bc:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    31c0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
    31c2:	4810      	ldr	r0, [pc, #64]	@ (3204 <BinaryUart::formatf() const+0x70>)
    31c4:	f002 f89c 	bl	5300 <formatf>
		for(size_t i = 0; i < RxCount; i++) { printf("%.2X:", RxBuffer[i]); }
    31c8:	2300      	movs	r3, #0
    31ca:	60fb      	str	r3, [r7, #12]
    31cc:	e00b      	b.n	31e6 <BinaryUart::formatf() const+0x52>
    31ce:	687a      	ldr	r2, [r7, #4]
    31d0:	68fb      	ldr	r3, [r7, #12]
    31d2:	4413      	add	r3, r2
    31d4:	330c      	adds	r3, #12
    31d6:	781b      	ldrb	r3, [r3, #0]
    31d8:	4619      	mov	r1, r3
    31da:	480b      	ldr	r0, [pc, #44]	@ (3208 <BinaryUart::formatf() const+0x74>)
    31dc:	f003 fea6 	bl	6f2c <iprintf>
    31e0:	68fb      	ldr	r3, [r7, #12]
    31e2:	3301      	adds	r3, #1
    31e4:	60fb      	str	r3, [r7, #12]
    31e6:	687b      	ldr	r3, [r7, #4]
    31e8:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    31ec:	899b      	ldrh	r3, [r3, #12]
    31ee:	461a      	mov	r2, r3
    31f0:	68fb      	ldr	r3, [r7, #12]
    31f2:	4293      	cmp	r3, r2
    31f4:	d3eb      	bcc.n	31ce <BinaryUart::formatf() const+0x3a>
		printf("\n\n");
    31f6:	4805      	ldr	r0, [pc, #20]	@ (320c <BinaryUart::formatf() const+0x78>)
    31f8:	f003 ff3c 	bl	7074 <puts>
	}
    31fc:	bf00      	nop
    31fe:	3710      	adds	r7, #16
    3200:	46bd      	mov	sp, r7
    3202:	bd80      	pop	{r7, pc}
    3204:	00009da8 	.word	0x00009da8
    3208:	00009dc4 	.word	0x00009dc4
    320c:	00009dcc 	.word	0x00009dcc

00003210 <TxBinaryPacket(void const*, unsigned short, unsigned long, void const*, unsigned int)>:
};

//Slightly ugly hack cause our CmdSystem is C, not C++, but whatever...

__inline__ void TxBinaryPacket(const void* TxPktContext, const uint16_t PayloadTypeToken, const uint32_t SerialNumber, const void* PayloadData, const size_t PayloadLen)
{
    3210:	b590      	push	{r4, r7, lr}
    3212:	b087      	sub	sp, #28
    3214:	af02      	add	r7, sp, #8
    3216:	60f8      	str	r0, [r7, #12]
    3218:	607a      	str	r2, [r7, #4]
    321a:	603b      	str	r3, [r7, #0]
    321c:	460b      	mov	r3, r1
    321e:	817b      	strh	r3, [r7, #10]
	if (NULL != TxPktContext) { reinterpret_cast<const BinaryUart*>(TxPktContext)->TxBinaryPacket(PayloadTypeToken, SerialNumber, PayloadData, PayloadLen); }
    3220:	68fb      	ldr	r3, [r7, #12]
    3222:	2b00      	cmp	r3, #0
    3224:	d00b      	beq.n	323e <TxBinaryPacket(void const*, unsigned short, unsigned long, void const*, unsigned int)+0x2e>
    3226:	68fb      	ldr	r3, [r7, #12]
    3228:	681b      	ldr	r3, [r3, #0]
    322a:	330c      	adds	r3, #12
    322c:	681c      	ldr	r4, [r3, #0]
    322e:	8979      	ldrh	r1, [r7, #10]
    3230:	6a3b      	ldr	r3, [r7, #32]
    3232:	9300      	str	r3, [sp, #0]
    3234:	683b      	ldr	r3, [r7, #0]
    3236:	687a      	ldr	r2, [r7, #4]
    3238:	68f8      	ldr	r0, [r7, #12]
    323a:	47a0      	blx	r4
	else { ::formatf("\n\nTxBinaryPacket: NULL PacketContext! (Should be BinaryUart*) Please recompile this binary...\n\r"); }
};
    323c:	e002      	b.n	3244 <TxBinaryPacket(void const*, unsigned short, unsigned long, void const*, unsigned int)+0x34>
	else { ::formatf("\n\nTxBinaryPacket: NULL PacketContext! (Should be BinaryUart*) Please recompile this binary...\n\r"); }
    323e:	4803      	ldr	r0, [pc, #12]	@ (324c <TxBinaryPacket(void const*, unsigned short, unsigned long, void const*, unsigned int)+0x3c>)
    3240:	f002 f85e 	bl	5300 <formatf>
};
    3244:	bf00      	nop
    3246:	3714      	adds	r7, #20
    3248:	46bd      	mov	sp, r7
    324a:	bd90      	pop	{r4, r7, pc}
    324c:	00009dd0 	.word	0x00009dd0

00003250 <uart_pinout_fpga::Monitor(bool)>:

	virtual void flushoutput() override { } // if (FW) { FW->UartTxStatusRegister = 0; } //Need to make tx & rx status registers seperate...
	virtual void purgeinput() override { } // if (FW) { FW->UartRxStatusRegister = 0; }
	virtual bool isopen() const override { return(true); }
	
	void Monitor(const bool m) { monitor = m; }
    3250:	b480      	push	{r7}
    3252:	b083      	sub	sp, #12
    3254:	af00      	add	r7, sp, #0
    3256:	6078      	str	r0, [r7, #4]
    3258:	460b      	mov	r3, r1
    325a:	70fb      	strb	r3, [r7, #3]
    325c:	687b      	ldr	r3, [r7, #4]
    325e:	78fa      	ldrb	r2, [r7, #3]
    3260:	711a      	strb	r2, [r3, #4]
    3262:	bf00      	nop
    3264:	370c      	adds	r7, #12
    3266:	46bd      	mov	sp, r7
    3268:	bc80      	pop	{r7}
    326a:	4770      	bx	lr

0000326c <uart_pinout_fpga::Monitor() const>:
	bool Monitor() const { return(monitor); }
    326c:	b480      	push	{r7}
    326e:	b083      	sub	sp, #12
    3270:	af00      	add	r7, sp, #0
    3272:	6078      	str	r0, [r7, #4]
    3274:	687b      	ldr	r3, [r7, #4]
    3276:	791b      	ldrb	r3, [r3, #4]
    3278:	4618      	mov	r0, r3
    327a:	370c      	adds	r7, #12
    327c:	46bd      	mov	sp, r7
    327e:	bc80      	pop	{r7}
    3280:	4770      	bx	lr
	...

00003284 <VersionCommand(char const*, char const*, unsigned int, void const*)>:
extern CGraphDMMappings DMMappings;

char Buffer[4096];

int8_t VersionCommand(char const* Name, char const* Params, const size_t ParamsLen, const void* Argument)
{
    3284:	b580      	push	{r7, lr}
    3286:	b086      	sub	sp, #24
    3288:	af02      	add	r7, sp, #8
    328a:	60f8      	str	r0, [r7, #12]
    328c:	60b9      	str	r1, [r7, #8]
    328e:	607a      	str	r2, [r7, #4]
    3290:	603b      	str	r3, [r7, #0]
	if (NULL != DM)
    3292:	4b11      	ldr	r3, [pc, #68]	@ (32d8 <VersionCommand(char const*, char const*, unsigned int, void const*)+0x54>)
    3294:	681b      	ldr	r3, [r3, #0]
    3296:	2b00      	cmp	r3, #0
    3298:	d00e      	beq.n	32b8 <VersionCommand(char const*, char const*, unsigned int, void const*)+0x34>
	{
		printf("\n\nVersion: Serial Number: %.8lX, Global Revision: %s; build number: %u on: %s; fpga build: %lu.\n", DM->DeviceSerialNumber, GITVERSION, BuildNum, BuildTimeStr, DM->FpgaFirmwareBuildNumber);
    329a:	4b0f      	ldr	r3, [pc, #60]	@ (32d8 <VersionCommand(char const*, char const*, unsigned int, void const*)+0x54>)
    329c:	681b      	ldr	r3, [r3, #0]
    329e:	6819      	ldr	r1, [r3, #0]
    32a0:	4b0d      	ldr	r3, [pc, #52]	@ (32d8 <VersionCommand(char const*, char const*, unsigned int, void const*)+0x54>)
    32a2:	681b      	ldr	r3, [r3, #0]
    32a4:	685b      	ldr	r3, [r3, #4]
    32a6:	9301      	str	r3, [sp, #4]
    32a8:	4b0c      	ldr	r3, [pc, #48]	@ (32dc <VersionCommand(char const*, char const*, unsigned int, void const*)+0x58>)
    32aa:	9300      	str	r3, [sp, #0]
    32ac:	23ee      	movs	r3, #238	@ 0xee
    32ae:	4a0c      	ldr	r2, [pc, #48]	@ (32e0 <VersionCommand(char const*, char const*, unsigned int, void const*)+0x5c>)
    32b0:	480c      	ldr	r0, [pc, #48]	@ (32e4 <VersionCommand(char const*, char const*, unsigned int, void const*)+0x60>)
    32b2:	f003 fe3b 	bl	6f2c <iprintf>
    32b6:	e005      	b.n	32c4 <VersionCommand(char const*, char const*, unsigned int, void const*)+0x40>
	}
	else
	{
		printf("\n\nVersion: Global Revision: %s; build number: %u on: %s.\n", GITVERSION, BuildNum, BuildTimeStr);
    32b8:	4b08      	ldr	r3, [pc, #32]	@ (32dc <VersionCommand(char const*, char const*, unsigned int, void const*)+0x58>)
    32ba:	22ee      	movs	r2, #238	@ 0xee
    32bc:	4908      	ldr	r1, [pc, #32]	@ (32e0 <VersionCommand(char const*, char const*, unsigned int, void const*)+0x5c>)
    32be:	480a      	ldr	r0, [pc, #40]	@ (32e8 <VersionCommand(char const*, char const*, unsigned int, void const*)+0x64>)
    32c0:	f003 fe34 	bl	6f2c <iprintf>
	}
	
    return(strlen(Params));
    32c4:	68b8      	ldr	r0, [r7, #8]
    32c6:	f004 f8d4 	bl	7472 <strlen>
    32ca:	4603      	mov	r3, r0
    32cc:	b25b      	sxtb	r3, r3
}
    32ce:	4618      	mov	r0, r3
    32d0:	3710      	adds	r7, #16
    32d2:	46bd      	mov	sp, r7
    32d4:	bd80      	pop	{r7, pc}
    32d6:	bf00      	nop
    32d8:	2000003c 	.word	0x2000003c
    32dc:	0000a8c8 	.word	0x0000a8c8
    32e0:	00009e30 	.word	0x00009e30
    32e4:	00009e5c 	.word	0x00009e5c
    32e8:	00009ec0 	.word	0x00009ec0

000032ec <ReadFpgaCommand(char const*, char const*, unsigned int, void const*)>:

int8_t ReadFpgaCommand(char const* Name, char const* Params, const size_t ParamsLen, const void* Argument)
{
    32ec:	b580      	push	{r7, lr}
    32ee:	b086      	sub	sp, #24
    32f0:	af00      	add	r7, sp, #0
    32f2:	60f8      	str	r0, [r7, #12]
    32f4:	60b9      	str	r1, [r7, #8]
    32f6:	607a      	str	r2, [r7, #4]
    32f8:	603b      	str	r3, [r7, #0]
	uint8_t FpgaRdBuf;

	//Convert parameter to an integer
    size_t addr = 0;
    32fa:	2300      	movs	r3, #0
    32fc:	613b      	str	r3, [r7, #16]
	int8_t numfound = sscanf(Params, "%zX", &addr);
    32fe:	f107 0310 	add.w	r3, r7, #16
    3302:	461a      	mov	r2, r3
    3304:	4924      	ldr	r1, [pc, #144]	@ (3398 <ReadFpgaCommand(char const*, char const*, unsigned int, void const*)+0xac>)
    3306:	68b8      	ldr	r0, [r7, #8]
    3308:	f003 febc 	bl	7084 <siscanf>
    330c:	4603      	mov	r3, r0
    330e:	75fb      	strb	r3, [r7, #23]
    if (numfound < 1)
    3310:	f997 3017 	ldrsb.w	r3, [r7, #23]
    3314:	2b00      	cmp	r3, #0
    3316:	dc20      	bgt.n	335a <ReadFpgaCommand(char const*, char const*, unsigned int, void const*)+0x6e>
    {
		printf("\nReadFpgaCommand: ");
    3318:	4820      	ldr	r0, [pc, #128]	@ (339c <ReadFpgaCommand(char const*, char const*, unsigned int, void const*)+0xb0>)
    331a:	f003 fe07 	bl	6f2c <iprintf>
		//~ for (addr = 0; addr <= 64; addr++)
		for (addr = 0; addr <= 128; addr++)
    331e:	2300      	movs	r3, #0
    3320:	613b      	str	r3, [r7, #16]
    3322:	e013      	b.n	334c <ReadFpgaCommand(char const*, char const*, unsigned int, void const*)+0x60>
		{
			FpgaRdBuf = *(((uint8_t*)DM)+addr);
    3324:	4b1e      	ldr	r3, [pc, #120]	@ (33a0 <ReadFpgaCommand(char const*, char const*, unsigned int, void const*)+0xb4>)
    3326:	681a      	ldr	r2, [r3, #0]
    3328:	693b      	ldr	r3, [r7, #16]
    332a:	4413      	add	r3, r2
    332c:	781b      	ldrb	r3, [r3, #0]
    332e:	75bb      	strb	r3, [r7, #22]
			printf("\n0x%.2zX: 0x%.2X ", addr, FpgaRdBuf);
    3330:	693b      	ldr	r3, [r7, #16]
    3332:	7dba      	ldrb	r2, [r7, #22]
    3334:	4619      	mov	r1, r3
    3336:	481b      	ldr	r0, [pc, #108]	@ (33a4 <ReadFpgaCommand(char const*, char const*, unsigned int, void const*)+0xb8>)
    3338:	f003 fdf8 	bl	6f2c <iprintf>
			printf("[%u]", FpgaRdBuf);
    333c:	7dbb      	ldrb	r3, [r7, #22]
    333e:	4619      	mov	r1, r3
    3340:	4819      	ldr	r0, [pc, #100]	@ (33a8 <ReadFpgaCommand(char const*, char const*, unsigned int, void const*)+0xbc>)
    3342:	f003 fdf3 	bl	6f2c <iprintf>
		for (addr = 0; addr <= 128; addr++)
    3346:	693b      	ldr	r3, [r7, #16]
    3348:	3301      	adds	r3, #1
    334a:	613b      	str	r3, [r7, #16]
    334c:	693b      	ldr	r3, [r7, #16]
    334e:	2b80      	cmp	r3, #128	@ 0x80
    3350:	d9e8      	bls.n	3324 <ReadFpgaCommand(char const*, char const*, unsigned int, void const*)+0x38>
			//~ printf(" ('%c')", FpgaRdBuf);
		}	
		printf("\n\n");
    3352:	4816      	ldr	r0, [pc, #88]	@ (33ac <ReadFpgaCommand(char const*, char const*, unsigned int, void const*)+0xc0>)
    3354:	f003 fe8e 	bl	7074 <puts>
    3358:	e018      	b.n	338c <ReadFpgaCommand(char const*, char const*, unsigned int, void const*)+0xa0>
    }
	else
	{
		FpgaRdBuf = *(((uint8_t*)DM)+addr);
    335a:	4b11      	ldr	r3, [pc, #68]	@ (33a0 <ReadFpgaCommand(char const*, char const*, unsigned int, void const*)+0xb4>)
    335c:	681a      	ldr	r2, [r3, #0]
    335e:	693b      	ldr	r3, [r7, #16]
    3360:	4413      	add	r3, r2
    3362:	781b      	ldrb	r3, [r3, #0]
    3364:	75bb      	strb	r3, [r7, #22]
		printf("\nReadFpgaCommand: ");
    3366:	480d      	ldr	r0, [pc, #52]	@ (339c <ReadFpgaCommand(char const*, char const*, unsigned int, void const*)+0xb0>)
    3368:	f003 fde0 	bl	6f2c <iprintf>
		//~ printf("\n%zu: 0x%.2X ", addr, FpgaRdBuf);
		printf("\n0x%.2zX: 0x%.2X ", addr, FpgaRdBuf);
    336c:	693b      	ldr	r3, [r7, #16]
    336e:	7dba      	ldrb	r2, [r7, #22]
    3370:	4619      	mov	r1, r3
    3372:	480c      	ldr	r0, [pc, #48]	@ (33a4 <ReadFpgaCommand(char const*, char const*, unsigned int, void const*)+0xb8>)
    3374:	f003 fdda 	bl	6f2c <iprintf>
		printf("[%u]", FpgaRdBuf);
    3378:	7dbb      	ldrb	r3, [r7, #22]
    337a:	4619      	mov	r1, r3
    337c:	480a      	ldr	r0, [pc, #40]	@ (33a8 <ReadFpgaCommand(char const*, char const*, unsigned int, void const*)+0xbc>)
    337e:	f003 fdd5 	bl	6f2c <iprintf>
		printf(" ('%c')\n\n", FpgaRdBuf);
    3382:	7dbb      	ldrb	r3, [r7, #22]
    3384:	4619      	mov	r1, r3
    3386:	480a      	ldr	r0, [pc, #40]	@ (33b0 <ReadFpgaCommand(char const*, char const*, unsigned int, void const*)+0xc4>)
    3388:	f003 fdd0 	bl	6f2c <iprintf>
	}
	
	return(ParamsLen);
    338c:	687b      	ldr	r3, [r7, #4]
    338e:	b25b      	sxtb	r3, r3
}
    3390:	4618      	mov	r0, r3
    3392:	3718      	adds	r7, #24
    3394:	46bd      	mov	sp, r7
    3396:	bd80      	pop	{r7, pc}
    3398:	00009efc 	.word	0x00009efc
    339c:	00009f00 	.word	0x00009f00
    33a0:	2000003c 	.word	0x2000003c
    33a4:	00009f14 	.word	0x00009f14
    33a8:	00009f28 	.word	0x00009f28
    33ac:	00009dcc 	.word	0x00009dcc
    33b0:	00009f30 	.word	0x00009f30

000033b4 <WriteFpgaCommand(char const*, char const*, unsigned int, void const*)>:

int8_t WriteFpgaCommand(char const* Name, char const* Params, const size_t ParamsLen, const void* Argument)
{
    33b4:	b580      	push	{r7, lr}
    33b6:	b088      	sub	sp, #32
    33b8:	af00      	add	r7, sp, #0
    33ba:	60f8      	str	r0, [r7, #12]
    33bc:	60b9      	str	r1, [r7, #8]
    33be:	607a      	str	r2, [r7, #4]
    33c0:	603b      	str	r3, [r7, #0]
	//Convert parameter to an integer
	size_t addr = 0;
    33c2:	2300      	movs	r3, #0
    33c4:	61bb      	str	r3, [r7, #24]
    unsigned long val = 0;
    33c6:	2300      	movs	r3, #0
    33c8:	617b      	str	r3, [r7, #20]
    int8_t numfound = sscanf(Params, "%zX %lu", &addr, &val);
    33ca:	f107 0314 	add.w	r3, r7, #20
    33ce:	f107 0218 	add.w	r2, r7, #24
    33d2:	4915      	ldr	r1, [pc, #84]	@ (3428 <WriteFpgaCommand(char const*, char const*, unsigned int, void const*)+0x74>)
    33d4:	68b8      	ldr	r0, [r7, #8]
    33d6:	f003 fe55 	bl	7084 <siscanf>
    33da:	4603      	mov	r3, r0
    33dc:	77fb      	strb	r3, [r7, #31]
    if (numfound < 2)
    33de:	f997 301f 	ldrsb.w	r3, [r7, #31]
    33e2:	2b01      	cmp	r3, #1
    33e4:	dc09      	bgt.n	33fa <WriteFpgaCommand(char const*, char const*, unsigned int, void const*)+0x46>
    {
		printf("\nWriteFpgaCommand: need 2 numeric parameters (address and value), got \"%s\" (%d params).\n", Params, numfound);
    33e6:	f997 301f 	ldrsb.w	r3, [r7, #31]
    33ea:	461a      	mov	r2, r3
    33ec:	68b9      	ldr	r1, [r7, #8]
    33ee:	480f      	ldr	r0, [pc, #60]	@ (342c <WriteFpgaCommand(char const*, char const*, unsigned int, void const*)+0x78>)
    33f0:	f003 fd9c 	bl	6f2c <iprintf>
        return(-1);
    33f4:	f04f 33ff 	mov.w	r3, #4294967295
    33f8:	e012      	b.n	3420 <WriteFpgaCommand(char const*, char const*, unsigned int, void const*)+0x6c>
    }

	//Write data to fpga:
	*(((uint8_t*)DM)+addr) = (uint8_t)val;
    33fa:	6979      	ldr	r1, [r7, #20]
    33fc:	4b0c      	ldr	r3, [pc, #48]	@ (3430 <WriteFpgaCommand(char const*, char const*, unsigned int, void const*)+0x7c>)
    33fe:	681a      	ldr	r2, [r3, #0]
    3400:	69bb      	ldr	r3, [r7, #24]
    3402:	4413      	add	r3, r2
    3404:	b2ca      	uxtb	r2, r1
    3406:	701a      	strb	r2, [r3, #0]

	printf("\nWriteFpgaCommand: Wrote %lu to ", val);
    3408:	697b      	ldr	r3, [r7, #20]
    340a:	4619      	mov	r1, r3
    340c:	4809      	ldr	r0, [pc, #36]	@ (3434 <WriteFpgaCommand(char const*, char const*, unsigned int, void const*)+0x80>)
    340e:	f003 fd8d 	bl	6f2c <iprintf>
	printf("0x%.4zX.\n", addr);
    3412:	69bb      	ldr	r3, [r7, #24]
    3414:	4619      	mov	r1, r3
    3416:	4808      	ldr	r0, [pc, #32]	@ (3438 <WriteFpgaCommand(char const*, char const*, unsigned int, void const*)+0x84>)
    3418:	f003 fd88 	bl	6f2c <iprintf>
	
	return(ParamsLen);
    341c:	687b      	ldr	r3, [r7, #4]
    341e:	b25b      	sxtb	r3, r3
}
    3420:	4618      	mov	r0, r3
    3422:	3720      	adds	r7, #32
    3424:	46bd      	mov	sp, r7
    3426:	bd80      	pop	{r7, pc}
    3428:	00009f3c 	.word	0x00009f3c
    342c:	00009f44 	.word	0x00009f44
    3430:	2000003c 	.word	0x2000003c
    3434:	00009fa0 	.word	0x00009fa0
    3438:	00009fc4 	.word	0x00009fc4
    343c:	00000000 	.word	0x00000000

00003440 <DMDacCommand(char const*, char const*, unsigned int, void const*)>:


int8_t DMDacCommand(char const* Name, char const* Params, const size_t ParamsLen, const void* Argument)
{
    3440:	b5f0      	push	{r4, r5, r6, r7, lr}
    3442:	b0af      	sub	sp, #188	@ 0xbc
    3444:	af10      	add	r7, sp, #64	@ 0x40
    3446:	62f8      	str	r0, [r7, #44]	@ 0x2c
    3448:	62b9      	str	r1, [r7, #40]	@ 0x28
    344a:	627a      	str	r2, [r7, #36]	@ 0x24
    344c:	623b      	str	r3, [r7, #32]
    unsigned long A = 0, B = 0, C = 0;	
    344e:	2300      	movs	r3, #0
    3450:	657b      	str	r3, [r7, #84]	@ 0x54
    3452:	2300      	movs	r3, #0
    3454:	653b      	str	r3, [r7, #80]	@ 0x50
    3456:	2300      	movs	r3, #0
    3458:	64fb      	str	r3, [r7, #76]	@ 0x4c
    if (NULL == DM) {
    345a:	4b73      	ldr	r3, [pc, #460]	@ (3628 <DMDacCommand(char const*, char const*, unsigned int, void const*)+0x1e8>)
    345c:	681b      	ldr	r3, [r3, #0]
    345e:	2b00      	cmp	r3, #0
    3460:	d105      	bne.n	346e <DMDacCommand(char const*, char const*, unsigned int, void const*)+0x2e>
      printf("\n\nDMDacs: Fpga interface is not initialized! Please call InitFpga first!.");
    3462:	4872      	ldr	r0, [pc, #456]	@ (362c <DMDacCommand(char const*, char const*, unsigned int, void const*)+0x1ec>)
    3464:	f003 fd62 	bl	6f2c <iprintf>
      return(ParamsLen);
    3468:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    346a:	b25b      	sxtb	r3, r3
    346c:	e0d1      	b.n	3612 <DMDacCommand(char const*, char const*, unsigned int, void const*)+0x1d2>
    }
	
    //Convert parameters
    int8_t numfound = sscanf(Params, "%lx,%lx,%lx", &A, &B, &C);
    346e:	f107 0150 	add.w	r1, r7, #80	@ 0x50
    3472:	f107 0254 	add.w	r2, r7, #84	@ 0x54
    3476:	f107 034c 	add.w	r3, r7, #76	@ 0x4c
    347a:	9300      	str	r3, [sp, #0]
    347c:	460b      	mov	r3, r1
    347e:	496c      	ldr	r1, [pc, #432]	@ (3630 <DMDacCommand(char const*, char const*, unsigned int, void const*)+0x1f0>)
    3480:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
    3482:	f003 fdff 	bl	7084 <siscanf>
    3486:	4603      	mov	r3, r0
    3488:	f887 3077 	strb.w	r3, [r7, #119]	@ 0x77
    if (numfound >= 3) {
    348c:	f997 3077 	ldrsb.w	r3, [r7, #119]	@ 0x77
    3490:	2b02      	cmp	r3, #2
    3492:	dd08      	ble.n	34a6 <DMDacCommand(char const*, char const*, unsigned int, void const*)+0x66>
//      DM->DacASetpoint = A;
//      DM->DacBSetpoint = B;
//      DM->DacCSetpoint = C;
      printf("\n\nDMDacs: set to: %lx, %lx, %lx.\n", A, B, C);
    3494:	6d79      	ldr	r1, [r7, #84]	@ 0x54
    3496:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
    3498:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
    349a:	4866      	ldr	r0, [pc, #408]	@ (3634 <DMDacCommand(char const*, char const*, unsigned int, void const*)+0x1f4>)
    349c:	f003 fd46 	bl	6f2c <iprintf>
      return(ParamsLen);
    34a0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    34a2:	b25b      	sxtb	r3, r3
    34a4:	e0b5      	b.n	3612 <DMDacCommand(char const*, char const*, unsigned int, void const*)+0x1d2>
    }
    if (numfound >= 1) {
    34a6:	f997 3077 	ldrsb.w	r3, [r7, #119]	@ 0x77
    34aa:	2b00      	cmp	r3, #0
    34ac:	dd08      	ble.n	34c0 <DMDacCommand(char const*, char const*, unsigned int, void const*)+0x80>
//      DM->DacASetpoint = A;
//      DM->DacBSetpoint = A;
//      //~ DM->DacBSetpoint = 0x006FFFFFUL; //Sometimes this is 100V
//      //~ DM->DacBSetpoint = 0x00CFFFFFUL; //Aaaaaand, sometimes this is 100V
//      DM->DacCSetpoint = A;
      printf("\n\nDMDacs: set to: %lx, %lx, %lx.\n", A, A, A);
    34ae:	6d79      	ldr	r1, [r7, #84]	@ 0x54
    34b0:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
    34b2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
    34b4:	485f      	ldr	r0, [pc, #380]	@ (3634 <DMDacCommand(char const*, char const*, unsigned int, void const*)+0x1f4>)
    34b6:	f003 fd39 	bl	6f2c <iprintf>
      return(ParamsLen);
    34ba:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    34bc:	b25b      	sxtb	r3, r3
    34be:	e0a8      	b.n	3612 <DMDacCommand(char const*, char const*, unsigned int, void const*)+0x1d2>
    }

//    A = DM->DacASetpoint;
//    B = DM->DacBSetpoint;
//    C = DM->DacCSetpoint;
    printf("\n\nDMDacs: current value: %lx, %lx, %lx.\n", A, B, C);
    34c0:	6d79      	ldr	r1, [r7, #84]	@ 0x54
    34c2:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
    34c4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
    34c6:	485c      	ldr	r0, [pc, #368]	@ (3638 <DMDacCommand(char const*, char const*, unsigned int, void const*)+0x1f8>)
    34c8:	f003 fd30 	bl	6f2c <iprintf>
	
    //Show current A/D values:
    {
      AdcAccumulator Aa, Ba, Ca;
    34cc:	f107 0344 	add.w	r3, r7, #68	@ 0x44
    34d0:	4618      	mov	r0, r3
    34d2:	f7ff fde0 	bl	3096 <AdcAccumulator::AdcAccumulator()>
    34d6:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
    34da:	4618      	mov	r0, r3
    34dc:	f7ff fddb 	bl	3096 <AdcAccumulator::AdcAccumulator()>
    34e0:	f107 0334 	add.w	r3, r7, #52	@ 0x34
    34e4:	4618      	mov	r0, r3
    34e6:	f7ff fdd6 	bl	3096 <AdcAccumulator::AdcAccumulator()>
//      Aa = DM->AdcAAccumulator;
//      Ba = DM->AdcBAccumulator;
//      Ca = DM->AdcCAccumulator;
      
      double Av, Bv, Cv;
      Av = (8.192 * ((Aa.Samples - 0) / Aa.NumAccums)) / 16777216.0;
    34ea:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
    34ec:	f343 0317 	sbfx	r3, r3, #0, #24
    34f0:	461a      	mov	r2, r3
    34f2:	f8b7 304a 	ldrh.w	r3, [r7, #74]	@ 0x4a
    34f6:	fb92 f3f3 	sdiv	r3, r2, r3
    34fa:	4618      	mov	r0, r3
    34fc:	f005 fa3e 	bl	897c <__aeabi_i2d>
    3500:	a347      	add	r3, pc, #284	@ (adr r3, 3620 <DMDacCommand(char const*, char const*, unsigned int, void const*)+0x1e0>)
    3502:	e9d3 2300 	ldrd	r2, r3, [r3]
    3506:	f005 faa3 	bl	8a50 <__aeabi_dmul>
    350a:	4602      	mov	r2, r0
    350c:	460b      	mov	r3, r1
    350e:	4610      	mov	r0, r2
    3510:	4619      	mov	r1, r3
    3512:	f04f 0200 	mov.w	r2, #0
    3516:	4b49      	ldr	r3, [pc, #292]	@ (363c <DMDacCommand(char const*, char const*, unsigned int, void const*)+0x1fc>)
    3518:	f005 fbc4 	bl	8ca4 <__aeabi_ddiv>
    351c:	4602      	mov	r2, r0
    351e:	460b      	mov	r3, r1
    3520:	e9c7 231a 	strd	r2, r3, [r7, #104]	@ 0x68
      Bv = (8.192 * ((Ba.Samples - 0) / Ba.NumAccums)) / 16777216.0;
    3524:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
    3526:	f343 0317 	sbfx	r3, r3, #0, #24
    352a:	461a      	mov	r2, r3
    352c:	f8b7 3042 	ldrh.w	r3, [r7, #66]	@ 0x42
    3530:	fb92 f3f3 	sdiv	r3, r2, r3
    3534:	4618      	mov	r0, r3
    3536:	f005 fa21 	bl	897c <__aeabi_i2d>
    353a:	a339      	add	r3, pc, #228	@ (adr r3, 3620 <DMDacCommand(char const*, char const*, unsigned int, void const*)+0x1e0>)
    353c:	e9d3 2300 	ldrd	r2, r3, [r3]
    3540:	f005 fa86 	bl	8a50 <__aeabi_dmul>
    3544:	4602      	mov	r2, r0
    3546:	460b      	mov	r3, r1
    3548:	4610      	mov	r0, r2
    354a:	4619      	mov	r1, r3
    354c:	f04f 0200 	mov.w	r2, #0
    3550:	4b3a      	ldr	r3, [pc, #232]	@ (363c <DMDacCommand(char const*, char const*, unsigned int, void const*)+0x1fc>)
    3552:	f005 fba7 	bl	8ca4 <__aeabi_ddiv>
    3556:	4602      	mov	r2, r0
    3558:	460b      	mov	r3, r1
    355a:	e9c7 2318 	strd	r2, r3, [r7, #96]	@ 0x60
      Cv = (8.192 * ((Ca.Samples - 0) / Ca.NumAccums)) / 16777216.0;
    355e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    3560:	f343 0317 	sbfx	r3, r3, #0, #24
    3564:	461a      	mov	r2, r3
    3566:	8f7b      	ldrh	r3, [r7, #58]	@ 0x3a
    3568:	fb92 f3f3 	sdiv	r3, r2, r3
    356c:	4618      	mov	r0, r3
    356e:	f005 fa05 	bl	897c <__aeabi_i2d>
    3572:	a32b      	add	r3, pc, #172	@ (adr r3, 3620 <DMDacCommand(char const*, char const*, unsigned int, void const*)+0x1e0>)
    3574:	e9d3 2300 	ldrd	r2, r3, [r3]
    3578:	f005 fa6a 	bl	8a50 <__aeabi_dmul>
    357c:	4602      	mov	r2, r0
    357e:	460b      	mov	r3, r1
    3580:	4610      	mov	r0, r2
    3582:	4619      	mov	r1, r3
    3584:	f04f 0200 	mov.w	r2, #0
    3588:	4b2c      	ldr	r3, [pc, #176]	@ (363c <DMDacCommand(char const*, char const*, unsigned int, void const*)+0x1fc>)
    358a:	f005 fb8b 	bl	8ca4 <__aeabi_ddiv>
    358e:	4602      	mov	r2, r0
    3590:	460b      	mov	r3, r1
    3592:	e9c7 2316 	strd	r2, r3, [r7, #88]	@ 0x58
      printf("\nDMDacs: Sensor A/D's: 0x%016llx, 0x%016llx, 0x%016llx; %+d(%u), %+d(%u), %+d(%u), %+1.3lf, %+1.3lf, %+1.3lf\n", Aa.all, Ba.all, Ca.all, Aa.Samples, Aa.NumAccums, Ba.Samples, Ba.NumAccums, Ca.Samples, Ca.NumAccums, Av, Bv, Cv);
    3596:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
    3598:	61bb      	str	r3, [r7, #24]
    359a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
    359c:	61fb      	str	r3, [r7, #28]
    359e:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
    35a0:	6c39      	ldr	r1, [r7, #64]	@ 0x40
    35a2:	6b7c      	ldr	r4, [r7, #52]	@ 0x34
    35a4:	6bbd      	ldr	r5, [r7, #56]	@ 0x38
    35a6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
    35a8:	f343 0317 	sbfx	r3, r3, #0, #24
    35ac:	461e      	mov	r6, r3
    35ae:	f8b7 304a 	ldrh.w	r3, [r7, #74]	@ 0x4a
    35b2:	617b      	str	r3, [r7, #20]
    35b4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
    35b6:	f343 0317 	sbfx	r3, r3, #0, #24
    35ba:	613b      	str	r3, [r7, #16]
    35bc:	f8b7 3042 	ldrh.w	r3, [r7, #66]	@ 0x42
    35c0:	60fb      	str	r3, [r7, #12]
    35c2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    35c4:	f343 0317 	sbfx	r3, r3, #0, #24
    35c8:	60bb      	str	r3, [r7, #8]
    35ca:	8f7b      	ldrh	r3, [r7, #58]	@ 0x3a
    35cc:	607b      	str	r3, [r7, #4]
    35ce:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	@ 0x58
    35d2:	e9cd 230e 	strd	r2, r3, [sp, #56]	@ 0x38
    35d6:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
    35da:	e9cd 230c 	strd	r2, r3, [sp, #48]	@ 0x30
    35de:	e9d7 231a 	ldrd	r2, r3, [r7, #104]	@ 0x68
    35e2:	e9cd 230a 	strd	r2, r3, [sp, #40]	@ 0x28
    35e6:	687a      	ldr	r2, [r7, #4]
    35e8:	9209      	str	r2, [sp, #36]	@ 0x24
    35ea:	68ba      	ldr	r2, [r7, #8]
    35ec:	9208      	str	r2, [sp, #32]
    35ee:	68fa      	ldr	r2, [r7, #12]
    35f0:	9207      	str	r2, [sp, #28]
    35f2:	693a      	ldr	r2, [r7, #16]
    35f4:	9206      	str	r2, [sp, #24]
    35f6:	697b      	ldr	r3, [r7, #20]
    35f8:	9305      	str	r3, [sp, #20]
    35fa:	9604      	str	r6, [sp, #16]
    35fc:	e9cd 4502 	strd	r4, r5, [sp, #8]
    3600:	e9cd 0100 	strd	r0, r1, [sp]
    3604:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
    3608:	480d      	ldr	r0, [pc, #52]	@ (3640 <DMDacCommand(char const*, char const*, unsigned int, void const*)+0x200>)
    360a:	f003 fc8f 	bl	6f2c <iprintf>
    }
	
    return(ParamsLen);
    360e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    3610:	b25b      	sxtb	r3, r3
}
    3612:	4618      	mov	r0, r3
    3614:	377c      	adds	r7, #124	@ 0x7c
    3616:	46bd      	mov	sp, r7
    3618:	bdf0      	pop	{r4, r5, r6, r7, pc}
    361a:	bf00      	nop
    361c:	f3af 8000 	nop.w
    3620:	d2f1a9fc 	.word	0xd2f1a9fc
    3624:	4020624d 	.word	0x4020624d
    3628:	2000003c 	.word	0x2000003c
    362c:	00009fd0 	.word	0x00009fd0
    3630:	0000a01c 	.word	0x0000a01c
    3634:	0000a028 	.word	0x0000a028
    3638:	0000a04c 	.word	0x0000a04c
    363c:	41700000 	.word	0x41700000
    3640:	0000a078 	.word	0x0000a078
    3644:	00000000 	.word	0x00000000

00003648 <DMAdcsCommand(char const*, char const*, unsigned int, void const*)>:
//	
//	return(ParamsLen);	
//}

int8_t DMAdcsCommand(char const* Name, char const* Params, const size_t ParamsLen, const void* Argument)
{
    3648:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    364c:	b0a7      	sub	sp, #156	@ 0x9c
    364e:	af10      	add	r7, sp, #64	@ 0x40
    3650:	6278      	str	r0, [r7, #36]	@ 0x24
    3652:	6239      	str	r1, [r7, #32]
    3654:	61fa      	str	r2, [r7, #28]
    3656:	61bb      	str	r3, [r7, #24]
  //~ size_t cycle = 0;
  //~ int key = 0;

  if (NULL == DM) {
    3658:	4b57      	ldr	r3, [pc, #348]	@ (37b8 <DMAdcsCommand(char const*, char const*, unsigned int, void const*)+0x170>)
    365a:	681b      	ldr	r3, [r3, #0]
    365c:	2b00      	cmp	r3, #0
    365e:	d105      	bne.n	366c <DMAdcsCommand(char const*, char const*, unsigned int, void const*)+0x24>
    printf("\n\nDMAdcs: Fpga interface is not initialized! Please call InitFpga first!.");
    3660:	4856      	ldr	r0, [pc, #344]	@ (37bc <DMAdcsCommand(char const*, char const*, unsigned int, void const*)+0x174>)
    3662:	f003 fc63 	bl	6f2c <iprintf>
    return(ParamsLen);
    3666:	69fb      	ldr	r3, [r7, #28]
    3668:	b25b      	sxtb	r3, r3
    366a:	e09c      	b.n	37a6 <DMAdcsCommand(char const*, char const*, unsigned int, void const*)+0x15e>
  }
	
  {
    AdcAccumulator A, B, C;
    366c:	f107 0338 	add.w	r3, r7, #56	@ 0x38
    3670:	4618      	mov	r0, r3
    3672:	f7ff fd10 	bl	3096 <AdcAccumulator::AdcAccumulator()>
    3676:	f107 0330 	add.w	r3, r7, #48	@ 0x30
    367a:	4618      	mov	r0, r3
    367c:	f7ff fd0b 	bl	3096 <AdcAccumulator::AdcAccumulator()>
    3680:	f107 0328 	add.w	r3, r7, #40	@ 0x28
    3684:	4618      	mov	r0, r3
    3686:	f7ff fd06 	bl	3096 <AdcAccumulator::AdcAccumulator()>
//    A = DM->AdcAAccumulator;
//    B = DM->AdcBAccumulator;
//    C = DM->AdcCAccumulator;
    
    double Av, Bv, Cv;
    Av = (8.192 * ((A.Samples - 0) / A.NumAccums)) / 16777216.0;
    368a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
    368c:	f343 0317 	sbfx	r3, r3, #0, #24
    3690:	461a      	mov	r2, r3
    3692:	8ffb      	ldrh	r3, [r7, #62]	@ 0x3e
    3694:	fb92 f3f3 	sdiv	r3, r2, r3
    3698:	4618      	mov	r0, r3
    369a:	f005 f96f 	bl	897c <__aeabi_i2d>
    369e:	a344      	add	r3, pc, #272	@ (adr r3, 37b0 <DMAdcsCommand(char const*, char const*, unsigned int, void const*)+0x168>)
    36a0:	e9d3 2300 	ldrd	r2, r3, [r3]
    36a4:	f005 f9d4 	bl	8a50 <__aeabi_dmul>
    36a8:	4602      	mov	r2, r0
    36aa:	460b      	mov	r3, r1
    36ac:	4610      	mov	r0, r2
    36ae:	4619      	mov	r1, r3
    36b0:	f04f 0200 	mov.w	r2, #0
    36b4:	4b42      	ldr	r3, [pc, #264]	@ (37c0 <DMAdcsCommand(char const*, char const*, unsigned int, void const*)+0x178>)
    36b6:	f005 faf5 	bl	8ca4 <__aeabi_ddiv>
    36ba:	4602      	mov	r2, r0
    36bc:	460b      	mov	r3, r1
    36be:	e9c7 2314 	strd	r2, r3, [r7, #80]	@ 0x50
    Bv = (8.192 * ((B.Samples - 0) / B.NumAccums)) / 16777216.0;
    36c2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    36c4:	f343 0317 	sbfx	r3, r3, #0, #24
    36c8:	461a      	mov	r2, r3
    36ca:	8efb      	ldrh	r3, [r7, #54]	@ 0x36
    36cc:	fb92 f3f3 	sdiv	r3, r2, r3
    36d0:	4618      	mov	r0, r3
    36d2:	f005 f953 	bl	897c <__aeabi_i2d>
    36d6:	a336      	add	r3, pc, #216	@ (adr r3, 37b0 <DMAdcsCommand(char const*, char const*, unsigned int, void const*)+0x168>)
    36d8:	e9d3 2300 	ldrd	r2, r3, [r3]
    36dc:	f005 f9b8 	bl	8a50 <__aeabi_dmul>
    36e0:	4602      	mov	r2, r0
    36e2:	460b      	mov	r3, r1
    36e4:	4610      	mov	r0, r2
    36e6:	4619      	mov	r1, r3
    36e8:	f04f 0200 	mov.w	r2, #0
    36ec:	4b34      	ldr	r3, [pc, #208]	@ (37c0 <DMAdcsCommand(char const*, char const*, unsigned int, void const*)+0x178>)
    36ee:	f005 fad9 	bl	8ca4 <__aeabi_ddiv>
    36f2:	4602      	mov	r2, r0
    36f4:	460b      	mov	r3, r1
    36f6:	e9c7 2312 	strd	r2, r3, [r7, #72]	@ 0x48
    Cv = (8.192 * ((C.Samples - 0) / C.NumAccums)) / 16777216.0;
    36fa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    36fc:	f343 0317 	sbfx	r3, r3, #0, #24
    3700:	461a      	mov	r2, r3
    3702:	8dfb      	ldrh	r3, [r7, #46]	@ 0x2e
    3704:	fb92 f3f3 	sdiv	r3, r2, r3
    3708:	4618      	mov	r0, r3
    370a:	f005 f937 	bl	897c <__aeabi_i2d>
    370e:	a328      	add	r3, pc, #160	@ (adr r3, 37b0 <DMAdcsCommand(char const*, char const*, unsigned int, void const*)+0x168>)
    3710:	e9d3 2300 	ldrd	r2, r3, [r3]
    3714:	f005 f99c 	bl	8a50 <__aeabi_dmul>
    3718:	4602      	mov	r2, r0
    371a:	460b      	mov	r3, r1
    371c:	4610      	mov	r0, r2
    371e:	4619      	mov	r1, r3
    3720:	f04f 0200 	mov.w	r2, #0
    3724:	4b26      	ldr	r3, [pc, #152]	@ (37c0 <DMAdcsCommand(char const*, char const*, unsigned int, void const*)+0x178>)
    3726:	f005 fabd 	bl	8ca4 <__aeabi_ddiv>
    372a:	4602      	mov	r2, r0
    372c:	460b      	mov	r3, r1
    372e:	e9c7 2310 	strd	r2, r3, [r7, #64]	@ 0x40
			
    printf("\nDMAdcs: current values: 0x%016llx, 0x%016llx, 0x%016llx; %+d(%u), %+d(%u), %+d(%u), %+1.3lf, %+1.3lf, %+1.3lf\n", A.all, B.all, C.all, A.Samples, A.NumAccums, B.Samples, B.NumAccums, C.Samples, C.NumAccums, Av, Bv, Cv);
    3732:	e9d7 890e 	ldrd	r8, r9, [r7, #56]	@ 0x38
    3736:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	@ 0x30
    373a:	e9d7 450a 	ldrd	r4, r5, [r7, #40]	@ 0x28
    373e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
    3740:	f343 0317 	sbfx	r3, r3, #0, #24
    3744:	461e      	mov	r6, r3
    3746:	8ffb      	ldrh	r3, [r7, #62]	@ 0x3e
    3748:	617b      	str	r3, [r7, #20]
    374a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    374c:	f343 0317 	sbfx	r3, r3, #0, #24
    3750:	613b      	str	r3, [r7, #16]
    3752:	8efb      	ldrh	r3, [r7, #54]	@ 0x36
    3754:	60fb      	str	r3, [r7, #12]
    3756:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    3758:	f343 0317 	sbfx	r3, r3, #0, #24
    375c:	60bb      	str	r3, [r7, #8]
    375e:	8dfb      	ldrh	r3, [r7, #46]	@ 0x2e
    3760:	607b      	str	r3, [r7, #4]
    3762:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
    3766:	e9cd 230e 	strd	r2, r3, [sp, #56]	@ 0x38
    376a:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	@ 0x48
    376e:	e9cd 230c 	strd	r2, r3, [sp, #48]	@ 0x30
    3772:	e9d7 2314 	ldrd	r2, r3, [r7, #80]	@ 0x50
    3776:	e9cd 230a 	strd	r2, r3, [sp, #40]	@ 0x28
    377a:	687a      	ldr	r2, [r7, #4]
    377c:	9209      	str	r2, [sp, #36]	@ 0x24
    377e:	68ba      	ldr	r2, [r7, #8]
    3780:	9208      	str	r2, [sp, #32]
    3782:	68fa      	ldr	r2, [r7, #12]
    3784:	9207      	str	r2, [sp, #28]
    3786:	693a      	ldr	r2, [r7, #16]
    3788:	9206      	str	r2, [sp, #24]
    378a:	697b      	ldr	r3, [r7, #20]
    378c:	9305      	str	r3, [sp, #20]
    378e:	9604      	str	r6, [sp, #16]
    3790:	e9cd 4502 	strd	r4, r5, [sp, #8]
    3794:	e9cd 0100 	strd	r0, r1, [sp]
    3798:	4642      	mov	r2, r8
    379a:	464b      	mov	r3, r9
    379c:	4809      	ldr	r0, [pc, #36]	@ (37c4 <DMAdcsCommand(char const*, char const*, unsigned int, void const*)+0x17c>)
    379e:	f003 fbc5 	bl	6f2c <iprintf>
  }
		
  return(ParamsLen);
    37a2:	69fb      	ldr	r3, [r7, #28]
    37a4:	b25b      	sxtb	r3, r3
}
    37a6:	4618      	mov	r0, r3
    37a8:	375c      	adds	r7, #92	@ 0x5c
    37aa:	46bd      	mov	sp, r7
    37ac:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    37b0:	d2f1a9fc 	.word	0xd2f1a9fc
    37b4:	4020624d 	.word	0x4020624d
    37b8:	2000003c 	.word	0x2000003c
    37bc:	0000a0e8 	.word	0x0000a0e8
    37c0:	41700000 	.word	0x41700000
    37c4:	0000a134 	.word	0x0000a134

000037c8 <BISTCommand(char const*, char const*, unsigned int, void const*)>:

int8_t BISTCommand(char const* Name, char const* Params, const size_t ParamsLen, const void* Argument)
{
    37c8:	b580      	push	{r7, lr}
    37ca:	b088      	sub	sp, #32
    37cc:	af00      	add	r7, sp, #0
    37ce:	60f8      	str	r0, [r7, #12]
    37d0:	60b9      	str	r1, [r7, #8]
    37d2:	607a      	str	r2, [r7, #4]
    37d4:	603b      	str	r3, [r7, #0]
  size_t cycle = 0;
    37d6:	2300      	movs	r3, #0
    37d8:	61fb      	str	r3, [r7, #28]
  //~ unsigned long daca = 0;
  int key = 0;
    37da:	2300      	movs	r3, #0
    37dc:	61bb      	str	r3, [r7, #24]
	
  while(true) {
    cycle++;
    37de:	69fb      	ldr	r3, [r7, #28]
    37e0:	3301      	adds	r3, #1
    37e2:	61fb      	str	r3, [r7, #28]
		
    {
      size_t j = cycle % 12;
    37e4:	69fa      	ldr	r2, [r7, #28]
    37e6:	4b0d      	ldr	r3, [pc, #52]	@ (381c <BISTCommand(char const*, char const*, unsigned int, void const*)+0x54>)
    37e8:	fba3 1302 	umull	r1, r3, r3, r2
    37ec:	08d9      	lsrs	r1, r3, #3
    37ee:	460b      	mov	r3, r1
    37f0:	005b      	lsls	r3, r3, #1
    37f2:	440b      	add	r3, r1
    37f4:	009b      	lsls	r3, r3, #2
    37f6:	1ad3      	subs	r3, r2, r3
    37f8:	617b      	str	r3, [r7, #20]
		
    //Quit on any keypress
    {
      //~ if (0 != key) 
      { 
        fflush(stdin);
    37fa:	4b09      	ldr	r3, [pc, #36]	@ (3820 <BISTCommand(char const*, char const*, unsigned int, void const*)+0x58>)
    37fc:	681b      	ldr	r3, [r3, #0]
    37fe:	685b      	ldr	r3, [r3, #4]
    3800:	4618      	mov	r0, r3
    3802:	f003 fabb 	bl	6d7c <fflush>
        printf("\n\nBIST: Keypress(%d); exiting.\n", key);
    3806:	69b9      	ldr	r1, [r7, #24]
    3808:	4806      	ldr	r0, [pc, #24]	@ (3824 <BISTCommand(char const*, char const*, unsigned int, void const*)+0x5c>)
    380a:	f003 fb8f 	bl	6f2c <iprintf>
        break; 
    380e:	bf00      	nop
    }

    //~ DelayMs(10);
  }
	
  return(ParamsLen);
    3810:	687b      	ldr	r3, [r7, #4]
    3812:	b25b      	sxtb	r3, r3
}
    3814:	4618      	mov	r0, r3
    3816:	3720      	adds	r7, #32
    3818:	46bd      	mov	sp, r7
    381a:	bd80      	pop	{r7, pc}
    381c:	aaaaaaab 	.word	0xaaaaaaab
    3820:	20000054 	.word	0x20000054
    3824:	0000a1a4 	.word	0x0000a1a4

00003828 <UartCommand(char const*, char const*, unsigned int, void const*)>:

int8_t UartCommand(char const* Name, char const* Params, const size_t ParamsLen, const void* Argument)
{
    3828:	b580      	push	{r7, lr}
    382a:	b090      	sub	sp, #64	@ 0x40
    382c:	af02      	add	r7, sp, #8
    382e:	60f8      	str	r0, [r7, #12]
    3830:	60b9      	str	r1, [r7, #8]
    3832:	607a      	str	r2, [r7, #4]
    3834:	603b      	str	r3, [r7, #0]
  struct timespec sleeptime;
  memset((char *)&sleeptime,0,sizeof(sleeptime));
    3836:	f107 0320 	add.w	r3, r7, #32
    383a:	2210      	movs	r2, #16
    383c:	2100      	movs	r1, #0
    383e:	4618      	mov	r0, r3
    3840:	f003 fd24 	bl	728c <memset>
  sleeptime.tv_nsec = 1000000;
    3844:	4b3c      	ldr	r3, [pc, #240]	@ (3938 <UartCommand(char const*, char const*, unsigned int, void const*)+0x110>)
    3846:	62bb      	str	r3, [r7, #40]	@ 0x28
  sleeptime.tv_sec = 0;
    3848:	f04f 0200 	mov.w	r2, #0
    384c:	f04f 0300 	mov.w	r3, #0
    3850:	e9c7 2308 	strd	r2, r3, [r7, #32]
  int key = 0;
    3854:	2300      	movs	r3, #0
    3856:	637b      	str	r3, [r7, #52]	@ 0x34

  
  printf("\nUartCommand: %u, %u. ", offsetof(CGraphDMHardwareInterface, UartFifo2), offsetof(CGraphDMHardwareInterface, UartStatusRegister2));
    3858:	2280      	movs	r2, #128	@ 0x80
    385a:	217c      	movs	r1, #124	@ 0x7c
    385c:	4837      	ldr	r0, [pc, #220]	@ (393c <UartCommand(char const*, char const*, unsigned int, void const*)+0x114>)
    385e:	f003 fb65 	bl	6f2c <iprintf>
	
  if (0 == strncmp(&(Params[1]), "loop", 4)) {
    3862:	68bb      	ldr	r3, [r7, #8]
    3864:	3301      	adds	r3, #1
    3866:	2204      	movs	r2, #4
    3868:	4935      	ldr	r1, [pc, #212]	@ (3940 <UartCommand(char const*, char const*, unsigned int, void const*)+0x118>)
    386a:	4618      	mov	r0, r3
    386c:	f003 fd23 	bl	72b6 <strncmp>
    3870:	4603      	mov	r3, r0
    3872:	2b00      	cmp	r3, #0
    3874:	d11a      	bne.n	38ac <UartCommand(char const*, char const*, unsigned int, void const*)+0x84>
    while(true) {
      //~ DM->UartFifo0 = 0x55;
      //~ DM->UartFifo1 = 0x55;	
      DM->UartFifo2 = 0x55;
    3876:	4b33      	ldr	r3, [pc, #204]	@ (3944 <UartCommand(char const*, char const*, unsigned int, void const*)+0x11c>)
    3878:	681b      	ldr	r3, [r3, #0]
    387a:	2200      	movs	r2, #0
    387c:	f042 0255 	orr.w	r2, r2, #85	@ 0x55
    3880:	f883 207c 	strb.w	r2, [r3, #124]	@ 0x7c
    3884:	2200      	movs	r2, #0
    3886:	f883 207d 	strb.w	r2, [r3, #125]	@ 0x7d
    388a:	2200      	movs	r2, #0
    388c:	f883 207e 	strb.w	r2, [r3, #126]	@ 0x7e
    3890:	2200      	movs	r2, #0
    3892:	f883 207f 	strb.w	r2, [r3, #127]	@ 0x7f
			
      //Quit on any keypress
      {
        //~ if (0 != key) 
        { 
          fflush(stdin);
    3896:	4b2c      	ldr	r3, [pc, #176]	@ (3948 <UartCommand(char const*, char const*, unsigned int, void const*)+0x120>)
    3898:	681b      	ldr	r3, [r3, #0]
    389a:	685b      	ldr	r3, [r3, #4]
    389c:	4618      	mov	r0, r3
    389e:	f003 fa6d 	bl	6d7c <fflush>
          printf("\n\nCircles: Keypress(%d); exiting.\n", key);
    38a2:	6b79      	ldr	r1, [r7, #52]	@ 0x34
    38a4:	4829      	ldr	r0, [pc, #164]	@ (394c <UartCommand(char const*, char const*, unsigned int, void const*)+0x124>)
    38a6:	f003 fb41 	bl	6f2c <iprintf>
          break; 
    38aa:	bf00      	nop
      }
    }
  }
	
  CGraphVersionPayload Version;
  Version.SerialNum = 0;
    38ac:	2300      	movs	r3, #0
    38ae:	617b      	str	r3, [r7, #20]
  Version.ProcessorFirmwareBuildNum = BuildNum;
    38b0:	23ee      	movs	r3, #238	@ 0xee
    38b2:	61bb      	str	r3, [r7, #24]
  Version.FPGAFirmwareBuildNum = 0;
    38b4:	2300      	movs	r3, #0
    38b6:	61fb      	str	r3, [r7, #28]
  if (DM) { 
    38b8:	4b22      	ldr	r3, [pc, #136]	@ (3944 <UartCommand(char const*, char const*, unsigned int, void const*)+0x11c>)
    38ba:	681b      	ldr	r3, [r3, #0]
    38bc:	2b00      	cmp	r3, #0
    38be:	d007      	beq.n	38d0 <UartCommand(char const*, char const*, unsigned int, void const*)+0xa8>
    Version.SerialNum = DM->DeviceSerialNumber; 
    38c0:	4b20      	ldr	r3, [pc, #128]	@ (3944 <UartCommand(char const*, char const*, unsigned int, void const*)+0x11c>)
    38c2:	681b      	ldr	r3, [r3, #0]
    38c4:	681b      	ldr	r3, [r3, #0]
    38c6:	617b      	str	r3, [r7, #20]
    Version.FPGAFirmwareBuildNum = DM->FpgaFirmwareBuildNumber; 
    38c8:	4b1e      	ldr	r3, [pc, #120]	@ (3944 <UartCommand(char const*, char const*, unsigned int, void const*)+0x11c>)
    38ca:	681b      	ldr	r3, [r3, #0]
    38cc:	685b      	ldr	r3, [r3, #4]
    38ce:	61fb      	str	r3, [r7, #28]
  }
  printf("\nUartCommand: Sending response (%u bytes): ", sizeof(CGraphVersionPayload));
    38d0:	210c      	movs	r1, #12
    38d2:	481f      	ldr	r0, [pc, #124]	@ (3950 <UartCommand(char const*, char const*, unsigned int, void const*)+0x128>)
    38d4:	f003 fb2a 	bl	6f2c <iprintf>
  Version.formatf();
    38d8:	f107 0314 	add.w	r3, r7, #20
    38dc:	4618      	mov	r0, r3
    38de:	f7ff fbf5 	bl	30cc <CGraphVersionPayload::formatf() const>
  printf("\n");
    38e2:	200a      	movs	r0, #10
    38e4:	f003 fb68 	bl	6fb8 <putchar>
  //~ TxBinaryPacket(&FpgaUartParser0, CGraphPayloadTypeVersion, 0, &Version, sizeof(CGraphVersionPayload));
  TxBinaryPacket(&FpgaUartParser0, CGraphPayloadTypeVersion, 0, &Version, sizeof(CGraphVersionPayload));
    38e8:	f107 0314 	add.w	r3, r7, #20
    38ec:	220c      	movs	r2, #12
    38ee:	9200      	str	r2, [sp, #0]
    38f0:	2200      	movs	r2, #0
    38f2:	f241 0101 	movw	r1, #4097	@ 0x1001
    38f6:	4817      	ldr	r0, [pc, #92]	@ (3954 <UartCommand(char const*, char const*, unsigned int, void const*)+0x12c>)
    38f8:	f7ff fc8a 	bl	3210 <TxBinaryPacket(void const*, unsigned short, unsigned long, void const*, unsigned int)>
  TxBinaryPacket(&FpgaUartParser1, CGraphPayloadTypeVersion, 0, &Version, sizeof(CGraphVersionPayload));
    38fc:	f107 0314 	add.w	r3, r7, #20
    3900:	220c      	movs	r2, #12
    3902:	9200      	str	r2, [sp, #0]
    3904:	2200      	movs	r2, #0
    3906:	f241 0101 	movw	r1, #4097	@ 0x1001
    390a:	4813      	ldr	r0, [pc, #76]	@ (3958 <UartCommand(char const*, char const*, unsigned int, void const*)+0x130>)
    390c:	f7ff fc80 	bl	3210 <TxBinaryPacket(void const*, unsigned short, unsigned long, void const*, unsigned int)>
  TxBinaryPacket(&FpgaUartParser2, CGraphPayloadTypeVersion, 0, &Version, sizeof(CGraphVersionPayload));
    3910:	f107 0314 	add.w	r3, r7, #20
    3914:	220c      	movs	r2, #12
    3916:	9200      	str	r2, [sp, #0]
    3918:	2200      	movs	r2, #0
    391a:	f241 0101 	movw	r1, #4097	@ 0x1001
    391e:	480f      	ldr	r0, [pc, #60]	@ (395c <UartCommand(char const*, char const*, unsigned int, void const*)+0x134>)
    3920:	f7ff fc76 	bl	3210 <TxBinaryPacket(void const*, unsigned short, unsigned long, void const*, unsigned int)>
    
  printf("\nUartCommand: complete.\n");
    3924:	480e      	ldr	r0, [pc, #56]	@ (3960 <UartCommand(char const*, char const*, unsigned int, void const*)+0x138>)
    3926:	f003 fba5 	bl	7074 <puts>

  return(ParamsLen);
    392a:	687b      	ldr	r3, [r7, #4]
    392c:	b25b      	sxtb	r3, r3
}
    392e:	4618      	mov	r0, r3
    3930:	3738      	adds	r7, #56	@ 0x38
    3932:	46bd      	mov	sp, r7
    3934:	bd80      	pop	{r7, pc}
    3936:	bf00      	nop
    3938:	000f4240 	.word	0x000f4240
    393c:	0000a1c4 	.word	0x0000a1c4
    3940:	0000a1dc 	.word	0x0000a1dc
    3944:	2000003c 	.word	0x2000003c
    3948:	20000054 	.word	0x20000054
    394c:	0000a1e4 	.word	0x0000a1e4
    3950:	0000a208 	.word	0x0000a208
    3954:	20001580 	.word	0x20001580
    3958:	200025b8 	.word	0x200025b8
    395c:	200035f0 	.word	0x200035f0
    3960:	0000a234 	.word	0x0000a234
    3964:	00000000 	.word	0x00000000

00003968 <BaudDividersCommand(char const*, char const*, unsigned int, void const*)>:

int8_t BaudDividersCommand(char const* Name, char const* Params, const size_t ParamsLen, const void* Argument)
{
    3968:	b580      	push	{r7, lr}
    396a:	b098      	sub	sp, #96	@ 0x60
    396c:	af02      	add	r7, sp, #8
    396e:	60f8      	str	r0, [r7, #12]
    3970:	60b9      	str	r1, [r7, #8]
    3972:	607a      	str	r2, [r7, #4]
    3974:	603b      	str	r3, [r7, #0]
  unsigned long A = 0, B = 0, C = 0, D = 0;
    3976:	2300      	movs	r3, #0
    3978:	61fb      	str	r3, [r7, #28]
    397a:	2300      	movs	r3, #0
    397c:	61bb      	str	r3, [r7, #24]
    397e:	2300      	movs	r3, #0
    3980:	617b      	str	r3, [r7, #20]
    3982:	2300      	movs	r3, #0
    3984:	613b      	str	r3, [r7, #16]
  
  if (NULL == DM) {
    3986:	4b54      	ldr	r3, [pc, #336]	@ (3ad8 <BaudDividersCommand(char const*, char const*, unsigned int, void const*)+0x170>)
    3988:	681b      	ldr	r3, [r3, #0]
    398a:	2b00      	cmp	r3, #0
    398c:	d105      	bne.n	399a <BaudDividersCommand(char const*, char const*, unsigned int, void const*)+0x32>
    printf("\n\nBaudDividers: Fpga interface is not initialized! Please call InitFpga first!.");
    398e:	4853      	ldr	r0, [pc, #332]	@ (3adc <BaudDividersCommand(char const*, char const*, unsigned int, void const*)+0x174>)
    3990:	f003 facc 	bl	6f2c <iprintf>
    return(ParamsLen);
    3994:	687b      	ldr	r3, [r7, #4]
    3996:	b25b      	sxtb	r3, r3
    3998:	e096      	b.n	3ac8 <BaudDividersCommand(char const*, char const*, unsigned int, void const*)+0x160>
  }
	
  //Convert parameters
  int8_t numfound = sscanf(Params, "%lu,%lu,%lu,%lu", &A, &B, &C, &D);
    399a:	f107 0118 	add.w	r1, r7, #24
    399e:	f107 021c 	add.w	r2, r7, #28
    39a2:	f107 0310 	add.w	r3, r7, #16
    39a6:	9301      	str	r3, [sp, #4]
    39a8:	f107 0314 	add.w	r3, r7, #20
    39ac:	9300      	str	r3, [sp, #0]
    39ae:	460b      	mov	r3, r1
    39b0:	494b      	ldr	r1, [pc, #300]	@ (3ae0 <BaudDividersCommand(char const*, char const*, unsigned int, void const*)+0x178>)
    39b2:	68b8      	ldr	r0, [r7, #8]
    39b4:	f003 fb66 	bl	7084 <siscanf>
    39b8:	4603      	mov	r3, r0
    39ba:	f887 3057 	strb.w	r3, [r7, #87]	@ 0x57
  if (numfound >= 4) {
    39be:	f997 3057 	ldrsb.w	r3, [r7, #87]	@ 0x57
    39c2:	2b03      	cmp	r3, #3
    39c4:	dd09      	ble.n	39da <BaudDividersCommand(char const*, char const*, unsigned int, void const*)+0x72>
//    DM->BaudDividers.Divider0 = A;
//    DM->BaudDividers.Divider1 = B;
//    DM->BaudDividers.Divider2 = C;
    //    DM->BaudDividers.Divider3 = D;
    printf("\n\nBaudDividers: setting to: %lu, %lu, %lu, %lu.\n", A, B, C, D);
    39c6:	69f9      	ldr	r1, [r7, #28]
    39c8:	69ba      	ldr	r2, [r7, #24]
    39ca:	6978      	ldr	r0, [r7, #20]
    39cc:	693b      	ldr	r3, [r7, #16]
    39ce:	9300      	str	r3, [sp, #0]
    39d0:	4603      	mov	r3, r0
    39d2:	4844      	ldr	r0, [pc, #272]	@ (3ae4 <BaudDividersCommand(char const*, char const*, unsigned int, void const*)+0x17c>)
    39d4:	f003 faaa 	bl	6f2c <iprintf>
    39d8:	e00c      	b.n	39f4 <BaudDividersCommand(char const*, char const*, unsigned int, void const*)+0x8c>
  }
  else {
    if (numfound >= 1) {
    39da:	f997 3057 	ldrsb.w	r3, [r7, #87]	@ 0x57
    39de:	2b00      	cmp	r3, #0
    39e0:	dd08      	ble.n	39f4 <BaudDividersCommand(char const*, char const*, unsigned int, void const*)+0x8c>
//      DM->BaudDividers.Divider0 = A;
//      DM->BaudDividers.Divider1 = A;
//      DM->BaudDividers.Divider2 = A;
      //DM->BaudDividers.Divider3 = A;
      printf("\n\nBaudDividers: setting to: %lu, %lu, %lu, %lu.\n", A, A, A, A);
    39e2:	69f9      	ldr	r1, [r7, #28]
    39e4:	69fa      	ldr	r2, [r7, #28]
    39e6:	69f8      	ldr	r0, [r7, #28]
    39e8:	69fb      	ldr	r3, [r7, #28]
    39ea:	9300      	str	r3, [sp, #0]
    39ec:	4603      	mov	r3, r0
    39ee:	483d      	ldr	r0, [pc, #244]	@ (3ae4 <BaudDividersCommand(char const*, char const*, unsigned int, void const*)+0x17c>)
    39f0:	f003 fa9c 	bl	6f2c <iprintf>
	
//  A = DM->BaudDividers.Divider0;
//  B = DM->BaudDividers.Divider1;
//  C = DM->BaudDividers.Divider2;
  //D = DM->BaudDividers.Divider3;
  printf("\n\nBaudDividers: current values: %lu, %lu, %lu.\n", A, B, C);
    39f4:	69f9      	ldr	r1, [r7, #28]
    39f6:	69ba      	ldr	r2, [r7, #24]
    39f8:	697b      	ldr	r3, [r7, #20]
    39fa:	483b      	ldr	r0, [pc, #236]	@ (3ae8 <BaudDividersCommand(char const*, char const*, unsigned int, void const*)+0x180>)
    39fc:	f003 fa96 	bl	6f2c <iprintf>
	
  double BaudClock = 102000000.0;
    3a00:	a333      	add	r3, pc, #204	@ (adr r3, 3ad0 <BaudDividersCommand(char const*, char const*, unsigned int, void const*)+0x168>)
    3a02:	e9d3 2300 	ldrd	r2, r3, [r3]
    3a06:	e9c7 2312 	strd	r2, r3, [r7, #72]	@ 0x48
  //~ unsigned int ActualDividerA = (A + 1) * 2;
  //~ unsigned int ActualDividerB = (B + 1) * 2;
  //~ unsigned int ActualDividerC = (C + 1) * 2;
  //~ unsigned int ActualDividerD = (D + 1) * 2;
  unsigned int ActualDividerA = (A + 1);
    3a0a:	69fb      	ldr	r3, [r7, #28]
    3a0c:	3301      	adds	r3, #1
    3a0e:	647b      	str	r3, [r7, #68]	@ 0x44
  unsigned int ActualDividerB = (B + 1);
    3a10:	69bb      	ldr	r3, [r7, #24]
    3a12:	3301      	adds	r3, #1
    3a14:	643b      	str	r3, [r7, #64]	@ 0x40
  unsigned int ActualDividerC = (C + 1);
    3a16:	697b      	ldr	r3, [r7, #20]
    3a18:	3301      	adds	r3, #1
    3a1a:	63fb      	str	r3, [r7, #60]	@ 0x3c
  //unsigned int ActualDividerD = (D + 1);
  double BaudRateA = (BaudClock / ActualDividerA) / 16;
    3a1c:	6c78      	ldr	r0, [r7, #68]	@ 0x44
    3a1e:	f004 ff9d 	bl	895c <__aeabi_ui2d>
    3a22:	4602      	mov	r2, r0
    3a24:	460b      	mov	r3, r1
    3a26:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	@ 0x48
    3a2a:	f005 f93b 	bl	8ca4 <__aeabi_ddiv>
    3a2e:	4602      	mov	r2, r0
    3a30:	460b      	mov	r3, r1
    3a32:	4610      	mov	r0, r2
    3a34:	4619      	mov	r1, r3
    3a36:	f04f 0200 	mov.w	r2, #0
    3a3a:	4b2c      	ldr	r3, [pc, #176]	@ (3aec <BaudDividersCommand(char const*, char const*, unsigned int, void const*)+0x184>)
    3a3c:	f005 f932 	bl	8ca4 <__aeabi_ddiv>
    3a40:	4602      	mov	r2, r0
    3a42:	460b      	mov	r3, r1
    3a44:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
  double BaudRateB = (BaudClock / ActualDividerB) / 16;
    3a48:	6c38      	ldr	r0, [r7, #64]	@ 0x40
    3a4a:	f004 ff87 	bl	895c <__aeabi_ui2d>
    3a4e:	4602      	mov	r2, r0
    3a50:	460b      	mov	r3, r1
    3a52:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	@ 0x48
    3a56:	f005 f925 	bl	8ca4 <__aeabi_ddiv>
    3a5a:	4602      	mov	r2, r0
    3a5c:	460b      	mov	r3, r1
    3a5e:	4610      	mov	r0, r2
    3a60:	4619      	mov	r1, r3
    3a62:	f04f 0200 	mov.w	r2, #0
    3a66:	4b21      	ldr	r3, [pc, #132]	@ (3aec <BaudDividersCommand(char const*, char const*, unsigned int, void const*)+0x184>)
    3a68:	f005 f91c 	bl	8ca4 <__aeabi_ddiv>
    3a6c:	4602      	mov	r2, r0
    3a6e:	460b      	mov	r3, r1
    3a70:	e9c7 230a 	strd	r2, r3, [r7, #40]	@ 0x28
  double BaudRateC = (BaudClock / ActualDividerC) / 16;
    3a74:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
    3a76:	f004 ff71 	bl	895c <__aeabi_ui2d>
    3a7a:	4602      	mov	r2, r0
    3a7c:	460b      	mov	r3, r1
    3a7e:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	@ 0x48
    3a82:	f005 f90f 	bl	8ca4 <__aeabi_ddiv>
    3a86:	4602      	mov	r2, r0
    3a88:	460b      	mov	r3, r1
    3a8a:	4610      	mov	r0, r2
    3a8c:	4619      	mov	r1, r3
    3a8e:	f04f 0200 	mov.w	r2, #0
    3a92:	4b16      	ldr	r3, [pc, #88]	@ (3aec <BaudDividersCommand(char const*, char const*, unsigned int, void const*)+0x184>)
    3a94:	f005 f906 	bl	8ca4 <__aeabi_ddiv>
    3a98:	4602      	mov	r2, r0
    3a9a:	460b      	mov	r3, r1
    3a9c:	e9c7 2308 	strd	r2, r3, [r7, #32]
  //double BaudRateD = (BaudClock / ActualDividerD) / 16;
	
  printf("\nBaudDividers: Port0 final division ratio: %u (/16); Actual baudrate: %.5lf", ActualDividerA, BaudRateA);
    3aa0:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	@ 0x30
    3aa4:	6c79      	ldr	r1, [r7, #68]	@ 0x44
    3aa6:	4812      	ldr	r0, [pc, #72]	@ (3af0 <BaudDividersCommand(char const*, char const*, unsigned int, void const*)+0x188>)
    3aa8:	f003 fa40 	bl	6f2c <iprintf>
  printf("\nBaudDividers: Port1 final division ratio: %u (/16); Actual baudrate: %.5lf", ActualDividerB, BaudRateB);
    3aac:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
    3ab0:	6c39      	ldr	r1, [r7, #64]	@ 0x40
    3ab2:	4810      	ldr	r0, [pc, #64]	@ (3af4 <BaudDividersCommand(char const*, char const*, unsigned int, void const*)+0x18c>)
    3ab4:	f003 fa3a 	bl	6f2c <iprintf>
  printf("\nBaudDividers: Port2 final division ratio: %u (/16); Actual baudrate: %.5lf\n", ActualDividerC, BaudRateC);
    3ab8:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
    3abc:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
    3abe:	480e      	ldr	r0, [pc, #56]	@ (3af8 <BaudDividersCommand(char const*, char const*, unsigned int, void const*)+0x190>)
    3ac0:	f003 fa34 	bl	6f2c <iprintf>
  //printf("\nBaudDividers: Port3 final division ratio: %u (/16); Actual baudrate: %.5lf\n", ActualDividerD, BaudRateD);
	
  return(ParamsLen);
    3ac4:	687b      	ldr	r3, [r7, #4]
    3ac6:	b25b      	sxtb	r3, r3
}
    3ac8:	4618      	mov	r0, r3
    3aca:	3758      	adds	r7, #88	@ 0x58
    3acc:	46bd      	mov	sp, r7
    3ace:	bd80      	pop	{r7, pc}
    3ad0:	00000000 	.word	0x00000000
    3ad4:	41985196 	.word	0x41985196
    3ad8:	2000003c 	.word	0x2000003c
    3adc:	0000a24c 	.word	0x0000a24c
    3ae0:	0000a29c 	.word	0x0000a29c
    3ae4:	0000a2ac 	.word	0x0000a2ac
    3ae8:	0000a2e0 	.word	0x0000a2e0
    3aec:	40300000 	.word	0x40300000
    3af0:	0000a310 	.word	0x0000a310
    3af4:	0000a35c 	.word	0x0000a35c
    3af8:	0000a3a8 	.word	0x0000a3a8

00003afc <PrintBuffersCommand(char const*, char const*, unsigned int, void const*)>:

int8_t PrintBuffersCommand(char const* Name, char const* Params, const size_t ParamsLen, const void* Argument)
{
    3afc:	b580      	push	{r7, lr}
    3afe:	b084      	sub	sp, #16
    3b00:	af00      	add	r7, sp, #0
    3b02:	60f8      	str	r0, [r7, #12]
    3b04:	60b9      	str	r1, [r7, #8]
    3b06:	607a      	str	r2, [r7, #4]
    3b08:	603b      	str	r3, [r7, #0]
  printf("\nShowBuffersCommand: FpgaUartParser: ");
    3b0a:	480a      	ldr	r0, [pc, #40]	@ (3b34 <PrintBuffersCommand(char const*, char const*, unsigned int, void const*)+0x38>)
    3b0c:	f003 fa0e 	bl	6f2c <iprintf>
  FpgaUartParser0.formatf();
    3b10:	4809      	ldr	r0, [pc, #36]	@ (3b38 <PrintBuffersCommand(char const*, char const*, unsigned int, void const*)+0x3c>)
    3b12:	f7ff fb3f 	bl	3194 <BinaryUart::formatf() const>
  FpgaUartParser1.formatf();
    3b16:	4809      	ldr	r0, [pc, #36]	@ (3b3c <PrintBuffersCommand(char const*, char const*, unsigned int, void const*)+0x40>)
    3b18:	f7ff fb3c 	bl	3194 <BinaryUart::formatf() const>
  FpgaUartParser2.formatf();
    3b1c:	4808      	ldr	r0, [pc, #32]	@ (3b40 <PrintBuffersCommand(char const*, char const*, unsigned int, void const*)+0x44>)
    3b1e:	f7ff fb39 	bl	3194 <BinaryUart::formatf() const>
  //FpgaUartParser3.formatf();
  printf("\n\n");
    3b22:	4808      	ldr	r0, [pc, #32]	@ (3b44 <PrintBuffersCommand(char const*, char const*, unsigned int, void const*)+0x48>)
    3b24:	f003 faa6 	bl	7074 <puts>
  return(ParamsLen);
    3b28:	687b      	ldr	r3, [r7, #4]
    3b2a:	b25b      	sxtb	r3, r3
}
    3b2c:	4618      	mov	r0, r3
    3b2e:	3710      	adds	r7, #16
    3b30:	46bd      	mov	sp, r7
    3b32:	bd80      	pop	{r7, pc}
    3b34:	0000a3f8 	.word	0x0000a3f8
    3b38:	20001580 	.word	0x20001580
    3b3c:	200025b8 	.word	0x200025b8
    3b40:	200035f0 	.word	0x200035f0
    3b44:	00009dcc 	.word	0x00009dcc

00003b48 <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)>:

int8_t MonitorSerialCommand(char const* Name, char const* Params, const size_t ParamsLen, const void* Argument)
{
    3b48:	b580      	push	{r7, lr}
    3b4a:	b08c      	sub	sp, #48	@ 0x30
    3b4c:	af02      	add	r7, sp, #8
    3b4e:	60f8      	str	r0, [r7, #12]
    3b50:	60b9      	str	r1, [r7, #8]
    3b52:	607a      	str	r2, [r7, #4]
    3b54:	603b      	str	r3, [r7, #0]
  unsigned long port = 0;
    3b56:	2300      	movs	r3, #0
    3b58:	623b      	str	r3, [r7, #32]
  char seperator[8];
  char onoff;
  bool OnOff = false;
    3b5a:	2300      	movs	r3, #0
    3b5c:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

  //Convert parameters
  int8_t numfound = sscanf(Params, "%lu%2[,\t ]%c", &port, seperator, &onoff);
    3b60:	f107 0118 	add.w	r1, r7, #24
    3b64:	f107 0220 	add.w	r2, r7, #32
    3b68:	f107 0317 	add.w	r3, r7, #23
    3b6c:	9300      	str	r3, [sp, #0]
    3b6e:	460b      	mov	r3, r1
    3b70:	4946      	ldr	r1, [pc, #280]	@ (3c8c <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0x144>)
    3b72:	68b8      	ldr	r0, [r7, #8]
    3b74:	f003 fa86 	bl	7084 <siscanf>
    3b78:	4603      	mov	r3, r0
    3b7a:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
  if (numfound >= 4) {
    3b7e:	f997 3026 	ldrsb.w	r3, [r7, #38]	@ 0x26
    3b82:	2b03      	cmp	r3, #3
    3b84:	dd4c      	ble.n	3c20 <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0xd8>
    if ( ('Y' == onoff) || ('y' == onoff) || ('T' == onoff) || ('t' == onoff) || ('1' == onoff) ) {
    3b86:	f997 3017 	ldrsb.w	r3, [r7, #23]
    3b8a:	2b59      	cmp	r3, #89	@ 0x59
    3b8c:	d00f      	beq.n	3bae <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0x66>
    3b8e:	f997 3017 	ldrsb.w	r3, [r7, #23]
    3b92:	2b79      	cmp	r3, #121	@ 0x79
    3b94:	d00b      	beq.n	3bae <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0x66>
    3b96:	f997 3017 	ldrsb.w	r3, [r7, #23]
    3b9a:	2b54      	cmp	r3, #84	@ 0x54
    3b9c:	d007      	beq.n	3bae <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0x66>
    3b9e:	f997 3017 	ldrsb.w	r3, [r7, #23]
    3ba2:	2b74      	cmp	r3, #116	@ 0x74
    3ba4:	d003      	beq.n	3bae <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0x66>
    3ba6:	f997 3017 	ldrsb.w	r3, [r7, #23]
    3baa:	2b31      	cmp	r3, #49	@ 0x31
    3bac:	d102      	bne.n	3bb4 <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0x6c>
      OnOff = true;
    3bae:	2301      	movs	r3, #1
    3bb0:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    }
		
    formatf("\n\nMonitorSerialCommand: Monitoring port %lu: %c.\n", port, OnOff?'Y':'N');
    3bb4:	6a39      	ldr	r1, [r7, #32]
    3bb6:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
    3bba:	2b00      	cmp	r3, #0
    3bbc:	d001      	beq.n	3bc2 <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0x7a>
    3bbe:	2359      	movs	r3, #89	@ 0x59
    3bc0:	e000      	b.n	3bc4 <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0x7c>
    3bc2:	234e      	movs	r3, #78	@ 0x4e
    3bc4:	461a      	mov	r2, r3
    3bc6:	4832      	ldr	r0, [pc, #200]	@ (3c90 <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0x148>)
    3bc8:	f001 fb9a 	bl	5300 <formatf>
		
    switch(port) {
    3bcc:	6a3b      	ldr	r3, [r7, #32]
    3bce:	2b02      	cmp	r3, #2
    3bd0:	d014      	beq.n	3bfc <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0xb4>
    3bd2:	2b02      	cmp	r3, #2
    3bd4:	d819      	bhi.n	3c0a <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0xc2>
    3bd6:	2b00      	cmp	r3, #0
    3bd8:	d002      	beq.n	3be0 <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0x98>
    3bda:	2b01      	cmp	r3, #1
    3bdc:	d007      	beq.n	3bee <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0xa6>
    3bde:	e014      	b.n	3c0a <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0xc2>
    case 0 : { FPGAUartPinout0.Monitor(OnOff); break; }			
    3be0:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
    3be4:	4619      	mov	r1, r3
    3be6:	482b      	ldr	r0, [pc, #172]	@ (3c94 <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0x14c>)
    3be8:	f7ff fb32 	bl	3250 <uart_pinout_fpga::Monitor(bool)>
    3bec:	e012      	b.n	3c14 <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0xcc>
    case 1 : { FPGAUartPinout1.Monitor(OnOff); break; }			
    3bee:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
    3bf2:	4619      	mov	r1, r3
    3bf4:	4828      	ldr	r0, [pc, #160]	@ (3c98 <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0x150>)
    3bf6:	f7ff fb2b 	bl	3250 <uart_pinout_fpga::Monitor(bool)>
    3bfa:	e00b      	b.n	3c14 <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0xcc>
    case 2 : { FPGAUartPinout2.Monitor(OnOff); break; }			
    3bfc:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
    3c00:	4619      	mov	r1, r3
    3c02:	4826      	ldr	r0, [pc, #152]	@ (3c9c <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0x154>)
    3c04:	f7ff fb24 	bl	3250 <uart_pinout_fpga::Monitor(bool)>
    3c08:	e004      	b.n	3c14 <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0xcc>
      //case 3 : { FPGAUartPinout3.Monitor(OnOff); break; }			
    default : 
      { 
        formatf("\n\nMonitorSerialCommand: Invalid port %lu; max is #2.\n", port);
    3c0a:	6a3b      	ldr	r3, [r7, #32]
    3c0c:	4619      	mov	r1, r3
    3c0e:	4824      	ldr	r0, [pc, #144]	@ (3ca0 <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0x158>)
    3c10:	f001 fb76 	bl	5300 <formatf>
      }
    }
			
    return(strlen(Params));
    3c14:	68b8      	ldr	r0, [r7, #8]
    3c16:	f003 fc2c 	bl	7472 <strlen>
    3c1a:	4603      	mov	r3, r0
    3c1c:	b25b      	sxtb	r3, r3
    3c1e:	e031      	b.n	3c84 <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0x13c>
  }
	
  formatf("\n\nMonitorSerialCommand: Insufficient parameters (%u; should be 2); querying...", numfound);
    3c20:	f997 3026 	ldrsb.w	r3, [r7, #38]	@ 0x26
    3c24:	4619      	mov	r1, r3
    3c26:	481f      	ldr	r0, [pc, #124]	@ (3ca4 <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0x15c>)
    3c28:	f001 fb6a 	bl	5300 <formatf>
  
  formatf("\nMonitorSerialCommand: Monitoring port 0: %c.\n", FPGAUartPinout0.Monitor()?'Y':'N');
    3c2c:	4819      	ldr	r0, [pc, #100]	@ (3c94 <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0x14c>)
    3c2e:	f7ff fb1d 	bl	326c <uart_pinout_fpga::Monitor() const>
    3c32:	4603      	mov	r3, r0
    3c34:	2b00      	cmp	r3, #0
    3c36:	d001      	beq.n	3c3c <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0xf4>
    3c38:	2359      	movs	r3, #89	@ 0x59
    3c3a:	e000      	b.n	3c3e <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0xf6>
    3c3c:	234e      	movs	r3, #78	@ 0x4e
    3c3e:	4619      	mov	r1, r3
    3c40:	4819      	ldr	r0, [pc, #100]	@ (3ca8 <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0x160>)
    3c42:	f001 fb5d 	bl	5300 <formatf>
  formatf("\nMonitorSerialCommand: Monitoring port 1: %c.\n", FPGAUartPinout1.Monitor()?'Y':'N');
    3c46:	4814      	ldr	r0, [pc, #80]	@ (3c98 <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0x150>)
    3c48:	f7ff fb10 	bl	326c <uart_pinout_fpga::Monitor() const>
    3c4c:	4603      	mov	r3, r0
    3c4e:	2b00      	cmp	r3, #0
    3c50:	d001      	beq.n	3c56 <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0x10e>
    3c52:	2359      	movs	r3, #89	@ 0x59
    3c54:	e000      	b.n	3c58 <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0x110>
    3c56:	234e      	movs	r3, #78	@ 0x4e
    3c58:	4619      	mov	r1, r3
    3c5a:	4814      	ldr	r0, [pc, #80]	@ (3cac <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0x164>)
    3c5c:	f001 fb50 	bl	5300 <formatf>
  formatf("\nMonitorSerialCommand: Monitoring port 2: %c.\n", FPGAUartPinout2.Monitor()?'Y':'N');	
    3c60:	480e      	ldr	r0, [pc, #56]	@ (3c9c <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0x154>)
    3c62:	f7ff fb03 	bl	326c <uart_pinout_fpga::Monitor() const>
    3c66:	4603      	mov	r3, r0
    3c68:	2b00      	cmp	r3, #0
    3c6a:	d001      	beq.n	3c70 <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0x128>
    3c6c:	2359      	movs	r3, #89	@ 0x59
    3c6e:	e000      	b.n	3c72 <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0x12a>
    3c70:	234e      	movs	r3, #78	@ 0x4e
    3c72:	4619      	mov	r1, r3
    3c74:	480e      	ldr	r0, [pc, #56]	@ (3cb0 <MonitorSerialCommand(char const*, char const*, unsigned int, void const*)+0x168>)
    3c76:	f001 fb43 	bl	5300 <formatf>
  //formatf("\nMonitorSerialCommand: Monitoring port 3: %c.\n", FPGAUartPinout3.Monitor()?'Y':'N');	
	
  return(strlen(Params));
    3c7a:	68b8      	ldr	r0, [r7, #8]
    3c7c:	f003 fbf9 	bl	7472 <strlen>
    3c80:	4603      	mov	r3, r0
    3c82:	b25b      	sxtb	r3, r3
}
    3c84:	4618      	mov	r0, r3
    3c86:	3728      	adds	r7, #40	@ 0x28
    3c88:	46bd      	mov	sp, r7
    3c8a:	bd80      	pop	{r7, pc}
    3c8c:	0000a420 	.word	0x0000a420
    3c90:	0000a430 	.word	0x0000a430
    3c94:	20001528 	.word	0x20001528
    3c98:	20001544 	.word	0x20001544
    3c9c:	20001560 	.word	0x20001560
    3ca0:	0000a464 	.word	0x0000a464
    3ca4:	0000a49c 	.word	0x0000a49c
    3ca8:	0000a4ec 	.word	0x0000a4ec
    3cac:	0000a51c 	.word	0x0000a51c
    3cb0:	0000a54c 	.word	0x0000a54c

00003cb4 <DMMappingCommand(char const*, char const*, unsigned int, void const*)>:

int8_t DMMappingCommand(char const* Name, char const* Params, const size_t ParamsLen, const void* Argument)
{
    3cb4:	b580      	push	{r7, lr}
    3cb6:	b08c      	sub	sp, #48	@ 0x30
    3cb8:	af02      	add	r7, sp, #8
    3cba:	60f8      	str	r0, [r7, #12]
    3cbc:	60b9      	str	r1, [r7, #8]
    3cbe:	607a      	str	r2, [r7, #4]
    3cc0:	603b      	str	r3, [r7, #0]
	unsigned long A = 0, B = 0, C = 0, D = 0;
    3cc2:	2300      	movs	r3, #0
    3cc4:	623b      	str	r3, [r7, #32]
    3cc6:	2300      	movs	r3, #0
    3cc8:	61fb      	str	r3, [r7, #28]
    3cca:	2300      	movs	r3, #0
    3ccc:	61bb      	str	r3, [r7, #24]
    3cce:	2300      	movs	r3, #0
    3cd0:	617b      	str	r3, [r7, #20]

	//Convert parameters - at the moment we're being lazy and only support testing a single mapping at a time...
	int8_t numfound = sscanf(Params, "%lu,%lu,%lu,%lu", &A, &B, &C, &D);
    3cd2:	f107 011c 	add.w	r1, r7, #28
    3cd6:	f107 0220 	add.w	r2, r7, #32
    3cda:	f107 0314 	add.w	r3, r7, #20
    3cde:	9301      	str	r3, [sp, #4]
    3ce0:	f107 0318 	add.w	r3, r7, #24
    3ce4:	9300      	str	r3, [sp, #0]
    3ce6:	460b      	mov	r3, r1
    3ce8:	491d      	ldr	r1, [pc, #116]	@ (3d60 <DMMappingCommand(char const*, char const*, unsigned int, void const*)+0xac>)
    3cea:	68b8      	ldr	r0, [r7, #8]
    3cec:	f003 f9ca 	bl	7084 <siscanf>
    3cf0:	4603      	mov	r3, r0
    3cf2:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
	if (numfound >= 4)
    3cf6:	f997 3027 	ldrsb.w	r3, [r7, #39]	@ 0x27
    3cfa:	2b03      	cmp	r3, #3
    3cfc:	dd21      	ble.n	3d42 <DMMappingCommand(char const*, char const*, unsigned int, void const*)+0x8e>
	{
		CGraphDMMappingPayload Mapping(B, C, D);
    3cfe:	69f9      	ldr	r1, [r7, #28]
    3d00:	69ba      	ldr	r2, [r7, #24]
    3d02:	697b      	ldr	r3, [r7, #20]
    3d04:	f107 0010 	add.w	r0, r7, #16
    3d08:	f7ff f9f4 	bl	30f4 <CGraphDMMappingPayload::CGraphDMMappingPayload(unsigned long, unsigned long, unsigned long)>
		
		DMMappings.Mappings[A] = Mapping;
    3d0c:	6a3a      	ldr	r2, [r7, #32]
    3d0e:	4915      	ldr	r1, [pc, #84]	@ (3d64 <DMMappingCommand(char const*, char const*, unsigned int, void const*)+0xb0>)
    3d10:	4613      	mov	r3, r2
    3d12:	005b      	lsls	r3, r3, #1
    3d14:	4413      	add	r3, r2
    3d16:	440b      	add	r3, r1
    3d18:	461a      	mov	r2, r3
    3d1a:	f107 0310 	add.w	r3, r7, #16
    3d1e:	8819      	ldrh	r1, [r3, #0]
    3d20:	789b      	ldrb	r3, [r3, #2]
    3d22:	8011      	strh	r1, [r2, #0]
    3d24:	7093      	strb	r3, [r2, #2]
		printf("\nBinaryDMMappingCommand: Set mapping %lu to ", (unsigned long)A);
    3d26:	6a3b      	ldr	r3, [r7, #32]
    3d28:	4619      	mov	r1, r3
    3d2a:	480f      	ldr	r0, [pc, #60]	@ (3d68 <DMMappingCommand(char const*, char const*, unsigned int, void const*)+0xb4>)
    3d2c:	f003 f8fe 	bl	6f2c <iprintf>
		Mapping.formatf();
    3d30:	f107 0310 	add.w	r3, r7, #16
    3d34:	4618      	mov	r0, r3
    3d36:	f7ff f9f7 	bl	3128 <CGraphDMMappingPayload::formatf() const>
		printf("\n\n");
    3d3a:	480c      	ldr	r0, [pc, #48]	@ (3d6c <DMMappingCommand(char const*, char const*, unsigned int, void const*)+0xb8>)
    3d3c:	f003 f99a 	bl	7074 <puts>
    3d40:	e008      	b.n	3d54 <DMMappingCommand(char const*, char const*, unsigned int, void const*)+0xa0>
	}
	//query?
	else
	{
		printf("\n\nDMMappingCommand: No parameters given; all mappings follow:\n");
    3d42:	480b      	ldr	r0, [pc, #44]	@ (3d70 <DMMappingCommand(char const*, char const*, unsigned int, void const*)+0xbc>)
    3d44:	f003 f996 	bl	7074 <puts>
		DMMappings.formatf();
    3d48:	4806      	ldr	r0, [pc, #24]	@ (3d64 <DMMappingCommand(char const*, char const*, unsigned int, void const*)+0xb0>)
    3d4a:	f7ff fa03 	bl	3154 <CGraphDMMappings::formatf() const>
		printf("\n\n");
    3d4e:	4807      	ldr	r0, [pc, #28]	@ (3d6c <DMMappingCommand(char const*, char const*, unsigned int, void const*)+0xb8>)
    3d50:	f003 f990 	bl	7074 <puts>
	}
		
    return(ParamsLen);
    3d54:	687b      	ldr	r3, [r7, #4]
    3d56:	b25b      	sxtb	r3, r3
}
    3d58:	4618      	mov	r0, r3
    3d5a:	3728      	adds	r7, #40	@ 0x28
    3d5c:	46bd      	mov	sp, r7
    3d5e:	bd80      	pop	{r7, pc}
    3d60:	0000a29c 	.word	0x0000a29c
    3d64:	200009e0 	.word	0x200009e0
    3d68:	0000a57c 	.word	0x0000a57c
    3d6c:	00009dcc 	.word	0x00009dcc
    3d70:	0000a5ac 	.word	0x0000a5ac

00003d74 <DMShortPixelsCommand(char const*, char const*, unsigned int, void const*)>:

int8_t DMShortPixelsCommand(char const* Name, char const* Params, const size_t ParamsLen, const void* Argument)
{
    3d74:	b5f0      	push	{r4, r5, r6, r7, lr}
    3d76:	b08b      	sub	sp, #44	@ 0x2c
    3d78:	af00      	add	r7, sp, #0
    3d7a:	60f8      	str	r0, [r7, #12]
    3d7c:	60b9      	str	r1, [r7, #8]
    3d7e:	607a      	str	r2, [r7, #4]
    3d80:	603b      	str	r3, [r7, #0]
	if (nullptr == DM)
    3d82:	4b50      	ldr	r3, [pc, #320]	@ (3ec4 <DMShortPixelsCommand(char const*, char const*, unsigned int, void const*)+0x150>)
    3d84:	681b      	ldr	r3, [r3, #0]
    3d86:	2b00      	cmp	r3, #0
    3d88:	d105      	bne.n	3d96 <DMShortPixelsCommand(char const*, char const*, unsigned int, void const*)+0x22>
	{
		printf("\nDMShortPixelsCommand: DM pointer is NULL! Firmware corrupted!\n");	
    3d8a:	484f      	ldr	r0, [pc, #316]	@ (3ec8 <DMShortPixelsCommand(char const*, char const*, unsigned int, void const*)+0x154>)
    3d8c:	f003 f972 	bl	7074 <puts>
		return(ParamsLen);
    3d90:	687b      	ldr	r3, [r7, #4]
    3d92:	b25b      	sxtb	r3, r3
    3d94:	e091      	b.n	3eba <DMShortPixelsCommand(char const*, char const*, unsigned int, void const*)+0x146>
	}

	unsigned long A = 0;
    3d96:	2300      	movs	r3, #0
    3d98:	617b      	str	r3, [r7, #20]
	
	strtok(const_cast<char*>(Params)," ,\t\r\n");
    3d9a:	494c      	ldr	r1, [pc, #304]	@ (3ecc <DMShortPixelsCommand(char const*, char const*, unsigned int, void const*)+0x158>)
    3d9c:	68b8      	ldr	r0, [r7, #8]
    3d9e:	f003 fa9d 	bl	72dc <strtok>

	//Convert start pixel
	int8_t numfound = sscanf(Params, "%lu", &A);
    3da2:	f107 0314 	add.w	r3, r7, #20
    3da6:	461a      	mov	r2, r3
    3da8:	4949      	ldr	r1, [pc, #292]	@ (3ed0 <DMShortPixelsCommand(char const*, char const*, unsigned int, void const*)+0x15c>)
    3daa:	68b8      	ldr	r0, [r7, #8]
    3dac:	f003 f96a 	bl	7084 <siscanf>
    3db0:	4603      	mov	r3, r0
    3db2:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
	if (numfound >= 1)
    3db6:	f997 3023 	ldrsb.w	r3, [r7, #35]	@ 0x23
    3dba:	2b00      	cmp	r3, #0
    3dbc:	dd76      	ble.n	3eac <DMShortPixelsCommand(char const*, char const*, unsigned int, void const*)+0x138>
	{
		//Now we start building an array of pixels...icky parsing lol
		size_t i = 0;
    3dbe:	2300      	movs	r3, #0
    3dc0:	627b      	str	r3, [r7, #36]	@ 0x24
		for (i = A; i < DMMaxActuators; i++)
    3dc2:	697b      	ldr	r3, [r7, #20]
    3dc4:	627b      	str	r3, [r7, #36]	@ 0x24
    3dc6:	e06c      	b.n	3ea2 <DMShortPixelsCommand(char const*, char const*, unsigned int, void const*)+0x12e>
		{
			char* PixStr = strtok((char*)nullptr," ,\t\r\n");
    3dc8:	4940      	ldr	r1, [pc, #256]	@ (3ecc <DMShortPixelsCommand(char const*, char const*, unsigned int, void const*)+0x158>)
    3dca:	2000      	movs	r0, #0
    3dcc:	f003 fa86 	bl	72dc <strtok>
    3dd0:	61f8      	str	r0, [r7, #28]
			if (nullptr == PixStr) { break; }
    3dd2:	69fb      	ldr	r3, [r7, #28]
    3dd4:	2b00      	cmp	r3, #0
    3dd6:	d06d      	beq.n	3eb4 <DMShortPixelsCommand(char const*, char const*, unsigned int, void const*)+0x140>
			uint16_t Pixel = atoi(PixStr);
    3dd8:	69f8      	ldr	r0, [r7, #28]
    3dda:	f002 fe9f 	bl	6b1c <atoi>
    3dde:	4603      	mov	r3, r0
    3de0:	837b      	strh	r3, [r7, #26]
			
			//What D/A ram does this pix belong to?
			if ( (DMMappings.Mappings[i].ControllerBoardIndex >= DMMaxControllerBoards) || (DMMappings.Mappings[i].ControllerBoardIndex >= DMMaxControllerBoards) || (DMMappings.Mappings[i].ControllerBoardIndex >= DMMaxControllerBoards) )
    3de2:	493c      	ldr	r1, [pc, #240]	@ (3ed4 <DMShortPixelsCommand(char const*, char const*, unsigned int, void const*)+0x160>)
    3de4:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
    3de6:	4613      	mov	r3, r2
    3de8:	005b      	lsls	r3, r3, #1
    3dea:	4413      	add	r3, r2
    3dec:	440b      	add	r3, r1
    3dee:	781b      	ldrb	r3, [r3, #0]
    3df0:	2b05      	cmp	r3, #5
    3df2:	d811      	bhi.n	3e18 <DMShortPixelsCommand(char const*, char const*, unsigned int, void const*)+0xa4>
    3df4:	4937      	ldr	r1, [pc, #220]	@ (3ed4 <DMShortPixelsCommand(char const*, char const*, unsigned int, void const*)+0x160>)
    3df6:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
    3df8:	4613      	mov	r3, r2
    3dfa:	005b      	lsls	r3, r3, #1
    3dfc:	4413      	add	r3, r2
    3dfe:	440b      	add	r3, r1
    3e00:	781b      	ldrb	r3, [r3, #0]
    3e02:	2b05      	cmp	r3, #5
    3e04:	d808      	bhi.n	3e18 <DMShortPixelsCommand(char const*, char const*, unsigned int, void const*)+0xa4>
    3e06:	4933      	ldr	r1, [pc, #204]	@ (3ed4 <DMShortPixelsCommand(char const*, char const*, unsigned int, void const*)+0x160>)
    3e08:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
    3e0a:	4613      	mov	r3, r2
    3e0c:	005b      	lsls	r3, r3, #1
    3e0e:	4413      	add	r3, r2
    3e10:	440b      	add	r3, r1
    3e12:	781b      	ldrb	r3, [r3, #0]
    3e14:	2b05      	cmp	r3, #5
    3e16:	d910      	bls.n	3e3a <DMShortPixelsCommand(char const*, char const*, unsigned int, void const*)+0xc6>
			{
				printf("\nDMShortPixelsCommand: Invalid mapping %lu; please reinitialize mappings!: ", (unsigned long)i);
    3e18:	6a79      	ldr	r1, [r7, #36]	@ 0x24
    3e1a:	482f      	ldr	r0, [pc, #188]	@ (3ed8 <DMShortPixelsCommand(char const*, char const*, unsigned int, void const*)+0x164>)
    3e1c:	f003 f886 	bl	6f2c <iprintf>
				DMMappings.Mappings[i].formatf();
    3e20:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
    3e22:	4613      	mov	r3, r2
    3e24:	005b      	lsls	r3, r3, #1
    3e26:	4413      	add	r3, r2
    3e28:	4a2a      	ldr	r2, [pc, #168]	@ (3ed4 <DMShortPixelsCommand(char const*, char const*, unsigned int, void const*)+0x160>)
    3e2a:	4413      	add	r3, r2
    3e2c:	4618      	mov	r0, r3
    3e2e:	f7ff f97b 	bl	3128 <CGraphDMMappingPayload::formatf() const>
				printf("\n\n");
    3e32:	482a      	ldr	r0, [pc, #168]	@ (3edc <DMShortPixelsCommand(char const*, char const*, unsigned int, void const*)+0x168>)
    3e34:	f003 f91e 	bl	7074 <puts>
    3e38:	e030      	b.n	3e9c <DMShortPixelsCommand(char const*, char const*, unsigned int, void const*)+0x128>
			}
			//Yay, we got here, things are actaully correct and we have something to do!
			else
			{
				dRAM->DacSetpoints[DMMappings.Mappings[i].ControllerBoardIndex][DMMappings.Mappings[i].DacIndex][DMMappings.Mappings[i].DacChannel] = ((uint32_t)Pixel) << 8; //<<8 cause we really want 24b values when we dither
    3e3a:	8b78      	ldrh	r0, [r7, #26]
    3e3c:	4b28      	ldr	r3, [pc, #160]	@ (3ee0 <DMShortPixelsCommand(char const*, char const*, unsigned int, void const*)+0x16c>)
    3e3e:	6819      	ldr	r1, [r3, #0]
    3e40:	4c24      	ldr	r4, [pc, #144]	@ (3ed4 <DMShortPixelsCommand(char const*, char const*, unsigned int, void const*)+0x160>)
    3e42:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
    3e44:	4613      	mov	r3, r2
    3e46:	005b      	lsls	r3, r3, #1
    3e48:	4413      	add	r3, r2
    3e4a:	4423      	add	r3, r4
    3e4c:	781b      	ldrb	r3, [r3, #0]
    3e4e:	461d      	mov	r5, r3
    3e50:	4c20      	ldr	r4, [pc, #128]	@ (3ed4 <DMShortPixelsCommand(char const*, char const*, unsigned int, void const*)+0x160>)
    3e52:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
    3e54:	4613      	mov	r3, r2
    3e56:	005b      	lsls	r3, r3, #1
    3e58:	4413      	add	r3, r2
    3e5a:	4423      	add	r3, r4
    3e5c:	3301      	adds	r3, #1
    3e5e:	781b      	ldrb	r3, [r3, #0]
    3e60:	461e      	mov	r6, r3
    3e62:	4c1c      	ldr	r4, [pc, #112]	@ (3ed4 <DMShortPixelsCommand(char const*, char const*, unsigned int, void const*)+0x160>)
    3e64:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
    3e66:	4613      	mov	r3, r2
    3e68:	005b      	lsls	r3, r3, #1
    3e6a:	4413      	add	r3, r2
    3e6c:	4423      	add	r3, r4
    3e6e:	3302      	adds	r3, #2
    3e70:	781b      	ldrb	r3, [r3, #0]
    3e72:	461c      	mov	r4, r3
    3e74:	0200      	lsls	r0, r0, #8
    3e76:	4632      	mov	r2, r6
    3e78:	0092      	lsls	r2, r2, #2
    3e7a:	4432      	add	r2, r6
    3e7c:	00d3      	lsls	r3, r2, #3
    3e7e:	461a      	mov	r2, r3
    3e80:	462b      	mov	r3, r5
    3e82:	009b      	lsls	r3, r3, #2
    3e84:	442b      	add	r3, r5
    3e86:	015b      	lsls	r3, r3, #5
    3e88:	4413      	add	r3, r2
    3e8a:	4423      	add	r3, r4
    3e8c:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
				printf("\nDMShortPixelsCommand: Set actuator %lu to %lu", (unsigned long)i, (unsigned long)Pixel);
    3e90:	8b7b      	ldrh	r3, [r7, #26]
    3e92:	461a      	mov	r2, r3
    3e94:	6a79      	ldr	r1, [r7, #36]	@ 0x24
    3e96:	4813      	ldr	r0, [pc, #76]	@ (3ee4 <DMShortPixelsCommand(char const*, char const*, unsigned int, void const*)+0x170>)
    3e98:	f003 f848 	bl	6f2c <iprintf>
		for (i = A; i < DMMaxActuators; i++)
    3e9c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    3e9e:	3301      	adds	r3, #1
    3ea0:	627b      	str	r3, [r7, #36]	@ 0x24
    3ea2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    3ea4:	f5b3 7f70 	cmp.w	r3, #960	@ 0x3c0
    3ea8:	d38e      	bcc.n	3dc8 <DMShortPixelsCommand(char const*, char const*, unsigned int, void const*)+0x54>
    3eaa:	e004      	b.n	3eb6 <DMShortPixelsCommand(char const*, char const*, unsigned int, void const*)+0x142>
		}
	}
	//query?
	else
	{
		printf("\n\nDMShortPixelsCommand: No parameters given; querying...\n");
    3eac:	480e      	ldr	r0, [pc, #56]	@ (3ee8 <DMShortPixelsCommand(char const*, char const*, unsigned int, void const*)+0x174>)
    3eae:	f003 f8e1 	bl	7074 <puts>
    3eb2:	e000      	b.n	3eb6 <DMShortPixelsCommand(char const*, char const*, unsigned int, void const*)+0x142>
			if (nullptr == PixStr) { break; }
    3eb4:	bf00      	nop
		
	}
		
    return(ParamsLen);
    3eb6:	687b      	ldr	r3, [r7, #4]
    3eb8:	b25b      	sxtb	r3, r3
}
    3eba:	4618      	mov	r0, r3
    3ebc:	372c      	adds	r7, #44	@ 0x2c
    3ebe:	46bd      	mov	sp, r7
    3ec0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3ec2:	bf00      	nop
    3ec4:	2000003c 	.word	0x2000003c
    3ec8:	0000a5ec 	.word	0x0000a5ec
    3ecc:	0000a62c 	.word	0x0000a62c
    3ed0:	0000a634 	.word	0x0000a634
    3ed4:	200009e0 	.word	0x200009e0
    3ed8:	0000a638 	.word	0x0000a638
    3edc:	00009dcc 	.word	0x00009dcc
    3ee0:	20000040 	.word	0x20000040
    3ee4:	0000a684 	.word	0x0000a684
    3ee8:	0000a6b4 	.word	0x0000a6b4

00003eec <DMDitherCommand(char const*, char const*, unsigned int, void const*)>:

int8_t DMDitherCommand(char const* Name, char const* Params, const size_t ParamsLen, const void* Argument)
{
    3eec:	b5f0      	push	{r4, r5, r6, r7, lr}
    3eee:	b08b      	sub	sp, #44	@ 0x2c
    3ef0:	af00      	add	r7, sp, #0
    3ef2:	60f8      	str	r0, [r7, #12]
    3ef4:	60b9      	str	r1, [r7, #8]
    3ef6:	607a      	str	r2, [r7, #4]
    3ef8:	603b      	str	r3, [r7, #0]
	if (nullptr == DM)
    3efa:	4b67      	ldr	r3, [pc, #412]	@ (4098 <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0x1ac>)
    3efc:	681b      	ldr	r3, [r3, #0]
    3efe:	2b00      	cmp	r3, #0
    3f00:	d105      	bne.n	3f0e <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0x22>
	{
		printf("\nDMDitherCommand: DM pointer is NULL! Firmware corrupted!\n");	
    3f02:	4866      	ldr	r0, [pc, #408]	@ (409c <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0x1b0>)
    3f04:	f003 f8b6 	bl	7074 <puts>
		return(ParamsLen);
    3f08:	687b      	ldr	r3, [r7, #4]
    3f0a:	b25b      	sxtb	r3, r3
    3f0c:	e0c0      	b.n	4090 <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0x1a4>
	}

	unsigned long A = 0;
    3f0e:	2300      	movs	r3, #0
    3f10:	617b      	str	r3, [r7, #20]
	
	strtok(const_cast<char*>(Params)," ,\t\r\n");
    3f12:	4963      	ldr	r1, [pc, #396]	@ (40a0 <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0x1b4>)
    3f14:	68b8      	ldr	r0, [r7, #8]
    3f16:	f003 f9e1 	bl	72dc <strtok>

	//Convert start pixel
	int8_t numfound = sscanf(Params, "%lu", &A);
    3f1a:	f107 0314 	add.w	r3, r7, #20
    3f1e:	461a      	mov	r2, r3
    3f20:	4960      	ldr	r1, [pc, #384]	@ (40a4 <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0x1b8>)
    3f22:	68b8      	ldr	r0, [r7, #8]
    3f24:	f003 f8ae 	bl	7084 <siscanf>
    3f28:	4603      	mov	r3, r0
    3f2a:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
	if (numfound >= 1)
    3f2e:	f997 3023 	ldrsb.w	r3, [r7, #35]	@ 0x23
    3f32:	2b00      	cmp	r3, #0
    3f34:	f340 80a5 	ble.w	4082 <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0x196>
	{
		//Now we start building an array of pixels...icky parsing lol
		size_t i = 0;
    3f38:	2300      	movs	r3, #0
    3f3a:	627b      	str	r3, [r7, #36]	@ 0x24
		for (i = A; i < DMMaxActuators; i++)
    3f3c:	697b      	ldr	r3, [r7, #20]
    3f3e:	627b      	str	r3, [r7, #36]	@ 0x24
    3f40:	e099      	b.n	4076 <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0x18a>
		{
			char* PixStr = strtok((char*)nullptr," ,\t\r\n");
    3f42:	4957      	ldr	r1, [pc, #348]	@ (40a0 <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0x1b4>)
    3f44:	2000      	movs	r0, #0
    3f46:	f003 f9c9 	bl	72dc <strtok>
    3f4a:	61f8      	str	r0, [r7, #28]
			if (nullptr == PixStr) { break; }
    3f4c:	69fb      	ldr	r3, [r7, #28]
    3f4e:	2b00      	cmp	r3, #0
    3f50:	f000 809b 	beq.w	408a <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0x19e>
			uint16_t Pixel = atoi(PixStr);
    3f54:	69f8      	ldr	r0, [r7, #28]
    3f56:	f002 fde1 	bl	6b1c <atoi>
    3f5a:	4603      	mov	r3, r0
    3f5c:	837b      	strh	r3, [r7, #26]
			
			//What D/A ram does this pix belong to?
			if ( (DMMappings.Mappings[i].ControllerBoardIndex >= DMMaxControllerBoards) || (DMMappings.Mappings[i].ControllerBoardIndex >= DMMaxControllerBoards) || (DMMappings.Mappings[i].ControllerBoardIndex >= DMMaxControllerBoards) )
    3f5e:	4952      	ldr	r1, [pc, #328]	@ (40a8 <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0x1bc>)
    3f60:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
    3f62:	4613      	mov	r3, r2
    3f64:	005b      	lsls	r3, r3, #1
    3f66:	4413      	add	r3, r2
    3f68:	440b      	add	r3, r1
    3f6a:	781b      	ldrb	r3, [r3, #0]
    3f6c:	2b05      	cmp	r3, #5
    3f6e:	d811      	bhi.n	3f94 <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0xa8>
    3f70:	494d      	ldr	r1, [pc, #308]	@ (40a8 <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0x1bc>)
    3f72:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
    3f74:	4613      	mov	r3, r2
    3f76:	005b      	lsls	r3, r3, #1
    3f78:	4413      	add	r3, r2
    3f7a:	440b      	add	r3, r1
    3f7c:	781b      	ldrb	r3, [r3, #0]
    3f7e:	2b05      	cmp	r3, #5
    3f80:	d808      	bhi.n	3f94 <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0xa8>
    3f82:	4949      	ldr	r1, [pc, #292]	@ (40a8 <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0x1bc>)
    3f84:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
    3f86:	4613      	mov	r3, r2
    3f88:	005b      	lsls	r3, r3, #1
    3f8a:	4413      	add	r3, r2
    3f8c:	440b      	add	r3, r1
    3f8e:	781b      	ldrb	r3, [r3, #0]
    3f90:	2b05      	cmp	r3, #5
    3f92:	d910      	bls.n	3fb6 <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0xca>
			{
				printf("\nDMDitherCommand: Invalid mapping %lu; please reinitialize mappings!: ", (unsigned long)i);
    3f94:	6a79      	ldr	r1, [r7, #36]	@ 0x24
    3f96:	4845      	ldr	r0, [pc, #276]	@ (40ac <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0x1c0>)
    3f98:	f002 ffc8 	bl	6f2c <iprintf>
				DMMappings.Mappings[i].formatf();
    3f9c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
    3f9e:	4613      	mov	r3, r2
    3fa0:	005b      	lsls	r3, r3, #1
    3fa2:	4413      	add	r3, r2
    3fa4:	4a40      	ldr	r2, [pc, #256]	@ (40a8 <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0x1bc>)
    3fa6:	4413      	add	r3, r2
    3fa8:	4618      	mov	r0, r3
    3faa:	f7ff f8bd 	bl	3128 <CGraphDMMappingPayload::formatf() const>
				printf("\n\n");
    3fae:	4840      	ldr	r0, [pc, #256]	@ (40b0 <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0x1c4>)
    3fb0:	f003 f860 	bl	7074 <puts>
    3fb4:	e05c      	b.n	4070 <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0x184>
			}
			//Yay, we got here, things are actaully correct and we have something to do!
			else
			{
				dRAM->DacSetpoints[DMMappings.Mappings[i].ControllerBoardIndex][DMMappings.Mappings[i].DacIndex][DMMappings.Mappings[i].DacChannel] |= (uint8_t)Pixel; //<<8 cause we really want 24b values when we dither
    3fb6:	4b3f      	ldr	r3, [pc, #252]	@ (40b4 <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0x1c8>)
    3fb8:	6819      	ldr	r1, [r3, #0]
    3fba:	483b      	ldr	r0, [pc, #236]	@ (40a8 <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0x1bc>)
    3fbc:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
    3fbe:	4613      	mov	r3, r2
    3fc0:	005b      	lsls	r3, r3, #1
    3fc2:	4413      	add	r3, r2
    3fc4:	4403      	add	r3, r0
    3fc6:	781b      	ldrb	r3, [r3, #0]
    3fc8:	461c      	mov	r4, r3
    3fca:	4837      	ldr	r0, [pc, #220]	@ (40a8 <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0x1bc>)
    3fcc:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
    3fce:	4613      	mov	r3, r2
    3fd0:	005b      	lsls	r3, r3, #1
    3fd2:	4413      	add	r3, r2
    3fd4:	4403      	add	r3, r0
    3fd6:	3301      	adds	r3, #1
    3fd8:	781b      	ldrb	r3, [r3, #0]
    3fda:	461d      	mov	r5, r3
    3fdc:	4832      	ldr	r0, [pc, #200]	@ (40a8 <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0x1bc>)
    3fde:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
    3fe0:	4613      	mov	r3, r2
    3fe2:	005b      	lsls	r3, r3, #1
    3fe4:	4413      	add	r3, r2
    3fe6:	4403      	add	r3, r0
    3fe8:	3302      	adds	r3, #2
    3fea:	781b      	ldrb	r3, [r3, #0]
    3fec:	4618      	mov	r0, r3
    3fee:	462a      	mov	r2, r5
    3ff0:	0092      	lsls	r2, r2, #2
    3ff2:	442a      	add	r2, r5
    3ff4:	00d3      	lsls	r3, r2, #3
    3ff6:	461a      	mov	r2, r3
    3ff8:	4623      	mov	r3, r4
    3ffa:	009b      	lsls	r3, r3, #2
    3ffc:	4423      	add	r3, r4
    3ffe:	015b      	lsls	r3, r3, #5
    4000:	4413      	add	r3, r2
    4002:	4403      	add	r3, r0
    4004:	f851 0023 	ldr.w	r0, [r1, r3, lsl #2]
    4008:	8b7b      	ldrh	r3, [r7, #26]
    400a:	b2db      	uxtb	r3, r3
    400c:	469c      	mov	ip, r3
    400e:	4b29      	ldr	r3, [pc, #164]	@ (40b4 <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0x1c8>)
    4010:	6819      	ldr	r1, [r3, #0]
    4012:	4c25      	ldr	r4, [pc, #148]	@ (40a8 <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0x1bc>)
    4014:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
    4016:	4613      	mov	r3, r2
    4018:	005b      	lsls	r3, r3, #1
    401a:	4413      	add	r3, r2
    401c:	4423      	add	r3, r4
    401e:	781b      	ldrb	r3, [r3, #0]
    4020:	461d      	mov	r5, r3
    4022:	4c21      	ldr	r4, [pc, #132]	@ (40a8 <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0x1bc>)
    4024:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
    4026:	4613      	mov	r3, r2
    4028:	005b      	lsls	r3, r3, #1
    402a:	4413      	add	r3, r2
    402c:	4423      	add	r3, r4
    402e:	3301      	adds	r3, #1
    4030:	781b      	ldrb	r3, [r3, #0]
    4032:	461e      	mov	r6, r3
    4034:	4c1c      	ldr	r4, [pc, #112]	@ (40a8 <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0x1bc>)
    4036:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
    4038:	4613      	mov	r3, r2
    403a:	005b      	lsls	r3, r3, #1
    403c:	4413      	add	r3, r2
    403e:	4423      	add	r3, r4
    4040:	3302      	adds	r3, #2
    4042:	781b      	ldrb	r3, [r3, #0]
    4044:	461c      	mov	r4, r3
    4046:	ea40 000c 	orr.w	r0, r0, ip
    404a:	4632      	mov	r2, r6
    404c:	0092      	lsls	r2, r2, #2
    404e:	4432      	add	r2, r6
    4050:	00d3      	lsls	r3, r2, #3
    4052:	461a      	mov	r2, r3
    4054:	462b      	mov	r3, r5
    4056:	009b      	lsls	r3, r3, #2
    4058:	442b      	add	r3, r5
    405a:	015b      	lsls	r3, r3, #5
    405c:	4413      	add	r3, r2
    405e:	4423      	add	r3, r4
    4060:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
				printf("\nDMDitherCommand: Set actuator %lu to %lu", (unsigned long)i, (unsigned long)Pixel);
    4064:	8b7b      	ldrh	r3, [r7, #26]
    4066:	461a      	mov	r2, r3
    4068:	6a79      	ldr	r1, [r7, #36]	@ 0x24
    406a:	4813      	ldr	r0, [pc, #76]	@ (40b8 <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0x1cc>)
    406c:	f002 ff5e 	bl	6f2c <iprintf>
		for (i = A; i < DMMaxActuators; i++)
    4070:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    4072:	3301      	adds	r3, #1
    4074:	627b      	str	r3, [r7, #36]	@ 0x24
    4076:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    4078:	f5b3 7f70 	cmp.w	r3, #960	@ 0x3c0
    407c:	f4ff af61 	bcc.w	3f42 <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0x56>
    4080:	e004      	b.n	408c <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0x1a0>
		}
	}
	//query?
	else
	{
		printf("\n\nDMDitherCommand: No parameters given; querying...\n");
    4082:	480e      	ldr	r0, [pc, #56]	@ (40bc <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0x1d0>)
    4084:	f002 fff6 	bl	7074 <puts>
    4088:	e000      	b.n	408c <DMDitherCommand(char const*, char const*, unsigned int, void const*)+0x1a0>
			if (nullptr == PixStr) { break; }
    408a:	bf00      	nop
		
	}
		
    return(ParamsLen);
    408c:	687b      	ldr	r3, [r7, #4]
    408e:	b25b      	sxtb	r3, r3
}
    4090:	4618      	mov	r0, r3
    4092:	372c      	adds	r7, #44	@ 0x2c
    4094:	46bd      	mov	sp, r7
    4096:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4098:	2000003c 	.word	0x2000003c
    409c:	0000a6f0 	.word	0x0000a6f0
    40a0:	0000a62c 	.word	0x0000a62c
    40a4:	0000a634 	.word	0x0000a634
    40a8:	200009e0 	.word	0x200009e0
    40ac:	0000a72c 	.word	0x0000a72c
    40b0:	00009dcc 	.word	0x00009dcc
    40b4:	20000040 	.word	0x20000040
    40b8:	0000a774 	.word	0x0000a774
    40bc:	0000a7a0 	.word	0x0000a7a0

000040c0 <DMLongPixelsCommand(char const*, char const*, unsigned int, void const*)>:

int8_t DMLongPixelsCommand(char const* Name, char const* Params, const size_t ParamsLen, const void* Argument)
{
    40c0:	b5f0      	push	{r4, r5, r6, r7, lr}
    40c2:	b08b      	sub	sp, #44	@ 0x2c
    40c4:	af00      	add	r7, sp, #0
    40c6:	60f8      	str	r0, [r7, #12]
    40c8:	60b9      	str	r1, [r7, #8]
    40ca:	607a      	str	r2, [r7, #4]
    40cc:	603b      	str	r3, [r7, #0]
	if (nullptr == DM)
    40ce:	4b4f      	ldr	r3, [pc, #316]	@ (420c <DMLongPixelsCommand(char const*, char const*, unsigned int, void const*)+0x14c>)
    40d0:	681b      	ldr	r3, [r3, #0]
    40d2:	2b00      	cmp	r3, #0
    40d4:	d105      	bne.n	40e2 <DMLongPixelsCommand(char const*, char const*, unsigned int, void const*)+0x22>
	{
		printf("\nDMLongPixelsCommand: DM pointer is NULL! Firmware corrupted!\n");	
    40d6:	484e      	ldr	r0, [pc, #312]	@ (4210 <DMLongPixelsCommand(char const*, char const*, unsigned int, void const*)+0x150>)
    40d8:	f002 ffcc 	bl	7074 <puts>
		return(ParamsLen);
    40dc:	687b      	ldr	r3, [r7, #4]
    40de:	b25b      	sxtb	r3, r3
    40e0:	e090      	b.n	4204 <DMLongPixelsCommand(char const*, char const*, unsigned int, void const*)+0x144>
	}

	unsigned long A = 0;
    40e2:	2300      	movs	r3, #0
    40e4:	617b      	str	r3, [r7, #20]
	
	strtok(const_cast<char*>(Params)," ,\t\r\n");
    40e6:	494b      	ldr	r1, [pc, #300]	@ (4214 <DMLongPixelsCommand(char const*, char const*, unsigned int, void const*)+0x154>)
    40e8:	68b8      	ldr	r0, [r7, #8]
    40ea:	f003 f8f7 	bl	72dc <strtok>

	//Convert start pixel
	int8_t numfound = sscanf(Params, "%lu", &A);
    40ee:	f107 0314 	add.w	r3, r7, #20
    40f2:	461a      	mov	r2, r3
    40f4:	4948      	ldr	r1, [pc, #288]	@ (4218 <DMLongPixelsCommand(char const*, char const*, unsigned int, void const*)+0x158>)
    40f6:	68b8      	ldr	r0, [r7, #8]
    40f8:	f002 ffc4 	bl	7084 <siscanf>
    40fc:	4603      	mov	r3, r0
    40fe:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
	if (numfound >= 1)
    4102:	f997 3023 	ldrsb.w	r3, [r7, #35]	@ 0x23
    4106:	2b00      	cmp	r3, #0
    4108:	dd75      	ble.n	41f6 <DMLongPixelsCommand(char const*, char const*, unsigned int, void const*)+0x136>
	{
		//Now we start building an array of pixels...icky parsing lol
		size_t i = 0;
    410a:	2300      	movs	r3, #0
    410c:	627b      	str	r3, [r7, #36]	@ 0x24
		for (i = A; i < DMMaxActuators; i++)
    410e:	697b      	ldr	r3, [r7, #20]
    4110:	627b      	str	r3, [r7, #36]	@ 0x24
    4112:	e06b      	b.n	41ec <DMLongPixelsCommand(char const*, char const*, unsigned int, void const*)+0x12c>
		{
			char* PixStr = strtok((char*)nullptr," ,\t\r\n");
    4114:	493f      	ldr	r1, [pc, #252]	@ (4214 <DMLongPixelsCommand(char const*, char const*, unsigned int, void const*)+0x154>)
    4116:	2000      	movs	r0, #0
    4118:	f003 f8e0 	bl	72dc <strtok>
    411c:	61f8      	str	r0, [r7, #28]
			if (nullptr == PixStr) { break; }
    411e:	69fb      	ldr	r3, [r7, #28]
    4120:	2b00      	cmp	r3, #0
    4122:	d06c      	beq.n	41fe <DMLongPixelsCommand(char const*, char const*, unsigned int, void const*)+0x13e>
			uint16_t Pixel = atoi(PixStr);
    4124:	69f8      	ldr	r0, [r7, #28]
    4126:	f002 fcf9 	bl	6b1c <atoi>
    412a:	4603      	mov	r3, r0
    412c:	837b      	strh	r3, [r7, #26]
			
			//What D/A ram does this pix belong to?
			if ( (DMMappings.Mappings[i].ControllerBoardIndex >= DMMaxControllerBoards) || (DMMappings.Mappings[i].ControllerBoardIndex >= DMMaxControllerBoards) || (DMMappings.Mappings[i].ControllerBoardIndex >= DMMaxControllerBoards) )
    412e:	493b      	ldr	r1, [pc, #236]	@ (421c <DMLongPixelsCommand(char const*, char const*, unsigned int, void const*)+0x15c>)
    4130:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
    4132:	4613      	mov	r3, r2
    4134:	005b      	lsls	r3, r3, #1
    4136:	4413      	add	r3, r2
    4138:	440b      	add	r3, r1
    413a:	781b      	ldrb	r3, [r3, #0]
    413c:	2b05      	cmp	r3, #5
    413e:	d811      	bhi.n	4164 <DMLongPixelsCommand(char const*, char const*, unsigned int, void const*)+0xa4>
    4140:	4936      	ldr	r1, [pc, #216]	@ (421c <DMLongPixelsCommand(char const*, char const*, unsigned int, void const*)+0x15c>)
    4142:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
    4144:	4613      	mov	r3, r2
    4146:	005b      	lsls	r3, r3, #1
    4148:	4413      	add	r3, r2
    414a:	440b      	add	r3, r1
    414c:	781b      	ldrb	r3, [r3, #0]
    414e:	2b05      	cmp	r3, #5
    4150:	d808      	bhi.n	4164 <DMLongPixelsCommand(char const*, char const*, unsigned int, void const*)+0xa4>
    4152:	4932      	ldr	r1, [pc, #200]	@ (421c <DMLongPixelsCommand(char const*, char const*, unsigned int, void const*)+0x15c>)
    4154:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
    4156:	4613      	mov	r3, r2
    4158:	005b      	lsls	r3, r3, #1
    415a:	4413      	add	r3, r2
    415c:	440b      	add	r3, r1
    415e:	781b      	ldrb	r3, [r3, #0]
    4160:	2b05      	cmp	r3, #5
    4162:	d910      	bls.n	4186 <DMLongPixelsCommand(char const*, char const*, unsigned int, void const*)+0xc6>
			{
				printf("\nDMLongPixelsCommand: Invalid mapping %lu; please reinitialize mappings!: ", (unsigned long)i);
    4164:	6a79      	ldr	r1, [r7, #36]	@ 0x24
    4166:	482e      	ldr	r0, [pc, #184]	@ (4220 <DMLongPixelsCommand(char const*, char const*, unsigned int, void const*)+0x160>)
    4168:	f002 fee0 	bl	6f2c <iprintf>
				DMMappings.Mappings[i].formatf();
    416c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
    416e:	4613      	mov	r3, r2
    4170:	005b      	lsls	r3, r3, #1
    4172:	4413      	add	r3, r2
    4174:	4a29      	ldr	r2, [pc, #164]	@ (421c <DMLongPixelsCommand(char const*, char const*, unsigned int, void const*)+0x15c>)
    4176:	4413      	add	r3, r2
    4178:	4618      	mov	r0, r3
    417a:	f7fe ffd5 	bl	3128 <CGraphDMMappingPayload::formatf() const>
				printf("\n\n");
    417e:	4829      	ldr	r0, [pc, #164]	@ (4224 <DMLongPixelsCommand(char const*, char const*, unsigned int, void const*)+0x164>)
    4180:	f002 ff78 	bl	7074 <puts>
    4184:	e02f      	b.n	41e6 <DMLongPixelsCommand(char const*, char const*, unsigned int, void const*)+0x126>
			}
			//Yay, we got here, things are actaully correct and we have something to do!
			else
			{
				dRAM->DacSetpoints[DMMappings.Mappings[i].ControllerBoardIndex][DMMappings.Mappings[i].DacIndex][DMMappings.Mappings[i].DacChannel] =  (uint32_t)Pixel & 0x00FFFFFF; //<<8 cause we really want 24b values when we dither
    4186:	4b28      	ldr	r3, [pc, #160]	@ (4228 <DMLongPixelsCommand(char const*, char const*, unsigned int, void const*)+0x168>)
    4188:	6819      	ldr	r1, [r3, #0]
    418a:	4824      	ldr	r0, [pc, #144]	@ (421c <DMLongPixelsCommand(char const*, char const*, unsigned int, void const*)+0x15c>)
    418c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
    418e:	4613      	mov	r3, r2
    4190:	005b      	lsls	r3, r3, #1
    4192:	4413      	add	r3, r2
    4194:	4403      	add	r3, r0
    4196:	781b      	ldrb	r3, [r3, #0]
    4198:	461c      	mov	r4, r3
    419a:	4820      	ldr	r0, [pc, #128]	@ (421c <DMLongPixelsCommand(char const*, char const*, unsigned int, void const*)+0x15c>)
    419c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
    419e:	4613      	mov	r3, r2
    41a0:	005b      	lsls	r3, r3, #1
    41a2:	4413      	add	r3, r2
    41a4:	4403      	add	r3, r0
    41a6:	3301      	adds	r3, #1
    41a8:	781b      	ldrb	r3, [r3, #0]
    41aa:	461d      	mov	r5, r3
    41ac:	481b      	ldr	r0, [pc, #108]	@ (421c <DMLongPixelsCommand(char const*, char const*, unsigned int, void const*)+0x15c>)
    41ae:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
    41b0:	4613      	mov	r3, r2
    41b2:	005b      	lsls	r3, r3, #1
    41b4:	4413      	add	r3, r2
    41b6:	4403      	add	r3, r0
    41b8:	3302      	adds	r3, #2
    41ba:	781b      	ldrb	r3, [r3, #0]
    41bc:	461e      	mov	r6, r3
    41be:	8b78      	ldrh	r0, [r7, #26]
    41c0:	462a      	mov	r2, r5
    41c2:	0092      	lsls	r2, r2, #2
    41c4:	442a      	add	r2, r5
    41c6:	00d3      	lsls	r3, r2, #3
    41c8:	461a      	mov	r2, r3
    41ca:	4623      	mov	r3, r4
    41cc:	009b      	lsls	r3, r3, #2
    41ce:	4423      	add	r3, r4
    41d0:	015b      	lsls	r3, r3, #5
    41d2:	4413      	add	r3, r2
    41d4:	4433      	add	r3, r6
    41d6:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
				printf("\nDMLongPixelsCommand: Set actuator %lu to %lu", (unsigned long)i, (unsigned long)Pixel);
    41da:	8b7b      	ldrh	r3, [r7, #26]
    41dc:	461a      	mov	r2, r3
    41de:	6a79      	ldr	r1, [r7, #36]	@ 0x24
    41e0:	4812      	ldr	r0, [pc, #72]	@ (422c <DMLongPixelsCommand(char const*, char const*, unsigned int, void const*)+0x16c>)
    41e2:	f002 fea3 	bl	6f2c <iprintf>
		for (i = A; i < DMMaxActuators; i++)
    41e6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    41e8:	3301      	adds	r3, #1
    41ea:	627b      	str	r3, [r7, #36]	@ 0x24
    41ec:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    41ee:	f5b3 7f70 	cmp.w	r3, #960	@ 0x3c0
    41f2:	d38f      	bcc.n	4114 <DMLongPixelsCommand(char const*, char const*, unsigned int, void const*)+0x54>
    41f4:	e004      	b.n	4200 <DMLongPixelsCommand(char const*, char const*, unsigned int, void const*)+0x140>
		}
	}
	//query?
	else
	{
		printf("\n\nDMLongPixelsCommand: No parameters given; querying...\n");
    41f6:	480e      	ldr	r0, [pc, #56]	@ (4230 <DMLongPixelsCommand(char const*, char const*, unsigned int, void const*)+0x170>)
    41f8:	f002 ff3c 	bl	7074 <puts>
    41fc:	e000      	b.n	4200 <DMLongPixelsCommand(char const*, char const*, unsigned int, void const*)+0x140>
			if (nullptr == PixStr) { break; }
    41fe:	bf00      	nop
		
	}
		
    return(ParamsLen);
    4200:	687b      	ldr	r3, [r7, #4]
    4202:	b25b      	sxtb	r3, r3
}
    4204:	4618      	mov	r0, r3
    4206:	372c      	adds	r7, #44	@ 0x2c
    4208:	46bd      	mov	sp, r7
    420a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    420c:	2000003c 	.word	0x2000003c
    4210:	0000a7d4 	.word	0x0000a7d4
    4214:	0000a62c 	.word	0x0000a62c
    4218:	0000a634 	.word	0x0000a634
    421c:	200009e0 	.word	0x200009e0
    4220:	0000a814 	.word	0x0000a814
    4224:	00009dcc 	.word	0x00009dcc
    4228:	20000040 	.word	0x20000040
    422c:	0000a860 	.word	0x0000a860
    4230:	0000a890 	.word	0x0000a890

00004234 <BinaryCmd::BinaryCmd(unsigned long, char const*, signed char (*)(unsigned long, char const*, unsigned int, void const*))>:
{
	uint32_t Name; ///The acutal command
	char const* Help; ///Any instructions for the command we'd like users to see
	int8_t (*Response)(const uint32_t, char const*, const size_t, const void*); ///callback function to excecute this command when it's located.

	BinaryCmd(const uint32_t name, const char* help, int8_t (*resp)(const uint32_t, char const*, const size_t, const void*) )
    4234:	b480      	push	{r7}
    4236:	b085      	sub	sp, #20
    4238:	af00      	add	r7, sp, #0
    423a:	60f8      	str	r0, [r7, #12]
    423c:	60b9      	str	r1, [r7, #8]
    423e:	607a      	str	r2, [r7, #4]
    4240:	603b      	str	r3, [r7, #0]
		: Name(name), Help(help), Response(resp)
    4242:	68fb      	ldr	r3, [r7, #12]
    4244:	68ba      	ldr	r2, [r7, #8]
    4246:	601a      	str	r2, [r3, #0]
    4248:	68fb      	ldr	r3, [r7, #12]
    424a:	687a      	ldr	r2, [r7, #4]
    424c:	605a      	str	r2, [r3, #4]
    424e:	68fb      	ldr	r3, [r7, #12]
    4250:	683a      	ldr	r2, [r7, #0]
    4252:	609a      	str	r2, [r3, #8]
	{ }
    4254:	68fb      	ldr	r3, [r7, #12]
    4256:	4618      	mov	r0, r3
    4258:	3714      	adds	r7, #20
    425a:	46bd      	mov	sp, r7
    425c:	bc80      	pop	{r7}
    425e:	4770      	bx	lr

00004260 <__static_initialization_and_destruction_0()>:

};
#endif

//Calculate the number of commands instanciated in the system - links with CmdSystem.cpp.o
const uint8_t NumBinaryCmds = sizeof(BinaryCmds) / sizeof(BinaryCmds[0]);
    4260:	b598      	push	{r3, r4, r7, lr}
    4262:	af00      	add	r7, sp, #0
};
    4264:	4c24      	ldr	r4, [pc, #144]	@ (42f8 <__static_initialization_and_destruction_0()+0x98>)
    4266:	4b25      	ldr	r3, [pc, #148]	@ (42fc <__static_initialization_and_destruction_0()+0x9c>)
    4268:	4a25      	ldr	r2, [pc, #148]	@ (4300 <__static_initialization_and_destruction_0()+0xa0>)
    426a:	f241 0101 	movw	r1, #4097	@ 0x1001
    426e:	4620      	mov	r0, r4
    4270:	f7ff ffe0 	bl	4234 <BinaryCmd::BinaryCmd(unsigned long, char const*, signed char (*)(unsigned long, char const*, unsigned int, void const*))>
    4274:	340c      	adds	r4, #12
    4276:	4b23      	ldr	r3, [pc, #140]	@ (4304 <__static_initialization_and_destruction_0()+0xa4>)
    4278:	4a23      	ldr	r2, [pc, #140]	@ (4308 <__static_initialization_and_destruction_0()+0xa8>)
    427a:	f243 0102 	movw	r1, #12290	@ 0x3002
    427e:	4620      	mov	r0, r4
    4280:	f7ff ffd8 	bl	4234 <BinaryCmd::BinaryCmd(unsigned long, char const*, signed char (*)(unsigned long, char const*, unsigned int, void const*))>
    4284:	340c      	adds	r4, #12
    4286:	4b21      	ldr	r3, [pc, #132]	@ (430c <__static_initialization_and_destruction_0()+0xac>)
    4288:	4a21      	ldr	r2, [pc, #132]	@ (4310 <__static_initialization_and_destruction_0()+0xb0>)
    428a:	f243 0104 	movw	r1, #12292	@ 0x3004
    428e:	4620      	mov	r0, r4
    4290:	f7ff ffd0 	bl	4234 <BinaryCmd::BinaryCmd(unsigned long, char const*, signed char (*)(unsigned long, char const*, unsigned int, void const*))>
    4294:	340c      	adds	r4, #12
    4296:	4b1f      	ldr	r3, [pc, #124]	@ (4314 <__static_initialization_and_destruction_0()+0xb4>)
    4298:	4a1f      	ldr	r2, [pc, #124]	@ (4318 <__static_initialization_and_destruction_0()+0xb8>)
    429a:	f243 0109 	movw	r1, #12297	@ 0x3009
    429e:	4620      	mov	r0, r4
    42a0:	f7ff ffc8 	bl	4234 <BinaryCmd::BinaryCmd(unsigned long, char const*, signed char (*)(unsigned long, char const*, unsigned int, void const*))>
    42a4:	340c      	adds	r4, #12
    42a6:	4b1d      	ldr	r3, [pc, #116]	@ (431c <__static_initialization_and_destruction_0()+0xbc>)
    42a8:	4a1d      	ldr	r2, [pc, #116]	@ (4320 <__static_initialization_and_destruction_0()+0xc0>)
    42aa:	f243 0105 	movw	r1, #12293	@ 0x3005
    42ae:	4620      	mov	r0, r4
    42b0:	f7ff ffc0 	bl	4234 <BinaryCmd::BinaryCmd(unsigned long, char const*, signed char (*)(unsigned long, char const*, unsigned int, void const*))>
    42b4:	340c      	adds	r4, #12
    42b6:	4b1b      	ldr	r3, [pc, #108]	@ (4324 <__static_initialization_and_destruction_0()+0xc4>)
    42b8:	4a1b      	ldr	r2, [pc, #108]	@ (4328 <__static_initialization_and_destruction_0()+0xc8>)
    42ba:	f243 010b 	movw	r1, #12299	@ 0x300b
    42be:	4620      	mov	r0, r4
    42c0:	f7ff ffb8 	bl	4234 <BinaryCmd::BinaryCmd(unsigned long, char const*, signed char (*)(unsigned long, char const*, unsigned int, void const*))>
    42c4:	340c      	adds	r4, #12
    42c6:	4b19      	ldr	r3, [pc, #100]	@ (432c <__static_initialization_and_destruction_0()+0xcc>)
    42c8:	4a19      	ldr	r2, [pc, #100]	@ (4330 <__static_initialization_and_destruction_0()+0xd0>)
    42ca:	f243 010c 	movw	r1, #12300	@ 0x300c
    42ce:	4620      	mov	r0, r4
    42d0:	f7ff ffb0 	bl	4234 <BinaryCmd::BinaryCmd(unsigned long, char const*, signed char (*)(unsigned long, char const*, unsigned int, void const*))>
    42d4:	340c      	adds	r4, #12
    42d6:	4b17      	ldr	r3, [pc, #92]	@ (4334 <__static_initialization_and_destruction_0()+0xd4>)
    42d8:	4a17      	ldr	r2, [pc, #92]	@ (4338 <__static_initialization_and_destruction_0()+0xd8>)
    42da:	f243 010d 	movw	r1, #12301	@ 0x300d
    42de:	4620      	mov	r0, r4
    42e0:	f7ff ffa8 	bl	4234 <BinaryCmd::BinaryCmd(unsigned long, char const*, signed char (*)(unsigned long, char const*, unsigned int, void const*))>
    42e4:	f104 000c 	add.w	r0, r4, #12
    42e8:	4b14      	ldr	r3, [pc, #80]	@ (433c <__static_initialization_and_destruction_0()+0xdc>)
    42ea:	4a15      	ldr	r2, [pc, #84]	@ (4340 <__static_initialization_and_destruction_0()+0xe0>)
    42ec:	f243 010e 	movw	r1, #12302	@ 0x300e
    42f0:	f7ff ffa0 	bl	4234 <BinaryCmd::BinaryCmd(unsigned long, char const*, signed char (*)(unsigned long, char const*, unsigned int, void const*))>
const uint8_t NumBinaryCmds = sizeof(BinaryCmds) / sizeof(BinaryCmds[0]);
    42f4:	bf00      	nop
    42f6:	bd98      	pop	{r3, r4, r7, pc}
    42f8:	20000200 	.word	0x20000200
    42fc:	0000443d 	.word	0x0000443d
    4300:	0000a8e4 	.word	0x0000a8e4
    4304:	000044a9 	.word	0x000044a9
    4308:	0000a8fc 	.word	0x0000a8fc
    430c:	00004549 	.word	0x00004549
    4310:	0000a910 	.word	0x0000a910
    4314:	0000457d 	.word	0x0000457d
    4318:	0000a92c 	.word	0x0000a92c
    431c:	000044e9 	.word	0x000044e9
    4320:	0000a948 	.word	0x0000a948
    4324:	00004619 	.word	0x00004619
    4328:	0000a960 	.word	0x0000a960
    432c:	00004879 	.word	0x00004879
    4330:	0000a978 	.word	0x0000a978
    4334:	00004ba1 	.word	0x00004ba1
    4338:	0000a994 	.word	0x0000a994
    433c:	00004f15 	.word	0x00004f15
    4340:	0000a9ac 	.word	0x0000a9ac

00004344 <_GLOBAL__sub_I_BinaryCmds>:
    4344:	b580      	push	{r7, lr}
    4346:	af00      	add	r7, sp, #0
    4348:	f7ff ff8a 	bl	4260 <__static_initialization_and_destruction_0()>
    434c:	bd80      	pop	{r7, pc}

0000434e <CGraphDMMappingPayload::CGraphDMMappingPayload()>:
	CGraphDMMappingPayload() : ControllerBoardIndex(0), DacIndex(0), DacChannel(0) { }
    434e:	b480      	push	{r7}
    4350:	b083      	sub	sp, #12
    4352:	af00      	add	r7, sp, #0
    4354:	6078      	str	r0, [r7, #4]
    4356:	687b      	ldr	r3, [r7, #4]
    4358:	2200      	movs	r2, #0
    435a:	701a      	strb	r2, [r3, #0]
    435c:	687b      	ldr	r3, [r7, #4]
    435e:	2200      	movs	r2, #0
    4360:	705a      	strb	r2, [r3, #1]
    4362:	687b      	ldr	r3, [r7, #4]
    4364:	2200      	movs	r2, #0
    4366:	709a      	strb	r2, [r3, #2]
    4368:	687b      	ldr	r3, [r7, #4]
    436a:	4618      	mov	r0, r3
    436c:	370c      	adds	r7, #12
    436e:	46bd      	mov	sp, r7
    4370:	bc80      	pop	{r7}
    4372:	4770      	bx	lr

00004374 <CGraphDMMappings::CGraphDMMappings()>:
	CGraphDMMappings()
    4374:	b5b0      	push	{r4, r5, r7, lr}
    4376:	b084      	sub	sp, #16
    4378:	af00      	add	r7, sp, #0
    437a:	6078      	str	r0, [r7, #4]
	{
    437c:	687b      	ldr	r3, [r7, #4]
    437e:	f240 34bf 	movw	r4, #959	@ 0x3bf
    4382:	461d      	mov	r5, r3
    4384:	e004      	b.n	4390 <CGraphDMMappings::CGraphDMMappings()+0x1c>
    4386:	4628      	mov	r0, r5
    4388:	f7ff ffe1 	bl	434e <CGraphDMMappingPayload::CGraphDMMappingPayload()>
    438c:	3c01      	subs	r4, #1
    438e:	3503      	adds	r5, #3
    4390:	2c00      	cmp	r4, #0
    4392:	daf8      	bge.n	4386 <CGraphDMMappings::CGraphDMMappings()+0x12>
		uint8_t ControllerBoardIndex = 0;
    4394:	2300      	movs	r3, #0
    4396:	73fb      	strb	r3, [r7, #15]
		uint8_t DacIndex = 0;
    4398:	2300      	movs	r3, #0
    439a:	73bb      	strb	r3, [r7, #14]
		uint8_t DacChannel = 0;
    439c:	2300      	movs	r3, #0
    439e:	737b      	strb	r3, [r7, #13]
		for (size_t i = 0; i < DMMaxActuators; i++)
    43a0:	2300      	movs	r3, #0
    43a2:	60bb      	str	r3, [r7, #8]
    43a4:	e034      	b.n	4410 <CGraphDMMappings::CGraphDMMappings()+0x9c>
			Mappings[i].ControllerBoardIndex = ControllerBoardIndex;
    43a6:	6879      	ldr	r1, [r7, #4]
    43a8:	68ba      	ldr	r2, [r7, #8]
    43aa:	4613      	mov	r3, r2
    43ac:	005b      	lsls	r3, r3, #1
    43ae:	4413      	add	r3, r2
    43b0:	440b      	add	r3, r1
    43b2:	7bfa      	ldrb	r2, [r7, #15]
    43b4:	701a      	strb	r2, [r3, #0]
			Mappings[i].DacIndex = DacIndex;
    43b6:	6879      	ldr	r1, [r7, #4]
    43b8:	68ba      	ldr	r2, [r7, #8]
    43ba:	4613      	mov	r3, r2
    43bc:	005b      	lsls	r3, r3, #1
    43be:	4413      	add	r3, r2
    43c0:	440b      	add	r3, r1
    43c2:	3301      	adds	r3, #1
    43c4:	7bba      	ldrb	r2, [r7, #14]
    43c6:	701a      	strb	r2, [r3, #0]
			Mappings[i].DacChannel = DacChannel;
    43c8:	6879      	ldr	r1, [r7, #4]
    43ca:	68ba      	ldr	r2, [r7, #8]
    43cc:	4613      	mov	r3, r2
    43ce:	005b      	lsls	r3, r3, #1
    43d0:	4413      	add	r3, r2
    43d2:	440b      	add	r3, r1
    43d4:	3302      	adds	r3, #2
    43d6:	7b7a      	ldrb	r2, [r7, #13]
    43d8:	701a      	strb	r2, [r3, #0]
			DacChannel++;
    43da:	7b7b      	ldrb	r3, [r7, #13]
    43dc:	3301      	adds	r3, #1
    43de:	737b      	strb	r3, [r7, #13]
			if (DacChannel >= DMActuatorsPerDac)
    43e0:	7b7b      	ldrb	r3, [r7, #13]
    43e2:	2b27      	cmp	r3, #39	@ 0x27
    43e4:	d911      	bls.n	440a <CGraphDMMappings::CGraphDMMappings()+0x96>
				DacChannel = 0;
    43e6:	2300      	movs	r3, #0
    43e8:	737b      	strb	r3, [r7, #13]
				DacIndex++;
    43ea:	7bbb      	ldrb	r3, [r7, #14]
    43ec:	3301      	adds	r3, #1
    43ee:	73bb      	strb	r3, [r7, #14]
				if (DacIndex >= DMMDacsPerControllerBoard)
    43f0:	7bbb      	ldrb	r3, [r7, #14]
    43f2:	2b03      	cmp	r3, #3
    43f4:	d909      	bls.n	440a <CGraphDMMappings::CGraphDMMappings()+0x96>
					DacIndex = 0;
    43f6:	2300      	movs	r3, #0
    43f8:	73bb      	strb	r3, [r7, #14]
					ControllerBoardIndex++;
    43fa:	7bfb      	ldrb	r3, [r7, #15]
    43fc:	3301      	adds	r3, #1
    43fe:	73fb      	strb	r3, [r7, #15]
					if (ControllerBoardIndex >= DMMaxControllerBoards)
    4400:	7bfb      	ldrb	r3, [r7, #15]
    4402:	2b05      	cmp	r3, #5
    4404:	d901      	bls.n	440a <CGraphDMMappings::CGraphDMMappings()+0x96>
						ControllerBoardIndex = 0;
    4406:	2300      	movs	r3, #0
    4408:	73fb      	strb	r3, [r7, #15]
		for (size_t i = 0; i < DMMaxActuators; i++)
    440a:	68bb      	ldr	r3, [r7, #8]
    440c:	3301      	adds	r3, #1
    440e:	60bb      	str	r3, [r7, #8]
    4410:	68bb      	ldr	r3, [r7, #8]
    4412:	f5b3 7f70 	cmp.w	r3, #960	@ 0x3c0
    4416:	d3c6      	bcc.n	43a6 <CGraphDMMappings::CGraphDMMappings()+0x32>
	}
    4418:	687b      	ldr	r3, [r7, #4]
    441a:	4618      	mov	r0, r3
    441c:	3710      	adds	r7, #16
    441e:	46bd      	mov	sp, r7
    4420:	bdb0      	pop	{r4, r5, r7, pc}

00004422 <DACspi::configDacs(int, int, unsigned long)>:
//    }

    return 0;
  }

  int configDacs(int cdboard, int dacNum, uint32_t dacWord) {
    4422:	b480      	push	{r7}
    4424:	b085      	sub	sp, #20
    4426:	af00      	add	r7, sp, #0
    4428:	60f8      	str	r0, [r7, #12]
    442a:	60b9      	str	r1, [r7, #8]
    442c:	607a      	str	r2, [r7, #4]
    442e:	603b      	str	r3, [r7, #0]
//    default:
//      addr = 0;
//      break;
//    }

    return 0;
    4430:	2300      	movs	r3, #0

  }
    4432:	4618      	mov	r0, r3
    4434:	3714      	adds	r7, #20
    4436:	46bd      	mov	sp, r7
    4438:	bc80      	pop	{r7}
    443a:	4770      	bx	lr

0000443c <BinaryVersionCommand(unsigned long, char const*, unsigned int, void const*)>:
DACspi  SpiContainer;

CGraphDMMappings DMMappings;

int8_t BinaryVersionCommand(const uint32_t Name, char const* Params, const size_t ParamsLen, const void* Argument)
{
    443c:	b580      	push	{r7, lr}
    443e:	b08a      	sub	sp, #40	@ 0x28
    4440:	af02      	add	r7, sp, #8
    4442:	60f8      	str	r0, [r7, #12]
    4444:	60b9      	str	r1, [r7, #8]
    4446:	607a      	str	r2, [r7, #4]
    4448:	603b      	str	r3, [r7, #0]
  CGraphVersionPayload Version;
  Version.SerialNum = 0;
    444a:	2300      	movs	r3, #0
    444c:	617b      	str	r3, [r7, #20]
  Version.ProcessorFirmwareBuildNum = BuildNum;
    444e:	23ee      	movs	r3, #238	@ 0xee
    4450:	61bb      	str	r3, [r7, #24]
  Version.FPGAFirmwareBuildNum = 0;
    4452:	2300      	movs	r3, #0
    4454:	61fb      	str	r3, [r7, #28]

  if (DM) { 
    4456:	4b12      	ldr	r3, [pc, #72]	@ (44a0 <BinaryVersionCommand(unsigned long, char const*, unsigned int, void const*)+0x64>)
    4458:	681b      	ldr	r3, [r3, #0]
    445a:	2b00      	cmp	r3, #0
    445c:	d003      	beq.n	4466 <BinaryVersionCommand(unsigned long, char const*, unsigned int, void const*)+0x2a>
    //    Version.SerialNum = DM->DeviceSerialNumber; 
    Version.FPGAFirmwareBuildNum = DM->FpgaFirmwareBuildNumber; 
    445e:	4b10      	ldr	r3, [pc, #64]	@ (44a0 <BinaryVersionCommand(unsigned long, char const*, unsigned int, void const*)+0x64>)
    4460:	681b      	ldr	r3, [r3, #0]
    4462:	685b      	ldr	r3, [r3, #4]
    4464:	61fb      	str	r3, [r7, #28]
  }
  printf("\nBinaryVersionCommand: Sending response (%u bytes): ", sizeof(CGraphVersionPayload));
    4466:	210c      	movs	r1, #12
    4468:	480e      	ldr	r0, [pc, #56]	@ (44a4 <BinaryVersionCommand(unsigned long, char const*, unsigned int, void const*)+0x68>)
    446a:	f002 fd5f 	bl	6f2c <iprintf>
  Version.formatf();
    446e:	f107 0314 	add.w	r3, r7, #20
    4472:	4618      	mov	r0, r3
    4474:	f7fe fe2a 	bl	30cc <CGraphVersionPayload::formatf() const>
  printf("\n");
    4478:	200a      	movs	r0, #10
    447a:	f002 fd9d 	bl	6fb8 <putchar>
  TxBinaryPacket(Argument, CGraphPayloadTypeVersion, 0, &Version, sizeof(CGraphVersionPayload));
    447e:	f107 0314 	add.w	r3, r7, #20
    4482:	220c      	movs	r2, #12
    4484:	9200      	str	r2, [sp, #0]
    4486:	2200      	movs	r2, #0
    4488:	f241 0101 	movw	r1, #4097	@ 0x1001
    448c:	6838      	ldr	r0, [r7, #0]
    448e:	f7fe febf 	bl	3210 <TxBinaryPacket(void const*, unsigned short, unsigned long, void const*, unsigned int)>
  
  return(ParamsLen);
    4492:	687b      	ldr	r3, [r7, #4]
    4494:	b25b      	sxtb	r3, r3
}
    4496:	4618      	mov	r0, r3
    4498:	3720      	adds	r7, #32
    449a:	46bd      	mov	sp, r7
    449c:	bd80      	pop	{r7, pc}
    449e:	bf00      	nop
    44a0:	2000003c 	.word	0x2000003c
    44a4:	0000ab34 	.word	0x0000ab34

000044a8 <BinaryDMDacCommand(unsigned long, char const*, unsigned int, void const*)>:

int8_t BinaryDMDacCommand(const uint32_t Name, char const* Params, const size_t ParamsLen, const void* Argument)
{
    44a8:	b580      	push	{r7, lr}
    44aa:	b088      	sub	sp, #32
    44ac:	af02      	add	r7, sp, #8
    44ae:	60f8      	str	r0, [r7, #12]
    44b0:	60b9      	str	r1, [r7, #8]
    44b2:	607a      	str	r2, [r7, #4]
    44b4:	603b      	str	r3, [r7, #0]
  uint32_t timeval=0;
    44b6:	2300      	movs	r3, #0
    44b8:	617b      	str	r3, [r7, #20]

  timeval = DM->GetTimer;
    44ba:	4b0a      	ldr	r3, [pc, #40]	@ (44e4 <BinaryDMDacCommand(unsigned long, char const*, unsigned int, void const*)+0x3c>)
    44bc:	681b      	ldr	r3, [r3, #0]
    44be:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
    44c2:	617b      	str	r3, [r7, #20]
        
  TxBinaryPacket(Argument, CGraphPayloadTypeDMDac, 0, &timeval, sizeof(uint32_t));
    44c4:	f107 0314 	add.w	r3, r7, #20
    44c8:	2204      	movs	r2, #4
    44ca:	9200      	str	r2, [sp, #0]
    44cc:	2200      	movs	r2, #0
    44ce:	f243 0102 	movw	r1, #12290	@ 0x3002
    44d2:	6838      	ldr	r0, [r7, #0]
    44d4:	f7fe fe9c 	bl	3210 <TxBinaryPacket(void const*, unsigned short, unsigned long, void const*, unsigned int)>
  return(ParamsLen);
    44d8:	687b      	ldr	r3, [r7, #4]
    44da:	b25b      	sxtb	r3, r3
}
    44dc:	4618      	mov	r0, r3
    44de:	3718      	adds	r7, #24
    44e0:	46bd      	mov	sp, r7
    44e2:	bd80      	pop	{r7, pc}
    44e4:	2000003c 	.word	0x2000003c

000044e8 <BinaryDMStartSMCommand(unsigned long, char const*, unsigned int, void const*)>:

int8_t BinaryDMStartSMCommand(const uint32_t Name, char const* Params, const size_t ParamsLen, const void* Argument)
{
    44e8:	b580      	push	{r7, lr}
    44ea:	b088      	sub	sp, #32
    44ec:	af02      	add	r7, sp, #8
    44ee:	60f8      	str	r0, [r7, #12]
    44f0:	60b9      	str	r1, [r7, #8]
    44f2:	607a      	str	r2, [r7, #4]
    44f4:	603b      	str	r3, [r7, #0]
  uint16_t started=1;
    44f6:	2301      	movs	r3, #1
    44f8:	82fb      	strh	r3, [r7, #22]

  if (DM) { 
    44fa:	4b12      	ldr	r3, [pc, #72]	@ (4544 <BinaryDMStartSMCommand(unsigned long, char const*, unsigned int, void const*)+0x5c>)
    44fc:	681b      	ldr	r3, [r3, #0]
    44fe:	2b00      	cmp	r3, #0
    4500:	d00f      	beq.n	4522 <BinaryDMStartSMCommand(unsigned long, char const*, unsigned int, void const*)+0x3a>
    //    Version.SerialNum = DM->DeviceSerialNumber; 
    DM->StartMachine = 1; 
    4502:	4b10      	ldr	r3, [pc, #64]	@ (4544 <BinaryDMStartSMCommand(unsigned long, char const*, unsigned int, void const*)+0x5c>)
    4504:	681b      	ldr	r3, [r3, #0]
    4506:	2200      	movs	r2, #0
    4508:	f042 0201 	orr.w	r2, r2, #1
    450c:	f883 2094 	strb.w	r2, [r3, #148]	@ 0x94
    4510:	2200      	movs	r2, #0
    4512:	f883 2095 	strb.w	r2, [r3, #149]	@ 0x95
    4516:	2200      	movs	r2, #0
    4518:	f883 2096 	strb.w	r2, [r3, #150]	@ 0x96
    451c:	2200      	movs	r2, #0
    451e:	f883 2097 	strb.w	r2, [r3, #151]	@ 0x97
  }
  TxBinaryPacket(Argument, CGraphPayloadTypeDMStartSM, 0, &started, sizeof(uint16_t));
    4522:	f107 0316 	add.w	r3, r7, #22
    4526:	2202      	movs	r2, #2
    4528:	9200      	str	r2, [sp, #0]
    452a:	2200      	movs	r2, #0
    452c:	f243 0105 	movw	r1, #12293	@ 0x3005
    4530:	6838      	ldr	r0, [r7, #0]
    4532:	f7fe fe6d 	bl	3210 <TxBinaryPacket(void const*, unsigned short, unsigned long, void const*, unsigned int)>
  return(ParamsLen);
    4536:	687b      	ldr	r3, [r7, #4]
    4538:	b25b      	sxtb	r3, r3
}
    453a:	4618      	mov	r0, r3
    453c:	3718      	adds	r7, #24
    453e:	46bd      	mov	sp, r7
    4540:	bd80      	pop	{r7, pc}
    4542:	bf00      	nop
    4544:	2000003c 	.word	0x2000003c

00004548 <BinaryDMTelemetryCommand(unsigned long, char const*, unsigned int, void const*)>:
	}
    return(ParamsLen);
}

int8_t BinaryDMTelemetryCommand(const uint32_t Name, char const* Params, const size_t ParamsLen, const void* Argument)
{
    4548:	b580      	push	{r7, lr}
    454a:	b084      	sub	sp, #16
    454c:	af00      	add	r7, sp, #0
    454e:	60f8      	str	r0, [r7, #12]
    4550:	60b9      	str	r1, [r7, #8]
    4552:	607a      	str	r2, [r7, #4]
    4554:	603b      	str	r3, [r7, #0]
	if ( (NULL != Params) && (ParamsLen >= (3 * sizeof(double))) )
    4556:	68bb      	ldr	r3, [r7, #8]
    4558:	2b00      	cmp	r3, #0
    455a:	d002      	beq.n	4562 <BinaryDMTelemetryCommand(unsigned long, char const*, unsigned int, void const*)+0x1a>
    455c:	687b      	ldr	r3, [r7, #4]
    455e:	2b17      	cmp	r3, #23
    4560:	d804      	bhi.n	456c <BinaryDMTelemetryCommand(unsigned long, char const*, unsigned int, void const*)+0x24>
//		
//		formatf("\n\nBinaryDMStatus Command complete.\n\n");
	}
	else
	{
		printf("\nBinaryDMAdcsFPCommand: Short packet: %u (exptected %u bytes): ", ParamsLen, (3 * sizeof(double)));
    4562:	2218      	movs	r2, #24
    4564:	6879      	ldr	r1, [r7, #4]
    4566:	4804      	ldr	r0, [pc, #16]	@ (4578 <BinaryDMTelemetryCommand(unsigned long, char const*, unsigned int, void const*)+0x30>)
    4568:	f002 fce0 	bl	6f2c <iprintf>
	}
    return(ParamsLen);
    456c:	687b      	ldr	r3, [r7, #4]
    456e:	b25b      	sxtb	r3, r3
}
    4570:	4618      	mov	r0, r3
    4572:	3710      	adds	r7, #16
    4574:	46bd      	mov	sp, r7
    4576:	bd80      	pop	{r7, pc}
    4578:	0000ac3c 	.word	0x0000ac3c

0000457c <BinaryDMDacConfigCommand(unsigned long, char const*, unsigned int, void const*)>:

int8_t BinaryDMDacConfigCommand(const uint32_t Name, char const* Params, const size_t ParamsLen, const void* Argument) {
    457c:	b580      	push	{r7, lr}
    457e:	b086      	sub	sp, #24
    4580:	af00      	add	r7, sp, #0
    4582:	60f8      	str	r0, [r7, #12]
    4584:	60b9      	str	r1, [r7, #8]
    4586:	607a      	str	r2, [r7, #4]
    4588:	603b      	str	r3, [r7, #0]
//    MSS_GPIO_set_output(MSS_GPIO_3,0); // set nClrDacs to 0
//  }
//  MSS_GPIO_set_output(MSS_GPIO_3,1); // set nClrDacs to 1
  // Dacs are now clear

  for (dacNum = 0; dacNum <24; dacNum++) {
    458a:	2300      	movs	r3, #0
    458c:	617b      	str	r3, [r7, #20]
    458e:	e033      	b.n	45f8 <BinaryDMDacConfigCommand(unsigned long, char const*, unsigned int, void const*)+0x7c>
    board = floor(dacNum/4);
    4590:	697b      	ldr	r3, [r7, #20]
    4592:	2b00      	cmp	r3, #0
    4594:	da00      	bge.n	4598 <BinaryDMDacConfigCommand(unsigned long, char const*, unsigned int, void const*)+0x1c>
    4596:	3303      	adds	r3, #3
    4598:	109b      	asrs	r3, r3, #2
    459a:	4618      	mov	r0, r3
    459c:	f000 fe70 	bl	5280 <__gnu_cxx::__enable_if<std::__is_integer<int>::__value, double>::__type std::floor<int>(int)>
    45a0:	4602      	mov	r2, r0
    45a2:	460b      	mov	r3, r1
    45a4:	4610      	mov	r0, r2
    45a6:	4619      	mov	r1, r3
    45a8:	f004 fc64 	bl	8e74 <__aeabi_d2iz>
    45ac:	4603      	mov	r3, r0
    45ae:	613b      	str	r3, [r7, #16]
    SpiContainer.configDacs(board, dacNum, 0x020000); // offset register 0
    45b0:	f44f 3300 	mov.w	r3, #131072	@ 0x20000
    45b4:	697a      	ldr	r2, [r7, #20]
    45b6:	6939      	ldr	r1, [r7, #16]
    45b8:	4814      	ldr	r0, [pc, #80]	@ (460c <BinaryDMDacConfigCommand(unsigned long, char const*, unsigned int, void const*)+0x90>)
    45ba:	f7ff ff32 	bl	4422 <DACspi::configDacs(int, int, unsigned long)>
    SpiContainer.configDacs(board, dacNum, 0x030000); // offset register 1
    45be:	f44f 3340 	mov.w	r3, #196608	@ 0x30000
    45c2:	697a      	ldr	r2, [r7, #20]
    45c4:	6939      	ldr	r1, [r7, #16]
    45c6:	4811      	ldr	r0, [pc, #68]	@ (460c <BinaryDMDacConfigCommand(unsigned long, char const*, unsigned int, void const*)+0x90>)
    45c8:	f7ff ff2b 	bl	4422 <DACspi::configDacs(int, int, unsigned long)>
    SpiContainer.configDacs(board, dacNum, 0x0B0000); // Block write nA/B select registers
    45cc:	f44f 2330 	mov.w	r3, #720896	@ 0xb0000
    45d0:	697a      	ldr	r2, [r7, #20]
    45d2:	6939      	ldr	r1, [r7, #16]
    45d4:	480d      	ldr	r0, [pc, #52]	@ (460c <BinaryDMDacConfigCommand(unsigned long, char const*, unsigned int, void const*)+0x90>)
    45d6:	f7ff ff24 	bl	4422 <DACspi::configDacs(int, int, unsigned long)>
    SpiContainer.configDacs(board, dacNum, 0x818000); // Write to gain (M) register
    45da:	4b0d      	ldr	r3, [pc, #52]	@ (4610 <BinaryDMDacConfigCommand(unsigned long, char const*, unsigned int, void const*)+0x94>)
    45dc:	697a      	ldr	r2, [r7, #20]
    45de:	6939      	ldr	r1, [r7, #16]
    45e0:	480a      	ldr	r0, [pc, #40]	@ (460c <BinaryDMDacConfigCommand(unsigned long, char const*, unsigned int, void const*)+0x90>)
    45e2:	f7ff ff1e 	bl	4422 <DACspi::configDacs(int, int, unsigned long)>
    SpiContainer.configDacs(board, dacNum, 0x41ff00); // Write to offset (C) register
    45e6:	4b0b      	ldr	r3, [pc, #44]	@ (4614 <BinaryDMDacConfigCommand(unsigned long, char const*, unsigned int, void const*)+0x98>)
    45e8:	697a      	ldr	r2, [r7, #20]
    45ea:	6939      	ldr	r1, [r7, #16]
    45ec:	4807      	ldr	r0, [pc, #28]	@ (460c <BinaryDMDacConfigCommand(unsigned long, char const*, unsigned int, void const*)+0x90>)
    45ee:	f7ff ff18 	bl	4422 <DACspi::configDacs(int, int, unsigned long)>
  for (dacNum = 0; dacNum <24; dacNum++) {
    45f2:	697b      	ldr	r3, [r7, #20]
    45f4:	3301      	adds	r3, #1
    45f6:	617b      	str	r3, [r7, #20]
    45f8:	697b      	ldr	r3, [r7, #20]
    45fa:	2b17      	cmp	r3, #23
    45fc:	ddc8      	ble.n	4590 <BinaryDMDacConfigCommand(unsigned long, char const*, unsigned int, void const*)+0x14>
//    }
//  }
  // Now turn on HV on board
  //  MSS_GPIO_set_output(MSS_GPIO_6, 0); // set the PwrHVnEn 0.  HV power is now on!!!

  return(ParamsLen);
    45fe:	687b      	ldr	r3, [r7, #4]
    4600:	b25b      	sxtb	r3, r3
}
    4602:	4618      	mov	r0, r3
    4604:	3718      	adds	r7, #24
    4606:	46bd      	mov	sp, r7
    4608:	bd80      	pop	{r7, pc}
    460a:	bf00      	nop
    460c:	2000026c 	.word	0x2000026c
    4610:	00818000 	.word	0x00818000
    4614:	0041ff00 	.word	0x0041ff00

00004618 <BinaryDMMappingCommand(unsigned long, char const*, unsigned int, void const*)>:

int8_t BinaryDMMappingCommand(const uint32_t Name, char const* Params, const size_t ParamsLen, const void* Argument)
{
    4618:	b590      	push	{r4, r7, lr}
    461a:	f6ad 3d74 	subw	sp, sp, #2932	@ 0xb74
    461e:	af02      	add	r7, sp, #8
    4620:	f607 3468 	addw	r4, r7, #2920	@ 0xb68
    4624:	f6a4 345c 	subw	r4, r4, #2908	@ 0xb5c
    4628:	6020      	str	r0, [r4, #0]
    462a:	f607 3068 	addw	r0, r7, #2920	@ 0xb68
    462e:	f5a0 6036 	sub.w	r0, r0, #2912	@ 0xb60
    4632:	6001      	str	r1, [r0, #0]
    4634:	f607 3168 	addw	r1, r7, #2920	@ 0xb68
    4638:	f6a1 3164 	subw	r1, r1, #2916	@ 0xb64
    463c:	600a      	str	r2, [r1, #0]
    463e:	f607 3268 	addw	r2, r7, #2920	@ 0xb68
    4642:	f6a2 3268 	subw	r2, r2, #2920	@ 0xb68
    4646:	6013      	str	r3, [r2, #0]
  //uint16_t readback = 5;
  
  //TxBinaryPacket(Argument, CGraphPayloadTypeDMMappings, 0, &readback, sizeof(uint16_t)); 
	if ( (nullptr != Params) && (ParamsLen > sizeof(CGraphDMPixelPayloadHeader)) )
    4648:	f607 3368 	addw	r3, r7, #2920	@ 0xb68
    464c:	f5a3 6336 	sub.w	r3, r3, #2912	@ 0xb60
    4650:	681b      	ldr	r3, [r3, #0]
    4652:	2b00      	cmp	r3, #0
    4654:	f000 80c9 	beq.w	47ea <BinaryDMMappingCommand(unsigned long, char const*, unsigned int, void const*)+0x1d2>
    4658:	f607 3368 	addw	r3, r7, #2920	@ 0xb68
    465c:	f6a3 3364 	subw	r3, r3, #2916	@ 0xb64
    4660:	681b      	ldr	r3, [r3, #0]
    4662:	2b02      	cmp	r3, #2
    4664:	f240 80c1 	bls.w	47ea <BinaryDMMappingCommand(unsigned long, char const*, unsigned int, void const*)+0x1d2>
	{
          //readback = 42;
          //TxBinaryPacket(Argument, CGraphPayloadTypeDMMappings, 0, &readback, sizeof(uint16_t));
		//Find a start index followed by some mappings
		const CGraphDMPixelPayloadHeader PixelHeader = *reinterpret_cast<const CGraphDMPixelPayloadHeader*>(Params);
    4668:	f607 3368 	addw	r3, r7, #2920	@ 0xb68
    466c:	f5a3 6336 	sub.w	r3, r3, #2912	@ 0xb60
    4670:	681b      	ldr	r3, [r3, #0]
    4672:	881b      	ldrh	r3, [r3, #0]
    4674:	f8a7 3b60 	strh.w	r3, [r7, #2912]	@ 0xb60
		const unsigned long StartPixel = PixelHeader.StartPixel;
    4678:	f8b7 3b60 	ldrh.w	r3, [r7, #2912]	@ 0xb60
    467c:	f8c7 3b5c 	str.w	r3, [r7, #2908]	@ 0xb5c
		if (StartPixel > DMMaxActuators) 
    4680:	f8d7 3b5c 	ldr.w	r3, [r7, #2908]	@ 0xb5c
    4684:	f5b3 7f70 	cmp.w	r3, #960	@ 0x3c0
    4688:	d914      	bls.n	46b4 <BinaryDMMappingCommand(unsigned long, char const*, unsigned int, void const*)+0x9c>
		{
			printf("\nBinaryDMMappingCommand: Invalid StartPixel: %lu!\n", (unsigned long)StartPixel);
    468a:	f8d7 3b5c 	ldr.w	r3, [r7, #2908]	@ 0xb5c
    468e:	4619      	mov	r1, r3
    4690:	486f      	ldr	r0, [pc, #444]	@ (4850 <BinaryDMMappingCommand(unsigned long, char const*, unsigned int, void const*)+0x238>)
    4692:	f002 fc4b 	bl	6f2c <iprintf>
			TxBinaryPacket(Argument, CGraphPayloadTypeDMMappings, 0, &StartPixel, sizeof(uint16_t));
    4696:	f607 335c 	addw	r3, r7, #2908	@ 0xb5c
    469a:	f607 3268 	addw	r2, r7, #2920	@ 0xb68
    469e:	f6a2 3068 	subw	r0, r2, #2920	@ 0xb68
    46a2:	2202      	movs	r2, #2
    46a4:	9200      	str	r2, [sp, #0]
    46a6:	2200      	movs	r2, #0
    46a8:	f243 010b 	movw	r1, #12299	@ 0x300b
    46ac:	6800      	ldr	r0, [r0, #0]
    46ae:	f7fe fdaf 	bl	3210 <TxBinaryPacket(void const*, unsigned short, unsigned long, void const*, unsigned int)>
					}
				}
			}
			TxBinaryPacket(Argument, CGraphPayloadTypeDMMappings, 0, &NumPixels, sizeof(uint16_t));
		}
	}
    46b2:	e0c2      	b.n	483a <BinaryDMMappingCommand(unsigned long, char const*, unsigned int, void const*)+0x222>
			unsigned long NumPixels = (ParamsLen - sizeof(CGraphDMPixelPayloadHeader)) / sizeof(CGraphDMMappingPayload);
    46b4:	f607 3368 	addw	r3, r7, #2920	@ 0xb68
    46b8:	f6a3 3364 	subw	r3, r3, #2916	@ 0xb64
    46bc:	681b      	ldr	r3, [r3, #0]
    46be:	3b02      	subs	r3, #2
    46c0:	4a64      	ldr	r2, [pc, #400]	@ (4854 <BinaryDMMappingCommand(unsigned long, char const*, unsigned int, void const*)+0x23c>)
    46c2:	fba2 2303 	umull	r2, r3, r2, r3
    46c6:	085b      	lsrs	r3, r3, #1
    46c8:	f8c7 3b58 	str.w	r3, [r7, #2904]	@ 0xb58
			if ((NumPixels + StartPixel) > DMMaxActuators) { NumPixels = DMMaxActuators - StartPixel; }
    46cc:	f8d7 2b58 	ldr.w	r2, [r7, #2904]	@ 0xb58
    46d0:	f8d7 3b5c 	ldr.w	r3, [r7, #2908]	@ 0xb5c
    46d4:	4413      	add	r3, r2
    46d6:	f5b3 7f70 	cmp.w	r3, #960	@ 0x3c0
    46da:	d905      	bls.n	46e8 <BinaryDMMappingCommand(unsigned long, char const*, unsigned int, void const*)+0xd0>
    46dc:	f8d7 3b5c 	ldr.w	r3, [r7, #2908]	@ 0xb5c
    46e0:	f5c3 7370 	rsb	r3, r3, #960	@ 0x3c0
    46e4:	f8c7 3b58 	str.w	r3, [r7, #2904]	@ 0xb58
			printf("\nBinaryDMMappingCommand: StartPixel: %lu, NumPixels: %lu\n", StartPixel, NumPixels);
    46e8:	f8d7 3b5c 	ldr.w	r3, [r7, #2908]	@ 0xb5c
    46ec:	f8d7 2b58 	ldr.w	r2, [r7, #2904]	@ 0xb58
    46f0:	4619      	mov	r1, r3
    46f2:	4859      	ldr	r0, [pc, #356]	@ (4858 <BinaryDMMappingCommand(unsigned long, char const*, unsigned int, void const*)+0x240>)
    46f4:	f002 fc1a 	bl	6f2c <iprintf>
			for (size_t i = StartPixel; i < (StartPixel + NumPixels); i++)
    46f8:	f8d7 3b5c 	ldr.w	r3, [r7, #2908]	@ 0xb5c
    46fc:	f8c7 3b64 	str.w	r3, [r7, #2916]	@ 0xb64
    4700:	e05b      	b.n	47ba <BinaryDMMappingCommand(unsigned long, char const*, unsigned int, void const*)+0x1a2>
				const CGraphDMMappingPayload Mapping = *reinterpret_cast<const CGraphDMMappingPayload*>(Params+sizeof(CGraphDMPixelPayloadHeader)+((i - StartPixel)*sizeof(CGraphDMMappingPayload)));
    4702:	f8d7 3b5c 	ldr.w	r3, [r7, #2908]	@ 0xb5c
    4706:	f8d7 2b64 	ldr.w	r2, [r7, #2916]	@ 0xb64
    470a:	1ad2      	subs	r2, r2, r3
    470c:	4613      	mov	r3, r2
    470e:	005b      	lsls	r3, r3, #1
    4710:	4413      	add	r3, r2
    4712:	3302      	adds	r3, #2
    4714:	f607 3268 	addw	r2, r7, #2920	@ 0xb68
    4718:	f5a2 6236 	sub.w	r2, r2, #2912	@ 0xb60
    471c:	6812      	ldr	r2, [r2, #0]
    471e:	441a      	add	r2, r3
    4720:	f607 3354 	addw	r3, r7, #2900	@ 0xb54
    4724:	8811      	ldrh	r1, [r2, #0]
    4726:	7892      	ldrb	r2, [r2, #2]
    4728:	8019      	strh	r1, [r3, #0]
    472a:	709a      	strb	r2, [r3, #2]
				if (Mapping.ControllerBoardIndex >= DMMaxControllerBoards)
    472c:	f897 3b54 	ldrb.w	r3, [r7, #2900]	@ 0xb54
    4730:	2b05      	cmp	r3, #5
    4732:	d908      	bls.n	4746 <BinaryDMMappingCommand(unsigned long, char const*, unsigned int, void const*)+0x12e>
					printf("\nBinaryDMMappingCommand: Invalid Controller Board for mapping %lu: %lu!\n", (unsigned long)i, (unsigned long)Mapping.ControllerBoardIndex);
    4734:	f897 3b54 	ldrb.w	r3, [r7, #2900]	@ 0xb54
    4738:	461a      	mov	r2, r3
    473a:	f8d7 1b64 	ldr.w	r1, [r7, #2916]	@ 0xb64
    473e:	4847      	ldr	r0, [pc, #284]	@ (485c <BinaryDMMappingCommand(unsigned long, char const*, unsigned int, void const*)+0x244>)
    4740:	f002 fbf4 	bl	6f2c <iprintf>
    4744:	e034      	b.n	47b0 <BinaryDMMappingCommand(unsigned long, char const*, unsigned int, void const*)+0x198>
					if (Mapping.DacIndex >= DMMDacsPerControllerBoard)
    4746:	f897 3b55 	ldrb.w	r3, [r7, #2901]	@ 0xb55
    474a:	2b03      	cmp	r3, #3
    474c:	d908      	bls.n	4760 <BinaryDMMappingCommand(unsigned long, char const*, unsigned int, void const*)+0x148>
						printf("\nBinaryDMMappingCommand: Invalid Dac Number for mapping %lu: %lu!\n", (unsigned long)i, (unsigned long)Mapping.DacIndex);
    474e:	f897 3b55 	ldrb.w	r3, [r7, #2901]	@ 0xb55
    4752:	461a      	mov	r2, r3
    4754:	f8d7 1b64 	ldr.w	r1, [r7, #2916]	@ 0xb64
    4758:	4841      	ldr	r0, [pc, #260]	@ (4860 <BinaryDMMappingCommand(unsigned long, char const*, unsigned int, void const*)+0x248>)
    475a:	f002 fbe7 	bl	6f2c <iprintf>
    475e:	e027      	b.n	47b0 <BinaryDMMappingCommand(unsigned long, char const*, unsigned int, void const*)+0x198>
						if (Mapping.DacChannel >= DMActuatorsPerDac)
    4760:	f897 3b56 	ldrb.w	r3, [r7, #2902]	@ 0xb56
    4764:	2b27      	cmp	r3, #39	@ 0x27
    4766:	d908      	bls.n	477a <BinaryDMMappingCommand(unsigned long, char const*, unsigned int, void const*)+0x162>
							printf("\nBinaryDMMappingCommand: Invalid Dac channel for mapping %lu: %lu!\n", (unsigned long)i, (unsigned long)Mapping.DacChannel);
    4768:	f897 3b56 	ldrb.w	r3, [r7, #2902]	@ 0xb56
    476c:	461a      	mov	r2, r3
    476e:	f8d7 1b64 	ldr.w	r1, [r7, #2916]	@ 0xb64
    4772:	483c      	ldr	r0, [pc, #240]	@ (4864 <BinaryDMMappingCommand(unsigned long, char const*, unsigned int, void const*)+0x24c>)
    4774:	f002 fbda 	bl	6f2c <iprintf>
    4778:	e01a      	b.n	47b0 <BinaryDMMappingCommand(unsigned long, char const*, unsigned int, void const*)+0x198>
							DMMappings.Mappings[i] = Mapping;
    477a:	493b      	ldr	r1, [pc, #236]	@ (4868 <BinaryDMMappingCommand(unsigned long, char const*, unsigned int, void const*)+0x250>)
    477c:	f8d7 2b64 	ldr.w	r2, [r7, #2916]	@ 0xb64
    4780:	4613      	mov	r3, r2
    4782:	005b      	lsls	r3, r3, #1
    4784:	4413      	add	r3, r2
    4786:	440b      	add	r3, r1
    4788:	461a      	mov	r2, r3
    478a:	f607 3354 	addw	r3, r7, #2900	@ 0xb54
    478e:	8819      	ldrh	r1, [r3, #0]
    4790:	789b      	ldrb	r3, [r3, #2]
    4792:	8011      	strh	r1, [r2, #0]
    4794:	7093      	strb	r3, [r2, #2]
							printf("\nBinaryDMMappingCommand: Set mapping %lu to ", (unsigned long)i);
    4796:	f8d7 1b64 	ldr.w	r1, [r7, #2916]	@ 0xb64
    479a:	4834      	ldr	r0, [pc, #208]	@ (486c <BinaryDMMappingCommand(unsigned long, char const*, unsigned int, void const*)+0x254>)
    479c:	f002 fbc6 	bl	6f2c <iprintf>
							Mapping.formatf();
    47a0:	f607 3354 	addw	r3, r7, #2900	@ 0xb54
    47a4:	4618      	mov	r0, r3
    47a6:	f7fe fcbf 	bl	3128 <CGraphDMMappingPayload::formatf() const>
							printf("\n\n");
    47aa:	4831      	ldr	r0, [pc, #196]	@ (4870 <BinaryDMMappingCommand(unsigned long, char const*, unsigned int, void const*)+0x258>)
    47ac:	f002 fc62 	bl	7074 <puts>
			for (size_t i = StartPixel; i < (StartPixel + NumPixels); i++)
    47b0:	f8d7 3b64 	ldr.w	r3, [r7, #2916]	@ 0xb64
    47b4:	3301      	adds	r3, #1
    47b6:	f8c7 3b64 	str.w	r3, [r7, #2916]	@ 0xb64
    47ba:	f8d7 2b5c 	ldr.w	r2, [r7, #2908]	@ 0xb5c
    47be:	f8d7 3b58 	ldr.w	r3, [r7, #2904]	@ 0xb58
    47c2:	4413      	add	r3, r2
    47c4:	f8d7 2b64 	ldr.w	r2, [r7, #2916]	@ 0xb64
    47c8:	429a      	cmp	r2, r3
    47ca:	d39a      	bcc.n	4702 <BinaryDMMappingCommand(unsigned long, char const*, unsigned int, void const*)+0xea>
			TxBinaryPacket(Argument, CGraphPayloadTypeDMMappings, 0, &NumPixels, sizeof(uint16_t));
    47cc:	f607 3358 	addw	r3, r7, #2904	@ 0xb58
    47d0:	f607 3268 	addw	r2, r7, #2920	@ 0xb68
    47d4:	f6a2 3068 	subw	r0, r2, #2920	@ 0xb68
    47d8:	2202      	movs	r2, #2
    47da:	9200      	str	r2, [sp, #0]
    47dc:	2200      	movs	r2, #0
    47de:	f243 010b 	movw	r1, #12299	@ 0x300b
    47e2:	6800      	ldr	r0, [r0, #0]
    47e4:	f7fe fd14 	bl	3210 <TxBinaryPacket(void const*, unsigned short, unsigned long, void const*, unsigned int)>
	}
    47e8:	e027      	b.n	483a <BinaryDMMappingCommand(unsigned long, char const*, unsigned int, void const*)+0x222>
	//Query
	else
	{
		printf("\nBinaryDMMappingCommand: Empty packet, returning query\n");
    47ea:	4822      	ldr	r0, [pc, #136]	@ (4874 <BinaryDMMappingCommand(unsigned long, char const*, unsigned int, void const*)+0x25c>)
    47ec:	f002 fc42 	bl	7074 <puts>
		uint8_t Buffer[(DMMaxActuators * sizeof(CGraphDMMappingPayload)) + sizeof(CGraphDMPixelPayloadHeader)];
		uint16_t StartPix = 0;
    47f0:	2300      	movs	r3, #0
    47f2:	f8a7 3b52 	strh.w	r3, [r7, #2898]	@ 0xb52
		memcpy(Buffer, &StartPix, sizeof(CGraphDMPixelPayloadHeader));
    47f6:	f8b7 2b52 	ldrh.w	r2, [r7, #2898]	@ 0xb52
    47fa:	f607 3368 	addw	r3, r7, #2920	@ 0xb68
    47fe:	f6a3 3358 	subw	r3, r3, #2904	@ 0xb58
    4802:	801a      	strh	r2, [r3, #0]
		memcpy(&(Buffer[sizeof(CGraphDMPixelPayloadHeader)]), DMMappings.Mappings, sizeof(CGraphDMMappingPayload) * DMMaxActuators);
    4804:	f607 3368 	addw	r3, r7, #2920	@ 0xb68
    4808:	f6a3 3358 	subw	r3, r3, #2904	@ 0xb58
    480c:	4a16      	ldr	r2, [pc, #88]	@ (4868 <BinaryDMMappingCommand(unsigned long, char const*, unsigned int, void const*)+0x250>)
    480e:	3302      	adds	r3, #2
    4810:	4611      	mov	r1, r2
    4812:	f44f 6234 	mov.w	r2, #2880	@ 0xb40
    4816:	4618      	mov	r0, r3
    4818:	f002 fe1d 	bl	7456 <memcpy>
		
		TxBinaryPacket(Argument, CGraphPayloadTypeDMMappings, 0, Buffer, (sizeof(CGraphDMMappingPayload) * DMMaxActuators) + sizeof(CGraphDMPixelPayloadHeader));
    481c:	f107 0310 	add.w	r3, r7, #16
    4820:	f607 3268 	addw	r2, r7, #2920	@ 0xb68
    4824:	f6a2 3068 	subw	r0, r2, #2920	@ 0xb68
    4828:	f640 3242 	movw	r2, #2882	@ 0xb42
    482c:	9200      	str	r2, [sp, #0]
    482e:	2200      	movs	r2, #0
    4830:	f243 010b 	movw	r1, #12299	@ 0x300b
    4834:	6800      	ldr	r0, [r0, #0]
    4836:	f7fe fceb 	bl	3210 <TxBinaryPacket(void const*, unsigned short, unsigned long, void const*, unsigned int)>
	}
	
    return(ParamsLen);
    483a:	f607 3368 	addw	r3, r7, #2920	@ 0xb68
    483e:	f6a3 3364 	subw	r3, r3, #2916	@ 0xb64
    4842:	681b      	ldr	r3, [r3, #0]
    4844:	b25b      	sxtb	r3, r3
}
    4846:	4618      	mov	r0, r3
    4848:	f607 376c 	addw	r7, r7, #2924	@ 0xb6c
    484c:	46bd      	mov	sp, r7
    484e:	bd90      	pop	{r4, r7, pc}
    4850:	0000ac7c 	.word	0x0000ac7c
    4854:	aaaaaaab 	.word	0xaaaaaaab
    4858:	0000acb0 	.word	0x0000acb0
    485c:	0000acec 	.word	0x0000acec
    4860:	0000ad38 	.word	0x0000ad38
    4864:	0000ad7c 	.word	0x0000ad7c
    4868:	200009e0 	.word	0x200009e0
    486c:	0000adc0 	.word	0x0000adc0
    4870:	0000ab88 	.word	0x0000ab88
    4874:	0000adf0 	.word	0x0000adf0

00004878 <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)>:

int8_t BinaryDMShortPixelsCommand(const uint32_t Name, char const* Params, const size_t ParamsLen, const void* Argument)
{
    4878:	b5b0      	push	{r4, r5, r7, lr}
    487a:	f5ad 6df8 	sub.w	sp, sp, #1984	@ 0x7c0
    487e:	af02      	add	r7, sp, #8
    4880:	f507 64f7 	add.w	r4, r7, #1976	@ 0x7b8
    4884:	f2a4 74ac 	subw	r4, r4, #1964	@ 0x7ac
    4888:	6020      	str	r0, [r4, #0]
    488a:	f507 60f7 	add.w	r0, r7, #1976	@ 0x7b8
    488e:	f5a0 60f6 	sub.w	r0, r0, #1968	@ 0x7b0
    4892:	6001      	str	r1, [r0, #0]
    4894:	f507 61f7 	add.w	r1, r7, #1976	@ 0x7b8
    4898:	f2a1 71b4 	subw	r1, r1, #1972	@ 0x7b4
    489c:	600a      	str	r2, [r1, #0]
    489e:	f507 62f7 	add.w	r2, r7, #1976	@ 0x7b8
    48a2:	f5a2 62f7 	sub.w	r2, r2, #1976	@ 0x7b8
    48a6:	6013      	str	r3, [r2, #0]
	if (nullptr == DM)
    48a8:	4bb4      	ldr	r3, [pc, #720]	@ (4b7c <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x304>)
    48aa:	681b      	ldr	r3, [r3, #0]
    48ac:	2b00      	cmp	r3, #0
    48ae:	d109      	bne.n	48c4 <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x4c>
	{
          printf("\nBinaryDMShortPixelsCommand: DM pointer is NULL! Firmware corrupted!\n");	
    48b0:	48b3      	ldr	r0, [pc, #716]	@ (4b80 <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x308>)
    48b2:	f002 fbdf 	bl	7074 <puts>
          return(ParamsLen);
    48b6:	f507 63f7 	add.w	r3, r7, #1976	@ 0x7b8
    48ba:	f2a3 73b4 	subw	r3, r3, #1972	@ 0x7b4
    48be:	681b      	ldr	r3, [r3, #0]
    48c0:	b25b      	sxtb	r3, r3
    48c2:	e156      	b.n	4b72 <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x2fa>
	}
		
	if ( (nullptr != Params) && (ParamsLen >= sizeof(CGraphDMPixelPayloadHeader)) )
    48c4:	f507 63f7 	add.w	r3, r7, #1976	@ 0x7b8
    48c8:	f5a3 63f6 	sub.w	r3, r3, #1968	@ 0x7b0
    48cc:	681b      	ldr	r3, [r3, #0]
    48ce:	2b00      	cmp	r3, #0
    48d0:	f000 810c 	beq.w	4aec <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x274>
    48d4:	f507 63f7 	add.w	r3, r7, #1976	@ 0x7b8
    48d8:	f2a3 73b4 	subw	r3, r3, #1972	@ 0x7b4
    48dc:	681b      	ldr	r3, [r3, #0]
    48de:	2b01      	cmp	r3, #1
    48e0:	f240 8104 	bls.w	4aec <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x274>
	{
          //ok, first we're looking for a packet with the start pixel and some pix's in it:
          const CGraphDMPixelPayloadHeader PixelHeader = *reinterpret_cast<const CGraphDMPixelPayloadHeader*>(Params);
    48e4:	f507 63f7 	add.w	r3, r7, #1976	@ 0x7b8
    48e8:	f5a3 63f6 	sub.w	r3, r3, #1968	@ 0x7b0
    48ec:	681b      	ldr	r3, [r3, #0]
    48ee:	881b      	ldrh	r3, [r3, #0]
    48f0:	f8a7 37a0 	strh.w	r3, [r7, #1952]	@ 0x7a0
          const unsigned long StartPixel = PixelHeader.StartPixel;
    48f4:	f8b7 37a0 	ldrh.w	r3, [r7, #1952]	@ 0x7a0
    48f8:	f8c7 379c 	str.w	r3, [r7, #1948]	@ 0x79c

          if (StartPixel > DMMaxActuators) {
    48fc:	f8d7 379c 	ldr.w	r3, [r7, #1948]	@ 0x79c
    4900:	f5b3 7f70 	cmp.w	r3, #960	@ 0x3c0
    4904:	d914      	bls.n	4930 <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0xb8>
            //Complain and bail out, something is horribly wrong:
            printf("\nBinaryDMShortPixelsCommand: Invalid StartPixel: %lu!\n", (unsigned long)StartPixel);
    4906:	f8d7 379c 	ldr.w	r3, [r7, #1948]	@ 0x79c
    490a:	4619      	mov	r1, r3
    490c:	489d      	ldr	r0, [pc, #628]	@ (4b84 <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x30c>)
    490e:	f002 fb0d 	bl	6f2c <iprintf>
            TxBinaryPacket(Argument, CGraphPayloadTypeDMShortPixels, 0, &StartPixel, sizeof(uint16_t));
    4912:	f207 739c 	addw	r3, r7, #1948	@ 0x79c
    4916:	f507 62f7 	add.w	r2, r7, #1976	@ 0x7b8
    491a:	f5a2 60f7 	sub.w	r0, r2, #1976	@ 0x7b8
    491e:	2202      	movs	r2, #2
    4920:	9200      	str	r2, [sp, #0]
    4922:	2200      	movs	r2, #0
    4924:	f243 010c 	movw	r1, #12300	@ 0x300c
    4928:	6800      	ldr	r0, [r0, #0]
    492a:	f7fe fc71 	bl	3210 <TxBinaryPacket(void const*, unsigned short, unsigned long, void const*, unsigned int)>
            else { // ParamsLen >= sizeof(CGraphDMPixelPayloadHeader)
              printf("\nBinaryDMMappingCommand: Short packet: %u (exptected >%u bytes): ", ParamsLen, (sizeof(CGraphDMPixelPayloadHeader)));
              TxBinaryPacket(Argument, CGraphPayloadTypeDMShortPixels, 0, &StartPixel, sizeof(uint16_t));
            }
          }
	}
    492e:	e11a      	b.n	4b66 <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x2ee>
            if (ParamsLen >= sizeof(CGraphDMPixelPayloadHeader)) {
    4930:	f507 63f7 	add.w	r3, r7, #1976	@ 0x7b8
    4934:	f2a3 73b4 	subw	r3, r3, #1972	@ 0x7b4
    4938:	681b      	ldr	r3, [r3, #0]
    493a:	2b01      	cmp	r3, #1
    493c:	f240 80be 	bls.w	4abc <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x244>
              unsigned long NumPixels = (ParamsLen - sizeof(CGraphDMPixelPayloadHeader)) / sizeof(uint16_t);
    4940:	f507 63f7 	add.w	r3, r7, #1976	@ 0x7b8
    4944:	f2a3 73b4 	subw	r3, r3, #1972	@ 0x7b4
    4948:	681b      	ldr	r3, [r3, #0]
    494a:	3b02      	subs	r3, #2
    494c:	085b      	lsrs	r3, r3, #1
    494e:	f8c7 3798 	str.w	r3, [r7, #1944]	@ 0x798
              if ((NumPixels + StartPixel) > DMMaxActuators) { NumPixels = DMMaxActuators - StartPixel; } //do let's try not to blow our array...
    4952:	f8d7 2798 	ldr.w	r2, [r7, #1944]	@ 0x798
    4956:	f8d7 379c 	ldr.w	r3, [r7, #1948]	@ 0x79c
    495a:	4413      	add	r3, r2
    495c:	f5b3 7f70 	cmp.w	r3, #960	@ 0x3c0
    4960:	d905      	bls.n	496e <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0xf6>
    4962:	f8d7 379c 	ldr.w	r3, [r7, #1948]	@ 0x79c
    4966:	f5c3 7370 	rsb	r3, r3, #960	@ 0x3c0
    496a:	f8c7 3798 	str.w	r3, [r7, #1944]	@ 0x798
              for (size_t i = StartPixel; i < (StartPixel + NumPixels); i++) {
    496e:	f8d7 379c 	ldr.w	r3, [r7, #1948]	@ 0x79c
    4972:	f8c7 37b4 	str.w	r3, [r7, #1972]	@ 0x7b4
    4976:	e088      	b.n	4a8a <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x212>
                const uint16_t DacVal = *reinterpret_cast<const uint16_t*>(Params+sizeof(CGraphDMPixelPayloadHeader)+((i - StartPixel)*sizeof(uint16_t)));
    4978:	f8d7 379c 	ldr.w	r3, [r7, #1948]	@ 0x79c
    497c:	f8d7 27b4 	ldr.w	r2, [r7, #1972]	@ 0x7b4
    4980:	1ad3      	subs	r3, r2, r3
    4982:	3301      	adds	r3, #1
    4984:	005b      	lsls	r3, r3, #1
    4986:	f507 62f7 	add.w	r2, r7, #1976	@ 0x7b8
    498a:	f5a2 62f6 	sub.w	r2, r2, #1968	@ 0x7b0
    498e:	6812      	ldr	r2, [r2, #0]
    4990:	4413      	add	r3, r2
    4992:	881b      	ldrh	r3, [r3, #0]
    4994:	f8a7 37ae 	strh.w	r3, [r7, #1966]	@ 0x7ae
                if ( (DMMappings.Mappings[i].ControllerBoardIndex >= DMMaxControllerBoards) || (DMMappings.Mappings[i].ControllerBoardIndex >= DMMaxControllerBoards) || (DMMappings.Mappings[i].ControllerBoardIndex >= DMMaxControllerBoards) ) {
    4998:	497b      	ldr	r1, [pc, #492]	@ (4b88 <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x310>)
    499a:	f8d7 27b4 	ldr.w	r2, [r7, #1972]	@ 0x7b4
    499e:	4613      	mov	r3, r2
    49a0:	005b      	lsls	r3, r3, #1
    49a2:	4413      	add	r3, r2
    49a4:	440b      	add	r3, r1
    49a6:	781b      	ldrb	r3, [r3, #0]
    49a8:	2b05      	cmp	r3, #5
    49aa:	d813      	bhi.n	49d4 <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x15c>
    49ac:	4976      	ldr	r1, [pc, #472]	@ (4b88 <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x310>)
    49ae:	f8d7 27b4 	ldr.w	r2, [r7, #1972]	@ 0x7b4
    49b2:	4613      	mov	r3, r2
    49b4:	005b      	lsls	r3, r3, #1
    49b6:	4413      	add	r3, r2
    49b8:	440b      	add	r3, r1
    49ba:	781b      	ldrb	r3, [r3, #0]
    49bc:	2b05      	cmp	r3, #5
    49be:	d809      	bhi.n	49d4 <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x15c>
    49c0:	4971      	ldr	r1, [pc, #452]	@ (4b88 <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x310>)
    49c2:	f8d7 27b4 	ldr.w	r2, [r7, #1972]	@ 0x7b4
    49c6:	4613      	mov	r3, r2
    49c8:	005b      	lsls	r3, r3, #1
    49ca:	4413      	add	r3, r2
    49cc:	440b      	add	r3, r1
    49ce:	781b      	ldrb	r3, [r3, #0]
    49d0:	2b05      	cmp	r3, #5
    49d2:	d912      	bls.n	49fa <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x182>
                  printf("\nBinaryDMShortPixelsCommand: Invalid mapping %lu; please reinitialize mappings!: ", (unsigned long)i);
    49d4:	f8d7 17b4 	ldr.w	r1, [r7, #1972]	@ 0x7b4
    49d8:	486c      	ldr	r0, [pc, #432]	@ (4b8c <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x314>)
    49da:	f002 faa7 	bl	6f2c <iprintf>
                  DMMappings.Mappings[i].formatf();
    49de:	f8d7 27b4 	ldr.w	r2, [r7, #1972]	@ 0x7b4
    49e2:	4613      	mov	r3, r2
    49e4:	005b      	lsls	r3, r3, #1
    49e6:	4413      	add	r3, r2
    49e8:	4a67      	ldr	r2, [pc, #412]	@ (4b88 <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x310>)
    49ea:	4413      	add	r3, r2
    49ec:	4618      	mov	r0, r3
    49ee:	f7fe fb9b 	bl	3128 <CGraphDMMappingPayload::formatf() const>
                  printf("\n\n");
    49f2:	4867      	ldr	r0, [pc, #412]	@ (4b90 <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x318>)
    49f4:	f002 fb3e 	bl	7074 <puts>
    49f8:	e042      	b.n	4a80 <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x208>
                  uint32_t spiBits = 0; // initialize to 0
    49fa:	2300      	movs	r3, #0
    49fc:	f8c7 37a8 	str.w	r3, [r7, #1960]	@ 0x7a8
                  spiBits = DacVal + (DACaddr[DMMappings.Mappings[i].DacChannel] << 16); // shift the address and add to the DacVal
    4a00:	f8b7 17ae 	ldrh.w	r1, [r7, #1966]	@ 0x7ae
    4a04:	4860      	ldr	r0, [pc, #384]	@ (4b88 <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x310>)
    4a06:	f8d7 27b4 	ldr.w	r2, [r7, #1972]	@ 0x7b4
    4a0a:	4613      	mov	r3, r2
    4a0c:	005b      	lsls	r3, r3, #1
    4a0e:	4413      	add	r3, r2
    4a10:	4403      	add	r3, r0
    4a12:	3302      	adds	r3, #2
    4a14:	781b      	ldrb	r3, [r3, #0]
    4a16:	461a      	mov	r2, r3
    4a18:	4b5e      	ldr	r3, [pc, #376]	@ (4b94 <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x31c>)
    4a1a:	5c9b      	ldrb	r3, [r3, r2]
    4a1c:	041b      	lsls	r3, r3, #16
    4a1e:	440b      	add	r3, r1
    4a20:	f8c7 37a8 	str.w	r3, [r7, #1960]	@ 0x7a8
                  dRAM->DacSetpoints[DMMappings.Mappings[i].ControllerBoardIndex][DMMappings.Mappings[i].DacIndex][DMMappings.Mappings[i].DacChannel] = (spiBits);
    4a24:	4b5c      	ldr	r3, [pc, #368]	@ (4b98 <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x320>)
    4a26:	6819      	ldr	r1, [r3, #0]
    4a28:	4857      	ldr	r0, [pc, #348]	@ (4b88 <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x310>)
    4a2a:	f8d7 27b4 	ldr.w	r2, [r7, #1972]	@ 0x7b4
    4a2e:	4613      	mov	r3, r2
    4a30:	005b      	lsls	r3, r3, #1
    4a32:	4413      	add	r3, r2
    4a34:	4403      	add	r3, r0
    4a36:	781b      	ldrb	r3, [r3, #0]
    4a38:	461c      	mov	r4, r3
    4a3a:	4853      	ldr	r0, [pc, #332]	@ (4b88 <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x310>)
    4a3c:	f8d7 27b4 	ldr.w	r2, [r7, #1972]	@ 0x7b4
    4a40:	4613      	mov	r3, r2
    4a42:	005b      	lsls	r3, r3, #1
    4a44:	4413      	add	r3, r2
    4a46:	4403      	add	r3, r0
    4a48:	3301      	adds	r3, #1
    4a4a:	781b      	ldrb	r3, [r3, #0]
    4a4c:	461d      	mov	r5, r3
    4a4e:	484e      	ldr	r0, [pc, #312]	@ (4b88 <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x310>)
    4a50:	f8d7 27b4 	ldr.w	r2, [r7, #1972]	@ 0x7b4
    4a54:	4613      	mov	r3, r2
    4a56:	005b      	lsls	r3, r3, #1
    4a58:	4413      	add	r3, r2
    4a5a:	4403      	add	r3, r0
    4a5c:	3302      	adds	r3, #2
    4a5e:	781b      	ldrb	r3, [r3, #0]
    4a60:	4618      	mov	r0, r3
    4a62:	462a      	mov	r2, r5
    4a64:	0092      	lsls	r2, r2, #2
    4a66:	442a      	add	r2, r5
    4a68:	00d3      	lsls	r3, r2, #3
    4a6a:	461a      	mov	r2, r3
    4a6c:	4623      	mov	r3, r4
    4a6e:	009b      	lsls	r3, r3, #2
    4a70:	4423      	add	r3, r4
    4a72:	015b      	lsls	r3, r3, #5
    4a74:	4413      	add	r3, r2
    4a76:	4403      	add	r3, r0
    4a78:	f8d7 27a8 	ldr.w	r2, [r7, #1960]	@ 0x7a8
    4a7c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
              for (size_t i = StartPixel; i < (StartPixel + NumPixels); i++) {
    4a80:	f8d7 37b4 	ldr.w	r3, [r7, #1972]	@ 0x7b4
    4a84:	3301      	adds	r3, #1
    4a86:	f8c7 37b4 	str.w	r3, [r7, #1972]	@ 0x7b4
    4a8a:	f8d7 279c 	ldr.w	r2, [r7, #1948]	@ 0x79c
    4a8e:	f8d7 3798 	ldr.w	r3, [r7, #1944]	@ 0x798
    4a92:	4413      	add	r3, r2
    4a94:	f8d7 27b4 	ldr.w	r2, [r7, #1972]	@ 0x7b4
    4a98:	429a      	cmp	r2, r3
    4a9a:	f4ff af6d 	bcc.w	4978 <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x100>
              TxBinaryPacket(Argument, CGraphPayloadTypeDMShortPixels, 0, &NumPixels, sizeof(uint16_t));
    4a9e:	f507 63f3 	add.w	r3, r7, #1944	@ 0x798
    4aa2:	f507 62f7 	add.w	r2, r7, #1976	@ 0x7b8
    4aa6:	f5a2 60f7 	sub.w	r0, r2, #1976	@ 0x7b8
    4aaa:	2202      	movs	r2, #2
    4aac:	9200      	str	r2, [sp, #0]
    4aae:	2200      	movs	r2, #0
    4ab0:	f243 010c 	movw	r1, #12300	@ 0x300c
    4ab4:	6800      	ldr	r0, [r0, #0]
    4ab6:	f7fe fbab 	bl	3210 <TxBinaryPacket(void const*, unsigned short, unsigned long, void const*, unsigned int)>
	}
    4aba:	e054      	b.n	4b66 <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x2ee>
              printf("\nBinaryDMMappingCommand: Short packet: %u (exptected >%u bytes): ", ParamsLen, (sizeof(CGraphDMPixelPayloadHeader)));
    4abc:	f507 63f7 	add.w	r3, r7, #1976	@ 0x7b8
    4ac0:	f2a3 73b4 	subw	r3, r3, #1972	@ 0x7b4
    4ac4:	2202      	movs	r2, #2
    4ac6:	6819      	ldr	r1, [r3, #0]
    4ac8:	4834      	ldr	r0, [pc, #208]	@ (4b9c <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x324>)
    4aca:	f002 fa2f 	bl	6f2c <iprintf>
              TxBinaryPacket(Argument, CGraphPayloadTypeDMShortPixels, 0, &StartPixel, sizeof(uint16_t));
    4ace:	f207 739c 	addw	r3, r7, #1948	@ 0x79c
    4ad2:	f507 62f7 	add.w	r2, r7, #1976	@ 0x7b8
    4ad6:	f5a2 60f7 	sub.w	r0, r2, #1976	@ 0x7b8
    4ada:	2202      	movs	r2, #2
    4adc:	9200      	str	r2, [sp, #0]
    4ade:	2200      	movs	r2, #0
    4ae0:	f243 010c 	movw	r1, #12300	@ 0x300c
    4ae4:	6800      	ldr	r0, [r0, #0]
    4ae6:	f7fe fb93 	bl	3210 <TxBinaryPacket(void const*, unsigned short, unsigned long, void const*, unsigned int)>
	}
    4aea:	e03c      	b.n	4b66 <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x2ee>
	//empty packet? query.
	else {
          //Not sure what to do besides send back the whole entire block!
          uint8_t Buffer[(DMMaxActuators * sizeof(uint16_t)) + sizeof(CGraphDMPixelPayloadHeader)];
          uint16_t StartPix = 0;
    4aec:	2300      	movs	r3, #0
    4aee:	f8a7 3796 	strh.w	r3, [r7, #1942]	@ 0x796
          memcpy(Buffer, &StartPix, sizeof(CGraphDMPixelPayloadHeader));
    4af2:	f8b7 2796 	ldrh.w	r2, [r7, #1942]	@ 0x796
    4af6:	f507 63f7 	add.w	r3, r7, #1976	@ 0x7b8
    4afa:	f2a3 73a4 	subw	r3, r3, #1956	@ 0x7a4
    4afe:	801a      	strh	r2, [r3, #0]
          for (size_t j = 0; j < DMMaxActuators; j++) {
    4b00:	2300      	movs	r3, #0
    4b02:	f8c7 37b0 	str.w	r3, [r7, #1968]	@ 0x7b0
    4b06:	e01a      	b.n	4b3e <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x2c6>
            uint16_t* Pixel = reinterpret_cast<uint16_t*>(Buffer+sizeof(CGraphDMPixelPayloadHeader)+(j*sizeof(uint16_t)));
    4b08:	f8d7 37b0 	ldr.w	r3, [r7, #1968]	@ 0x7b0
    4b0c:	3301      	adds	r3, #1
    4b0e:	005b      	lsls	r3, r3, #1
    4b10:	f107 0214 	add.w	r2, r7, #20
    4b14:	4413      	add	r3, r2
    4b16:	f8c7 37a4 	str.w	r3, [r7, #1956]	@ 0x7a4
            *Pixel = (reinterpret_cast<uint32_t*>(dRAM->DacSetpoints)[j] >> 8);
    4b1a:	4b1f      	ldr	r3, [pc, #124]	@ (4b98 <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x320>)
    4b1c:	681b      	ldr	r3, [r3, #0]
    4b1e:	461a      	mov	r2, r3
    4b20:	f8d7 37b0 	ldr.w	r3, [r7, #1968]	@ 0x7b0
    4b24:	009b      	lsls	r3, r3, #2
    4b26:	4413      	add	r3, r2
    4b28:	681b      	ldr	r3, [r3, #0]
    4b2a:	0a1b      	lsrs	r3, r3, #8
    4b2c:	b29a      	uxth	r2, r3
    4b2e:	f8d7 37a4 	ldr.w	r3, [r7, #1956]	@ 0x7a4
    4b32:	801a      	strh	r2, [r3, #0]
          for (size_t j = 0; j < DMMaxActuators; j++) {
    4b34:	f8d7 37b0 	ldr.w	r3, [r7, #1968]	@ 0x7b0
    4b38:	3301      	adds	r3, #1
    4b3a:	f8c7 37b0 	str.w	r3, [r7, #1968]	@ 0x7b0
    4b3e:	f8d7 37b0 	ldr.w	r3, [r7, #1968]	@ 0x7b0
    4b42:	f5b3 7f70 	cmp.w	r3, #960	@ 0x3c0
    4b46:	d3df      	bcc.n	4b08 <BinaryDMShortPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x290>
          }
          TxBinaryPacket(Argument, CGraphPayloadTypeDMShortPixels, 0, Buffer, sizeof(CGraphDMPixelPayloadHeader) + (sizeof(uint16_t) * DMMaxControllerBoards * DMMDacsPerControllerBoard * DMActuatorsPerDac));
    4b48:	f107 0314 	add.w	r3, r7, #20
    4b4c:	f507 62f7 	add.w	r2, r7, #1976	@ 0x7b8
    4b50:	f5a2 60f7 	sub.w	r0, r2, #1976	@ 0x7b8
    4b54:	f240 7282 	movw	r2, #1922	@ 0x782
    4b58:	9200      	str	r2, [sp, #0]
    4b5a:	2200      	movs	r2, #0
    4b5c:	f243 010c 	movw	r1, #12300	@ 0x300c
    4b60:	6800      	ldr	r0, [r0, #0]
    4b62:	f7fe fb55 	bl	3210 <TxBinaryPacket(void const*, unsigned short, unsigned long, void const*, unsigned int)>
	}

        return(ParamsLen);
    4b66:	f507 63f7 	add.w	r3, r7, #1976	@ 0x7b8
    4b6a:	f2a3 73b4 	subw	r3, r3, #1972	@ 0x7b4
    4b6e:	681b      	ldr	r3, [r3, #0]
    4b70:	b25b      	sxtb	r3, r3
}
    4b72:	4618      	mov	r0, r3
    4b74:	f507 67f7 	add.w	r7, r7, #1976	@ 0x7b8
    4b78:	46bd      	mov	sp, r7
    4b7a:	bdb0      	pop	{r4, r5, r7, pc}
    4b7c:	2000003c 	.word	0x2000003c
    4b80:	0000ae28 	.word	0x0000ae28
    4b84:	0000ae70 	.word	0x0000ae70
    4b88:	200009e0 	.word	0x200009e0
    4b8c:	0000aea8 	.word	0x0000aea8
    4b90:	0000ab88 	.word	0x0000ab88
    4b94:	20000014 	.word	0x20000014
    4b98:	20000040 	.word	0x20000040
    4b9c:	0000aefc 	.word	0x0000aefc

00004ba0 <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)>:


int8_t BinaryDMDitherCommand(const uint32_t Name, char const* Params, const size_t ParamsLen, const void* Argument)
{
    4ba0:	b5f0      	push	{r4, r5, r6, r7, lr}
    4ba2:	f2ad 7dbc 	subw	sp, sp, #1980	@ 0x7bc
    4ba6:	af02      	add	r7, sp, #8
    4ba8:	f507 64f6 	add.w	r4, r7, #1968	@ 0x7b0
    4bac:	f2a4 74a4 	subw	r4, r4, #1956	@ 0x7a4
    4bb0:	6020      	str	r0, [r4, #0]
    4bb2:	f507 60f6 	add.w	r0, r7, #1968	@ 0x7b0
    4bb6:	f5a0 60f5 	sub.w	r0, r0, #1960	@ 0x7a8
    4bba:	6001      	str	r1, [r0, #0]
    4bbc:	f507 61f6 	add.w	r1, r7, #1968	@ 0x7b0
    4bc0:	f2a1 71ac 	subw	r1, r1, #1964	@ 0x7ac
    4bc4:	600a      	str	r2, [r1, #0]
    4bc6:	f507 62f6 	add.w	r2, r7, #1968	@ 0x7b0
    4bca:	f5a2 62f6 	sub.w	r2, r2, #1968	@ 0x7b0
    4bce:	6013      	str	r3, [r2, #0]
	if (nullptr == DM)
    4bd0:	4bc6      	ldr	r3, [pc, #792]	@ (4eec <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x34c>)
    4bd2:	681b      	ldr	r3, [r3, #0]
    4bd4:	2b00      	cmp	r3, #0
    4bd6:	d109      	bne.n	4bec <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x4c>
	{
		printf("\nBinaryDMDitherCommand: DM pointer is NULL! Firmware corrupted!\n");	
    4bd8:	48c5      	ldr	r0, [pc, #788]	@ (4ef0 <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x350>)
    4bda:	f002 fa4b 	bl	7074 <puts>
		return(ParamsLen);
    4bde:	f507 63f6 	add.w	r3, r7, #1968	@ 0x7b0
    4be2:	f2a3 73ac 	subw	r3, r3, #1964	@ 0x7ac
    4be6:	681b      	ldr	r3, [r3, #0]
    4be8:	b25b      	sxtb	r3, r3
    4bea:	e17a      	b.n	4ee2 <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x342>
	}

	if ( (nullptr != Params) && (ParamsLen >= sizeof(CGraphDMPixelPayloadHeader)) )
    4bec:	f507 63f6 	add.w	r3, r7, #1968	@ 0x7b0
    4bf0:	f5a3 63f5 	sub.w	r3, r3, #1960	@ 0x7a8
    4bf4:	681b      	ldr	r3, [r3, #0]
    4bf6:	2b00      	cmp	r3, #0
    4bf8:	f000 8132 	beq.w	4e60 <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x2c0>
    4bfc:	f507 63f6 	add.w	r3, r7, #1968	@ 0x7b0
    4c00:	f2a3 73ac 	subw	r3, r3, #1964	@ 0x7ac
    4c04:	681b      	ldr	r3, [r3, #0]
    4c06:	2b01      	cmp	r3, #1
    4c08:	f240 812a 	bls.w	4e60 <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x2c0>
	{
		//ok, first we're looking for a packet with the start pixel and some pix's in it:
		const CGraphDMPixelPayloadHeader PixelHeader = *reinterpret_cast<const CGraphDMPixelPayloadHeader*>(Params);
    4c0c:	f507 63f6 	add.w	r3, r7, #1968	@ 0x7b0
    4c10:	f5a3 63f5 	sub.w	r3, r3, #1960	@ 0x7a8
    4c14:	681b      	ldr	r3, [r3, #0]
    4c16:	881b      	ldrh	r3, [r3, #0]
    4c18:	f8a7 379c 	strh.w	r3, [r7, #1948]	@ 0x79c
		const unsigned long StartPixel = PixelHeader.StartPixel;
    4c1c:	f8b7 379c 	ldrh.w	r3, [r7, #1948]	@ 0x79c
    4c20:	f8c7 3798 	str.w	r3, [r7, #1944]	@ 0x798
		if (StartPixel > DMMaxActuators) 
    4c24:	f8d7 3798 	ldr.w	r3, [r7, #1944]	@ 0x798
    4c28:	f5b3 7f70 	cmp.w	r3, #960	@ 0x3c0
    4c2c:	d914      	bls.n	4c58 <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0xb8>
		{
			//Complain and bail out, something is horribly wrong:
			printf("\nBinaryDMDitherCommand: Invalid StartPixel: %lu!\n", (unsigned long)StartPixel);
    4c2e:	f8d7 3798 	ldr.w	r3, [r7, #1944]	@ 0x798
    4c32:	4619      	mov	r1, r3
    4c34:	48af      	ldr	r0, [pc, #700]	@ (4ef4 <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x354>)
    4c36:	f002 f979 	bl	6f2c <iprintf>
			TxBinaryPacket(Argument, CGraphPayloadTypeDMDither, 0, &StartPixel, sizeof(uint16_t));
    4c3a:	f507 63f3 	add.w	r3, r7, #1944	@ 0x798
    4c3e:	f507 62f6 	add.w	r2, r7, #1968	@ 0x7b0
    4c42:	f5a2 60f6 	sub.w	r0, r2, #1968	@ 0x7b0
    4c46:	2202      	movs	r2, #2
    4c48:	9200      	str	r2, [sp, #0]
    4c4a:	2200      	movs	r2, #0
    4c4c:	f243 010d 	movw	r1, #12301	@ 0x300d
    4c50:	6800      	ldr	r0, [r0, #0]
    4c52:	f7fe fadd 	bl	3210 <TxBinaryPacket(void const*, unsigned short, unsigned long, void const*, unsigned int)>
			{
				printf("\nBinaryDMMappingCommand: Dither packet: %u (exptected >%u bytes): ", ParamsLen, (sizeof(CGraphDMPixelPayloadHeader)));
				TxBinaryPacket(Argument, CGraphPayloadTypeDMDither, 0, &StartPixel, sizeof(uint16_t));
			}
		}
	}
    4c56:	e13e      	b.n	4ed6 <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x336>
			if (ParamsLen >= sizeof(CGraphDMPixelPayloadHeader))
    4c58:	f507 63f6 	add.w	r3, r7, #1968	@ 0x7b0
    4c5c:	f2a3 73ac 	subw	r3, r3, #1964	@ 0x7ac
    4c60:	681b      	ldr	r3, [r3, #0]
    4c62:	2b01      	cmp	r3, #1
    4c64:	f240 80e4 	bls.w	4e30 <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x290>
				unsigned long NumPixels = (ParamsLen - sizeof(CGraphDMPixelPayloadHeader)) / sizeof(uint8_t);
    4c68:	f507 63f6 	add.w	r3, r7, #1968	@ 0x7b0
    4c6c:	f2a3 73ac 	subw	r3, r3, #1964	@ 0x7ac
    4c70:	681b      	ldr	r3, [r3, #0]
    4c72:	3b02      	subs	r3, #2
    4c74:	f8c7 3794 	str.w	r3, [r7, #1940]	@ 0x794
				if ((NumPixels + StartPixel) > DMMaxActuators) { NumPixels = DMMaxActuators - StartPixel; } //do let's try not to blow our array...
    4c78:	f8d7 2794 	ldr.w	r2, [r7, #1940]	@ 0x794
    4c7c:	f8d7 3798 	ldr.w	r3, [r7, #1944]	@ 0x798
    4c80:	4413      	add	r3, r2
    4c82:	f5b3 7f70 	cmp.w	r3, #960	@ 0x3c0
    4c86:	d905      	bls.n	4c94 <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0xf4>
    4c88:	f8d7 3798 	ldr.w	r3, [r7, #1944]	@ 0x798
    4c8c:	f5c3 7370 	rsb	r3, r3, #960	@ 0x3c0
    4c90:	f8c7 3794 	str.w	r3, [r7, #1940]	@ 0x794
				printf("\nBinaryDMDitherCommand: StartPixel: %lu, NumPixels: %lu\n", StartPixel, NumPixels);
    4c94:	f8d7 3798 	ldr.w	r3, [r7, #1944]	@ 0x798
    4c98:	f8d7 2794 	ldr.w	r2, [r7, #1940]	@ 0x794
    4c9c:	4619      	mov	r1, r3
    4c9e:	4896      	ldr	r0, [pc, #600]	@ (4ef8 <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x358>)
    4ca0:	f002 f944 	bl	6f2c <iprintf>
				for (size_t i = StartPixel; i < (StartPixel + NumPixels); i++)
    4ca4:	f8d7 3798 	ldr.w	r3, [r7, #1944]	@ 0x798
    4ca8:	f8c7 37ac 	str.w	r3, [r7, #1964]	@ 0x7ac
    4cac:	e0a7      	b.n	4dfe <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x25e>
					const uint8_t DacVal = *reinterpret_cast<const uint8_t*>(Params+sizeof(CGraphDMPixelPayloadHeader)+((i - StartPixel)*sizeof(uint8_t)));
    4cae:	f8d7 3798 	ldr.w	r3, [r7, #1944]	@ 0x798
    4cb2:	f8d7 27ac 	ldr.w	r2, [r7, #1964]	@ 0x7ac
    4cb6:	1ad3      	subs	r3, r2, r3
    4cb8:	3302      	adds	r3, #2
    4cba:	f507 62f6 	add.w	r2, r7, #1968	@ 0x7b0
    4cbe:	f5a2 62f5 	sub.w	r2, r2, #1960	@ 0x7a8
    4cc2:	6812      	ldr	r2, [r2, #0]
    4cc4:	4413      	add	r3, r2
    4cc6:	781b      	ldrb	r3, [r3, #0]
    4cc8:	f887 37a7 	strb.w	r3, [r7, #1959]	@ 0x7a7
					if ( (DMMappings.Mappings[i].ControllerBoardIndex >= DMMaxControllerBoards) || (DMMappings.Mappings[i].ControllerBoardIndex >= DMMaxControllerBoards) || (DMMappings.Mappings[i].ControllerBoardIndex >= DMMaxControllerBoards) )
    4ccc:	498b      	ldr	r1, [pc, #556]	@ (4efc <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x35c>)
    4cce:	f8d7 27ac 	ldr.w	r2, [r7, #1964]	@ 0x7ac
    4cd2:	4613      	mov	r3, r2
    4cd4:	005b      	lsls	r3, r3, #1
    4cd6:	4413      	add	r3, r2
    4cd8:	440b      	add	r3, r1
    4cda:	781b      	ldrb	r3, [r3, #0]
    4cdc:	2b05      	cmp	r3, #5
    4cde:	d813      	bhi.n	4d08 <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x168>
    4ce0:	4986      	ldr	r1, [pc, #536]	@ (4efc <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x35c>)
    4ce2:	f8d7 27ac 	ldr.w	r2, [r7, #1964]	@ 0x7ac
    4ce6:	4613      	mov	r3, r2
    4ce8:	005b      	lsls	r3, r3, #1
    4cea:	4413      	add	r3, r2
    4cec:	440b      	add	r3, r1
    4cee:	781b      	ldrb	r3, [r3, #0]
    4cf0:	2b05      	cmp	r3, #5
    4cf2:	d809      	bhi.n	4d08 <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x168>
    4cf4:	4981      	ldr	r1, [pc, #516]	@ (4efc <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x35c>)
    4cf6:	f8d7 27ac 	ldr.w	r2, [r7, #1964]	@ 0x7ac
    4cfa:	4613      	mov	r3, r2
    4cfc:	005b      	lsls	r3, r3, #1
    4cfe:	4413      	add	r3, r2
    4d00:	440b      	add	r3, r1
    4d02:	781b      	ldrb	r3, [r3, #0]
    4d04:	2b05      	cmp	r3, #5
    4d06:	d912      	bls.n	4d2e <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x18e>
						printf("\nBinaryDMDitherCommand: Invalid mapping %lu; please reinitialize mappings!: ", (unsigned long)i);
    4d08:	f8d7 17ac 	ldr.w	r1, [r7, #1964]	@ 0x7ac
    4d0c:	487c      	ldr	r0, [pc, #496]	@ (4f00 <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x360>)
    4d0e:	f002 f90d 	bl	6f2c <iprintf>
						DMMappings.Mappings[i].formatf();
    4d12:	f8d7 27ac 	ldr.w	r2, [r7, #1964]	@ 0x7ac
    4d16:	4613      	mov	r3, r2
    4d18:	005b      	lsls	r3, r3, #1
    4d1a:	4413      	add	r3, r2
    4d1c:	4a77      	ldr	r2, [pc, #476]	@ (4efc <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x35c>)
    4d1e:	4413      	add	r3, r2
    4d20:	4618      	mov	r0, r3
    4d22:	f7fe fa01 	bl	3128 <CGraphDMMappingPayload::formatf() const>
						printf("\n\n");
    4d26:	4877      	ldr	r0, [pc, #476]	@ (4f04 <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x364>)
    4d28:	f002 f9a4 	bl	7074 <puts>
    4d2c:	e062      	b.n	4df4 <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x254>
						dRAM->DacSetpoints[DMMappings.Mappings[i].ControllerBoardIndex][DMMappings.Mappings[i].DacIndex][DMMappings.Mappings[i].DacChannel] |= (uint32_t)DacVal; //note value is OR'ed in, high bytes never get altered by this command...
    4d2e:	4b76      	ldr	r3, [pc, #472]	@ (4f08 <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x368>)
    4d30:	6819      	ldr	r1, [r3, #0]
    4d32:	4872      	ldr	r0, [pc, #456]	@ (4efc <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x35c>)
    4d34:	f8d7 27ac 	ldr.w	r2, [r7, #1964]	@ 0x7ac
    4d38:	4613      	mov	r3, r2
    4d3a:	005b      	lsls	r3, r3, #1
    4d3c:	4413      	add	r3, r2
    4d3e:	4403      	add	r3, r0
    4d40:	781b      	ldrb	r3, [r3, #0]
    4d42:	461c      	mov	r4, r3
    4d44:	486d      	ldr	r0, [pc, #436]	@ (4efc <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x35c>)
    4d46:	f8d7 27ac 	ldr.w	r2, [r7, #1964]	@ 0x7ac
    4d4a:	4613      	mov	r3, r2
    4d4c:	005b      	lsls	r3, r3, #1
    4d4e:	4413      	add	r3, r2
    4d50:	4403      	add	r3, r0
    4d52:	3301      	adds	r3, #1
    4d54:	781b      	ldrb	r3, [r3, #0]
    4d56:	461d      	mov	r5, r3
    4d58:	4868      	ldr	r0, [pc, #416]	@ (4efc <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x35c>)
    4d5a:	f8d7 27ac 	ldr.w	r2, [r7, #1964]	@ 0x7ac
    4d5e:	4613      	mov	r3, r2
    4d60:	005b      	lsls	r3, r3, #1
    4d62:	4413      	add	r3, r2
    4d64:	4403      	add	r3, r0
    4d66:	3302      	adds	r3, #2
    4d68:	781b      	ldrb	r3, [r3, #0]
    4d6a:	4618      	mov	r0, r3
    4d6c:	462a      	mov	r2, r5
    4d6e:	0092      	lsls	r2, r2, #2
    4d70:	442a      	add	r2, r5
    4d72:	00d3      	lsls	r3, r2, #3
    4d74:	461a      	mov	r2, r3
    4d76:	4623      	mov	r3, r4
    4d78:	009b      	lsls	r3, r3, #2
    4d7a:	4423      	add	r3, r4
    4d7c:	015b      	lsls	r3, r3, #5
    4d7e:	4413      	add	r3, r2
    4d80:	4403      	add	r3, r0
    4d82:	f851 4023 	ldr.w	r4, [r1, r3, lsl #2]
    4d86:	f897 07a7 	ldrb.w	r0, [r7, #1959]	@ 0x7a7
    4d8a:	4b5f      	ldr	r3, [pc, #380]	@ (4f08 <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x368>)
    4d8c:	6819      	ldr	r1, [r3, #0]
    4d8e:	4d5b      	ldr	r5, [pc, #364]	@ (4efc <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x35c>)
    4d90:	f8d7 27ac 	ldr.w	r2, [r7, #1964]	@ 0x7ac
    4d94:	4613      	mov	r3, r2
    4d96:	005b      	lsls	r3, r3, #1
    4d98:	4413      	add	r3, r2
    4d9a:	442b      	add	r3, r5
    4d9c:	781b      	ldrb	r3, [r3, #0]
    4d9e:	461e      	mov	r6, r3
    4da0:	4d56      	ldr	r5, [pc, #344]	@ (4efc <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x35c>)
    4da2:	f8d7 27ac 	ldr.w	r2, [r7, #1964]	@ 0x7ac
    4da6:	4613      	mov	r3, r2
    4da8:	005b      	lsls	r3, r3, #1
    4daa:	4413      	add	r3, r2
    4dac:	442b      	add	r3, r5
    4dae:	3301      	adds	r3, #1
    4db0:	781b      	ldrb	r3, [r3, #0]
    4db2:	469c      	mov	ip, r3
    4db4:	4d51      	ldr	r5, [pc, #324]	@ (4efc <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x35c>)
    4db6:	f8d7 27ac 	ldr.w	r2, [r7, #1964]	@ 0x7ac
    4dba:	4613      	mov	r3, r2
    4dbc:	005b      	lsls	r3, r3, #1
    4dbe:	4413      	add	r3, r2
    4dc0:	442b      	add	r3, r5
    4dc2:	3302      	adds	r3, #2
    4dc4:	781b      	ldrb	r3, [r3, #0]
    4dc6:	461d      	mov	r5, r3
    4dc8:	4320      	orrs	r0, r4
    4dca:	4662      	mov	r2, ip
    4dcc:	0092      	lsls	r2, r2, #2
    4dce:	4462      	add	r2, ip
    4dd0:	00d3      	lsls	r3, r2, #3
    4dd2:	461a      	mov	r2, r3
    4dd4:	4633      	mov	r3, r6
    4dd6:	009b      	lsls	r3, r3, #2
    4dd8:	4433      	add	r3, r6
    4dda:	015b      	lsls	r3, r3, #5
    4ddc:	4413      	add	r3, r2
    4dde:	442b      	add	r3, r5
    4de0:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
						printf("\nBinaryDMDitherCommand: Set actuator %lu to %lu", (unsigned long)i, (unsigned long)DacVal);
    4de4:	f897 37a7 	ldrb.w	r3, [r7, #1959]	@ 0x7a7
    4de8:	461a      	mov	r2, r3
    4dea:	f8d7 17ac 	ldr.w	r1, [r7, #1964]	@ 0x7ac
    4dee:	4847      	ldr	r0, [pc, #284]	@ (4f0c <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x36c>)
    4df0:	f002 f89c 	bl	6f2c <iprintf>
				for (size_t i = StartPixel; i < (StartPixel + NumPixels); i++)
    4df4:	f8d7 37ac 	ldr.w	r3, [r7, #1964]	@ 0x7ac
    4df8:	3301      	adds	r3, #1
    4dfa:	f8c7 37ac 	str.w	r3, [r7, #1964]	@ 0x7ac
    4dfe:	f8d7 2798 	ldr.w	r2, [r7, #1944]	@ 0x798
    4e02:	f8d7 3794 	ldr.w	r3, [r7, #1940]	@ 0x794
    4e06:	4413      	add	r3, r2
    4e08:	f8d7 27ac 	ldr.w	r2, [r7, #1964]	@ 0x7ac
    4e0c:	429a      	cmp	r2, r3
    4e0e:	f4ff af4e 	bcc.w	4cae <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x10e>
				TxBinaryPacket(Argument, CGraphPayloadTypeDMDither, 0, &NumPixels, sizeof(uint16_t));
    4e12:	f207 7394 	addw	r3, r7, #1940	@ 0x794
    4e16:	f507 62f6 	add.w	r2, r7, #1968	@ 0x7b0
    4e1a:	f5a2 60f6 	sub.w	r0, r2, #1968	@ 0x7b0
    4e1e:	2202      	movs	r2, #2
    4e20:	9200      	str	r2, [sp, #0]
    4e22:	2200      	movs	r2, #0
    4e24:	f243 010d 	movw	r1, #12301	@ 0x300d
    4e28:	6800      	ldr	r0, [r0, #0]
    4e2a:	f7fe f9f1 	bl	3210 <TxBinaryPacket(void const*, unsigned short, unsigned long, void const*, unsigned int)>
	}
    4e2e:	e052      	b.n	4ed6 <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x336>
				printf("\nBinaryDMMappingCommand: Dither packet: %u (exptected >%u bytes): ", ParamsLen, (sizeof(CGraphDMPixelPayloadHeader)));
    4e30:	f507 63f6 	add.w	r3, r7, #1968	@ 0x7b0
    4e34:	f2a3 73ac 	subw	r3, r3, #1964	@ 0x7ac
    4e38:	2202      	movs	r2, #2
    4e3a:	6819      	ldr	r1, [r3, #0]
    4e3c:	4834      	ldr	r0, [pc, #208]	@ (4f10 <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x370>)
    4e3e:	f002 f875 	bl	6f2c <iprintf>
				TxBinaryPacket(Argument, CGraphPayloadTypeDMDither, 0, &StartPixel, sizeof(uint16_t));
    4e42:	f507 63f3 	add.w	r3, r7, #1944	@ 0x798
    4e46:	f507 62f6 	add.w	r2, r7, #1968	@ 0x7b0
    4e4a:	f5a2 60f6 	sub.w	r0, r2, #1968	@ 0x7b0
    4e4e:	2202      	movs	r2, #2
    4e50:	9200      	str	r2, [sp, #0]
    4e52:	2200      	movs	r2, #0
    4e54:	f243 010d 	movw	r1, #12301	@ 0x300d
    4e58:	6800      	ldr	r0, [r0, #0]
    4e5a:	f7fe f9d9 	bl	3210 <TxBinaryPacket(void const*, unsigned short, unsigned long, void const*, unsigned int)>
	}
    4e5e:	e03a      	b.n	4ed6 <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x336>
	//empty packet? query.
	else
	{
		//Not sure what to do besides send back the whole entire block!
		uint8_t Buffer[(DMMaxActuators * sizeof(uint16_t)) + sizeof(CGraphDMPixelPayloadHeader)];
		uint16_t StartPix = 0;
    4e60:	2300      	movs	r3, #0
    4e62:	f8a7 3792 	strh.w	r3, [r7, #1938]	@ 0x792
		memcpy(Buffer, &StartPix, sizeof(CGraphDMPixelPayloadHeader));
    4e66:	f8b7 2792 	ldrh.w	r2, [r7, #1938]	@ 0x792
    4e6a:	f507 63f6 	add.w	r3, r7, #1968	@ 0x7b0
    4e6e:	f5a3 63f4 	sub.w	r3, r3, #1952	@ 0x7a0
    4e72:	801a      	strh	r2, [r3, #0]
		for (size_t j = 0; j < DMMaxActuators; j++)
    4e74:	2300      	movs	r3, #0
    4e76:	f8c7 37a8 	str.w	r3, [r7, #1960]	@ 0x7a8
    4e7a:	e018      	b.n	4eae <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x30e>
		{
			uint8_t* Pixel = reinterpret_cast<uint8_t*>(Buffer+sizeof(CGraphDMPixelPayloadHeader)+(j*sizeof(uint8_t)));
    4e7c:	f8d7 37a8 	ldr.w	r3, [r7, #1960]	@ 0x7a8
    4e80:	3302      	adds	r3, #2
    4e82:	f107 0210 	add.w	r2, r7, #16
    4e86:	4413      	add	r3, r2
    4e88:	f8c7 37a0 	str.w	r3, [r7, #1952]	@ 0x7a0
			*Pixel = (reinterpret_cast<uint32_t*>(dRAM->DacSetpoints)[j] & 0x000000FFUL);
    4e8c:	4b1e      	ldr	r3, [pc, #120]	@ (4f08 <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x368>)
    4e8e:	681b      	ldr	r3, [r3, #0]
    4e90:	461a      	mov	r2, r3
    4e92:	f8d7 37a8 	ldr.w	r3, [r7, #1960]	@ 0x7a8
    4e96:	009b      	lsls	r3, r3, #2
    4e98:	4413      	add	r3, r2
    4e9a:	681b      	ldr	r3, [r3, #0]
    4e9c:	b2da      	uxtb	r2, r3
    4e9e:	f8d7 37a0 	ldr.w	r3, [r7, #1952]	@ 0x7a0
    4ea2:	701a      	strb	r2, [r3, #0]
		for (size_t j = 0; j < DMMaxActuators; j++)
    4ea4:	f8d7 37a8 	ldr.w	r3, [r7, #1960]	@ 0x7a8
    4ea8:	3301      	adds	r3, #1
    4eaa:	f8c7 37a8 	str.w	r3, [r7, #1960]	@ 0x7a8
    4eae:	f8d7 37a8 	ldr.w	r3, [r7, #1960]	@ 0x7a8
    4eb2:	f5b3 7f70 	cmp.w	r3, #960	@ 0x3c0
    4eb6:	d3e1      	bcc.n	4e7c <BinaryDMDitherCommand(unsigned long, char const*, unsigned int, void const*)+0x2dc>
		}
		TxBinaryPacket(Argument, CGraphPayloadTypeDMDither, 0, Buffer, sizeof(CGraphDMPixelPayloadHeader) + (sizeof(uint8_t) * DMMaxControllerBoards * DMMDacsPerControllerBoard * DMActuatorsPerDac));
    4eb8:	f107 0310 	add.w	r3, r7, #16
    4ebc:	f507 62f6 	add.w	r2, r7, #1968	@ 0x7b0
    4ec0:	f5a2 60f6 	sub.w	r0, r2, #1968	@ 0x7b0
    4ec4:	f240 32c2 	movw	r2, #962	@ 0x3c2
    4ec8:	9200      	str	r2, [sp, #0]
    4eca:	2200      	movs	r2, #0
    4ecc:	f243 010d 	movw	r1, #12301	@ 0x300d
    4ed0:	6800      	ldr	r0, [r0, #0]
    4ed2:	f7fe f99d 	bl	3210 <TxBinaryPacket(void const*, unsigned short, unsigned long, void const*, unsigned int)>
	}
		
    return(ParamsLen);
    4ed6:	f507 63f6 	add.w	r3, r7, #1968	@ 0x7b0
    4eda:	f2a3 73ac 	subw	r3, r3, #1964	@ 0x7ac
    4ede:	681b      	ldr	r3, [r3, #0]
    4ee0:	b25b      	sxtb	r3, r3
}
    4ee2:	4618      	mov	r0, r3
    4ee4:	f207 77b4 	addw	r7, r7, #1972	@ 0x7b4
    4ee8:	46bd      	mov	sp, r7
    4eea:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4eec:	2000003c 	.word	0x2000003c
    4ef0:	0000af40 	.word	0x0000af40
    4ef4:	0000af80 	.word	0x0000af80
    4ef8:	0000afb4 	.word	0x0000afb4
    4efc:	200009e0 	.word	0x200009e0
    4f00:	0000aff0 	.word	0x0000aff0
    4f04:	0000ab88 	.word	0x0000ab88
    4f08:	20000040 	.word	0x20000040
    4f0c:	0000b040 	.word	0x0000b040
    4f10:	0000b070 	.word	0x0000b070

00004f14 <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)>:
int8_t BinaryDMLongPixelsCommand(const uint32_t Name, char const* Params, const size_t ParamsLen, const void* Argument)
{
    4f14:	b5f0      	push	{r4, r5, r6, r7, lr}
    4f16:	f6ad 3d7c 	subw	sp, sp, #2940	@ 0xb7c
    4f1a:	af02      	add	r7, sp, #8
    4f1c:	f507 6437 	add.w	r4, r7, #2928	@ 0xb70
    4f20:	f6a4 3464 	subw	r4, r4, #2916	@ 0xb64
    4f24:	6020      	str	r0, [r4, #0]
    4f26:	f507 6037 	add.w	r0, r7, #2928	@ 0xb70
    4f2a:	f6a0 3068 	subw	r0, r0, #2920	@ 0xb68
    4f2e:	6001      	str	r1, [r0, #0]
    4f30:	f507 6137 	add.w	r1, r7, #2928	@ 0xb70
    4f34:	f6a1 316c 	subw	r1, r1, #2924	@ 0xb6c
    4f38:	600a      	str	r2, [r1, #0]
    4f3a:	f507 6237 	add.w	r2, r7, #2928	@ 0xb70
    4f3e:	f5a2 6237 	sub.w	r2, r2, #2928	@ 0xb70
    4f42:	6013      	str	r3, [r2, #0]
	if (nullptr == DM)
    4f44:	4bc3      	ldr	r3, [pc, #780]	@ (5254 <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x340>)
    4f46:	681b      	ldr	r3, [r3, #0]
    4f48:	2b00      	cmp	r3, #0
    4f4a:	d109      	bne.n	4f60 <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x4c>
	{
		printf("\nBinaryDMLongPixelsCommand: DM pointer is NULL! Firmware corrupted!\n");	
    4f4c:	48c2      	ldr	r0, [pc, #776]	@ (5258 <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x344>)
    4f4e:	f002 f891 	bl	7074 <puts>
		return(ParamsLen);
    4f52:	f507 6337 	add.w	r3, r7, #2928	@ 0xb70
    4f56:	f6a3 336c 	subw	r3, r3, #2924	@ 0xb6c
    4f5a:	681b      	ldr	r3, [r3, #0]
    4f5c:	b25b      	sxtb	r3, r3
    4f5e:	e174      	b.n	524a <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x336>
	}

	if ( (nullptr != Params) && (ParamsLen >= sizeof(CGraphDMPixelPayloadHeader)) )
    4f60:	f507 6337 	add.w	r3, r7, #2928	@ 0xb70
    4f64:	f6a3 3368 	subw	r3, r3, #2920	@ 0xb68
    4f68:	681b      	ldr	r3, [r3, #0]
    4f6a:	2b00      	cmp	r3, #0
    4f6c:	f000 810d 	beq.w	518a <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x276>
    4f70:	f507 6337 	add.w	r3, r7, #2928	@ 0xb70
    4f74:	f6a3 336c 	subw	r3, r3, #2924	@ 0xb6c
    4f78:	681b      	ldr	r3, [r3, #0]
    4f7a:	2b01      	cmp	r3, #1
    4f7c:	f240 8105 	bls.w	518a <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x276>
	{
		//ok, first we're looking for a packet with the start pixel and some pix's in it:
		const CGraphDMPixelPayloadHeader PixelHeader = *reinterpret_cast<const CGraphDMPixelPayloadHeader*>(Params);
    4f80:	f507 6337 	add.w	r3, r7, #2928	@ 0xb70
    4f84:	f6a3 3368 	subw	r3, r3, #2920	@ 0xb68
    4f88:	681b      	ldr	r3, [r3, #0]
    4f8a:	881b      	ldrh	r3, [r3, #0]
    4f8c:	f8a7 3b5c 	strh.w	r3, [r7, #2908]	@ 0xb5c
		const unsigned long StartPixel = PixelHeader.StartPixel;
    4f90:	f8b7 3b5c 	ldrh.w	r3, [r7, #2908]	@ 0xb5c
    4f94:	f8c7 3b58 	str.w	r3, [r7, #2904]	@ 0xb58
		if (StartPixel > DMMaxActuators) 
    4f98:	f8d7 3b58 	ldr.w	r3, [r7, #2904]	@ 0xb58
    4f9c:	f5b3 7f70 	cmp.w	r3, #960	@ 0x3c0
    4fa0:	d914      	bls.n	4fcc <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0xb8>
		{
			//Complain and bail out, something is horribly wrong:
			printf("\nBinaryDMLongPixelsCommand: Invalid StartPixel: %lu!\n", (unsigned long)StartPixel);
    4fa2:	f8d7 3b58 	ldr.w	r3, [r7, #2904]	@ 0xb58
    4fa6:	4619      	mov	r1, r3
    4fa8:	48ac      	ldr	r0, [pc, #688]	@ (525c <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x348>)
    4faa:	f001 ffbf 	bl	6f2c <iprintf>
			TxBinaryPacket(Argument, CGraphPayloadTypeDMLongPixels, 0, &StartPixel, sizeof(uint16_t));
    4fae:	f607 3358 	addw	r3, r7, #2904	@ 0xb58
    4fb2:	f507 6237 	add.w	r2, r7, #2928	@ 0xb70
    4fb6:	f5a2 6037 	sub.w	r0, r2, #2928	@ 0xb70
    4fba:	2202      	movs	r2, #2
    4fbc:	9200      	str	r2, [sp, #0]
    4fbe:	2200      	movs	r2, #0
    4fc0:	f243 010e 	movw	r1, #12302	@ 0x300e
    4fc4:	6800      	ldr	r0, [r0, #0]
    4fc6:	f7fe f923 	bl	3210 <TxBinaryPacket(void const*, unsigned short, unsigned long, void const*, unsigned int)>
			{
				printf("\nBinaryDMMappingCommand: Long packet: %u (exptected >%u bytes): ", ParamsLen, (sizeof(CGraphDMPixelPayloadHeader)));
				TxBinaryPacket(Argument, CGraphPayloadTypeDMLongPixels, 0, &StartPixel, sizeof(uint16_t));
			}
		}
	}
    4fca:	e138      	b.n	523e <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x32a>
			if (ParamsLen >= sizeof(CGraphDMPixelPayloadHeader))
    4fcc:	f507 6337 	add.w	r3, r7, #2928	@ 0xb70
    4fd0:	f6a3 336c 	subw	r3, r3, #2924	@ 0xb6c
    4fd4:	681b      	ldr	r3, [r3, #0]
    4fd6:	2b01      	cmp	r3, #1
    4fd8:	f240 80bf 	bls.w	515a <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x246>
				unsigned long NumPixels = (ParamsLen - sizeof(CGraphDMPixelPayloadHeader)) / (3 * sizeof(uint8_t));
    4fdc:	f507 6337 	add.w	r3, r7, #2928	@ 0xb70
    4fe0:	f6a3 336c 	subw	r3, r3, #2924	@ 0xb6c
    4fe4:	681b      	ldr	r3, [r3, #0]
    4fe6:	3b02      	subs	r3, #2
    4fe8:	4a9d      	ldr	r2, [pc, #628]	@ (5260 <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x34c>)
    4fea:	fba2 2303 	umull	r2, r3, r2, r3
    4fee:	085b      	lsrs	r3, r3, #1
    4ff0:	f8c7 3b54 	str.w	r3, [r7, #2900]	@ 0xb54
				if ((NumPixels + StartPixel) > DMMaxActuators) { NumPixels = DMMaxActuators - StartPixel; } //do let's try not to blow our array...
    4ff4:	f8d7 2b54 	ldr.w	r2, [r7, #2900]	@ 0xb54
    4ff8:	f8d7 3b58 	ldr.w	r3, [r7, #2904]	@ 0xb58
    4ffc:	4413      	add	r3, r2
    4ffe:	f5b3 7f70 	cmp.w	r3, #960	@ 0x3c0
    5002:	d905      	bls.n	5010 <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0xfc>
    5004:	f8d7 3b58 	ldr.w	r3, [r7, #2904]	@ 0xb58
    5008:	f5c3 7370 	rsb	r3, r3, #960	@ 0x3c0
    500c:	f8c7 3b54 	str.w	r3, [r7, #2900]	@ 0xb54
				printf("\nBinaryDMLongPixelsCommand: StartPixel: %lu, NumPixels: %lu\n", StartPixel, NumPixels);
    5010:	f8d7 3b58 	ldr.w	r3, [r7, #2904]	@ 0xb58
    5014:	f8d7 2b54 	ldr.w	r2, [r7, #2900]	@ 0xb54
    5018:	4619      	mov	r1, r3
    501a:	4892      	ldr	r0, [pc, #584]	@ (5264 <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x350>)
    501c:	f001 ff86 	bl	6f2c <iprintf>
				for (size_t i = StartPixel; i < (StartPixel + NumPixels); i++)
    5020:	f8d7 3b58 	ldr.w	r3, [r7, #2904]	@ 0xb58
    5024:	f8c7 3b6c 	str.w	r3, [r7, #2924]	@ 0xb6c
    5028:	e07e      	b.n	5128 <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x214>
					const uint32_t DacVal = *reinterpret_cast<const uint32_t*>(Params+sizeof(CGraphDMPixelPayloadHeader)+((i - StartPixel)*3*sizeof(uint8_t))); //Note the "*3" for 24-bit pixels!!!
    502a:	f8d7 3b58 	ldr.w	r3, [r7, #2904]	@ 0xb58
    502e:	f8d7 2b6c 	ldr.w	r2, [r7, #2924]	@ 0xb6c
    5032:	1ad2      	subs	r2, r2, r3
    5034:	4613      	mov	r3, r2
    5036:	005b      	lsls	r3, r3, #1
    5038:	4413      	add	r3, r2
    503a:	3302      	adds	r3, #2
    503c:	f507 6237 	add.w	r2, r7, #2928	@ 0xb70
    5040:	f6a2 3268 	subw	r2, r2, #2920	@ 0xb68
    5044:	6812      	ldr	r2, [r2, #0]
    5046:	4413      	add	r3, r2
    5048:	681b      	ldr	r3, [r3, #0]
    504a:	f8c7 3b64 	str.w	r3, [r7, #2916]	@ 0xb64
					if ( (DMMappings.Mappings[i].ControllerBoardIndex >= DMMaxControllerBoards) || (DMMappings.Mappings[i].ControllerBoardIndex >= DMMaxControllerBoards) || (DMMappings.Mappings[i].ControllerBoardIndex >= DMMaxControllerBoards) )
    504e:	4986      	ldr	r1, [pc, #536]	@ (5268 <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x354>)
    5050:	f8d7 2b6c 	ldr.w	r2, [r7, #2924]	@ 0xb6c
    5054:	4613      	mov	r3, r2
    5056:	005b      	lsls	r3, r3, #1
    5058:	4413      	add	r3, r2
    505a:	440b      	add	r3, r1
    505c:	781b      	ldrb	r3, [r3, #0]
    505e:	2b05      	cmp	r3, #5
    5060:	d813      	bhi.n	508a <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x176>
    5062:	4981      	ldr	r1, [pc, #516]	@ (5268 <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x354>)
    5064:	f8d7 2b6c 	ldr.w	r2, [r7, #2924]	@ 0xb6c
    5068:	4613      	mov	r3, r2
    506a:	005b      	lsls	r3, r3, #1
    506c:	4413      	add	r3, r2
    506e:	440b      	add	r3, r1
    5070:	781b      	ldrb	r3, [r3, #0]
    5072:	2b05      	cmp	r3, #5
    5074:	d809      	bhi.n	508a <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x176>
    5076:	497c      	ldr	r1, [pc, #496]	@ (5268 <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x354>)
    5078:	f8d7 2b6c 	ldr.w	r2, [r7, #2924]	@ 0xb6c
    507c:	4613      	mov	r3, r2
    507e:	005b      	lsls	r3, r3, #1
    5080:	4413      	add	r3, r2
    5082:	440b      	add	r3, r1
    5084:	781b      	ldrb	r3, [r3, #0]
    5086:	2b05      	cmp	r3, #5
    5088:	d912      	bls.n	50b0 <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x19c>
						printf("\nBinaryDMLongPixelsCommand: Invalid mapping %lu; please reinitialize mappings!: ", (unsigned long)i);
    508a:	f8d7 1b6c 	ldr.w	r1, [r7, #2924]	@ 0xb6c
    508e:	4877      	ldr	r0, [pc, #476]	@ (526c <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x358>)
    5090:	f001 ff4c 	bl	6f2c <iprintf>
						DMMappings.Mappings[i].formatf();
    5094:	f8d7 2b6c 	ldr.w	r2, [r7, #2924]	@ 0xb6c
    5098:	4613      	mov	r3, r2
    509a:	005b      	lsls	r3, r3, #1
    509c:	4413      	add	r3, r2
    509e:	4a72      	ldr	r2, [pc, #456]	@ (5268 <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x354>)
    50a0:	4413      	add	r3, r2
    50a2:	4618      	mov	r0, r3
    50a4:	f7fe f840 	bl	3128 <CGraphDMMappingPayload::formatf() const>
						printf("\n\n");
    50a8:	4871      	ldr	r0, [pc, #452]	@ (5270 <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x35c>)
    50aa:	f001 ffe3 	bl	7074 <puts>
    50ae:	e036      	b.n	511e <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x20a>
						dRAM->DacSetpoints[DMMappings.Mappings[i].ControllerBoardIndex][DMMappings.Mappings[i].DacIndex][DMMappings.Mappings[i].DacChannel] = DacVal & 0x00FFFFFF; //mask off the byte we picked up from the last pixel since there's no concept of a "uint24_t"
    50b0:	4b70      	ldr	r3, [pc, #448]	@ (5274 <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x360>)
    50b2:	6819      	ldr	r1, [r3, #0]
    50b4:	486c      	ldr	r0, [pc, #432]	@ (5268 <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x354>)
    50b6:	f8d7 2b6c 	ldr.w	r2, [r7, #2924]	@ 0xb6c
    50ba:	4613      	mov	r3, r2
    50bc:	005b      	lsls	r3, r3, #1
    50be:	4413      	add	r3, r2
    50c0:	4403      	add	r3, r0
    50c2:	781b      	ldrb	r3, [r3, #0]
    50c4:	461c      	mov	r4, r3
    50c6:	4868      	ldr	r0, [pc, #416]	@ (5268 <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x354>)
    50c8:	f8d7 2b6c 	ldr.w	r2, [r7, #2924]	@ 0xb6c
    50cc:	4613      	mov	r3, r2
    50ce:	005b      	lsls	r3, r3, #1
    50d0:	4413      	add	r3, r2
    50d2:	4403      	add	r3, r0
    50d4:	3301      	adds	r3, #1
    50d6:	781b      	ldrb	r3, [r3, #0]
    50d8:	461d      	mov	r5, r3
    50da:	4863      	ldr	r0, [pc, #396]	@ (5268 <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x354>)
    50dc:	f8d7 2b6c 	ldr.w	r2, [r7, #2924]	@ 0xb6c
    50e0:	4613      	mov	r3, r2
    50e2:	005b      	lsls	r3, r3, #1
    50e4:	4413      	add	r3, r2
    50e6:	4403      	add	r3, r0
    50e8:	3302      	adds	r3, #2
    50ea:	781b      	ldrb	r3, [r3, #0]
    50ec:	461e      	mov	r6, r3
    50ee:	f8d7 3b64 	ldr.w	r3, [r7, #2916]	@ 0xb64
    50f2:	f023 407f 	bic.w	r0, r3, #4278190080	@ 0xff000000
    50f6:	462a      	mov	r2, r5
    50f8:	0092      	lsls	r2, r2, #2
    50fa:	442a      	add	r2, r5
    50fc:	00d3      	lsls	r3, r2, #3
    50fe:	461a      	mov	r2, r3
    5100:	4623      	mov	r3, r4
    5102:	009b      	lsls	r3, r3, #2
    5104:	4423      	add	r3, r4
    5106:	015b      	lsls	r3, r3, #5
    5108:	4413      	add	r3, r2
    510a:	4433      	add	r3, r6
    510c:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
						printf("\nBinaryDMLongPixelsCommand: Set actuator %lu to %lu", (unsigned long)i, (unsigned long)DacVal);
    5110:	f8d7 2b64 	ldr.w	r2, [r7, #2916]	@ 0xb64
    5114:	f8d7 1b6c 	ldr.w	r1, [r7, #2924]	@ 0xb6c
    5118:	4857      	ldr	r0, [pc, #348]	@ (5278 <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x364>)
    511a:	f001 ff07 	bl	6f2c <iprintf>
				for (size_t i = StartPixel; i < (StartPixel + NumPixels); i++)
    511e:	f8d7 3b6c 	ldr.w	r3, [r7, #2924]	@ 0xb6c
    5122:	3301      	adds	r3, #1
    5124:	f8c7 3b6c 	str.w	r3, [r7, #2924]	@ 0xb6c
    5128:	f8d7 2b58 	ldr.w	r2, [r7, #2904]	@ 0xb58
    512c:	f8d7 3b54 	ldr.w	r3, [r7, #2900]	@ 0xb54
    5130:	4413      	add	r3, r2
    5132:	f8d7 2b6c 	ldr.w	r2, [r7, #2924]	@ 0xb6c
    5136:	429a      	cmp	r2, r3
    5138:	f4ff af77 	bcc.w	502a <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x116>
				TxBinaryPacket(Argument, CGraphPayloadTypeDMLongPixels, 0, &NumPixels, sizeof(uint16_t));
    513c:	f607 3354 	addw	r3, r7, #2900	@ 0xb54
    5140:	f507 6237 	add.w	r2, r7, #2928	@ 0xb70
    5144:	f5a2 6037 	sub.w	r0, r2, #2928	@ 0xb70
    5148:	2202      	movs	r2, #2
    514a:	9200      	str	r2, [sp, #0]
    514c:	2200      	movs	r2, #0
    514e:	f243 010e 	movw	r1, #12302	@ 0x300e
    5152:	6800      	ldr	r0, [r0, #0]
    5154:	f7fe f85c 	bl	3210 <TxBinaryPacket(void const*, unsigned short, unsigned long, void const*, unsigned int)>
	}
    5158:	e071      	b.n	523e <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x32a>
				printf("\nBinaryDMMappingCommand: Long packet: %u (exptected >%u bytes): ", ParamsLen, (sizeof(CGraphDMPixelPayloadHeader)));
    515a:	f507 6337 	add.w	r3, r7, #2928	@ 0xb70
    515e:	f6a3 336c 	subw	r3, r3, #2924	@ 0xb6c
    5162:	2202      	movs	r2, #2
    5164:	6819      	ldr	r1, [r3, #0]
    5166:	4845      	ldr	r0, [pc, #276]	@ (527c <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x368>)
    5168:	f001 fee0 	bl	6f2c <iprintf>
				TxBinaryPacket(Argument, CGraphPayloadTypeDMLongPixels, 0, &StartPixel, sizeof(uint16_t));
    516c:	f607 3358 	addw	r3, r7, #2904	@ 0xb58
    5170:	f507 6237 	add.w	r2, r7, #2928	@ 0xb70
    5174:	f5a2 6037 	sub.w	r0, r2, #2928	@ 0xb70
    5178:	2202      	movs	r2, #2
    517a:	9200      	str	r2, [sp, #0]
    517c:	2200      	movs	r2, #0
    517e:	f243 010e 	movw	r1, #12302	@ 0x300e
    5182:	6800      	ldr	r0, [r0, #0]
    5184:	f7fe f844 	bl	3210 <TxBinaryPacket(void const*, unsigned short, unsigned long, void const*, unsigned int)>
	}
    5188:	e059      	b.n	523e <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x32a>
	//empty packet? query.
	else
	{
		//Not sure what to do besides send back the whole entire block!
		uint8_t Buffer[(DMMaxActuators * 3 * sizeof(uint8_t)) + sizeof(CGraphDMPixelPayloadHeader)];
		uint16_t StartPix = 0;
    518a:	2300      	movs	r3, #0
    518c:	f8a7 3b52 	strh.w	r3, [r7, #2898]	@ 0xb52
		memcpy(Buffer, &StartPix, sizeof(CGraphDMPixelPayloadHeader));
    5190:	f8b7 2b52 	ldrh.w	r2, [r7, #2898]	@ 0xb52
    5194:	f507 6337 	add.w	r3, r7, #2928	@ 0xb70
    5198:	f5a3 6336 	sub.w	r3, r3, #2912	@ 0xb60
    519c:	801a      	strh	r2, [r3, #0]
		for (size_t j = 0; j < DMMaxActuators; j++)
    519e:	2300      	movs	r3, #0
    51a0:	f8c7 3b68 	str.w	r3, [r7, #2920]	@ 0xb68
    51a4:	e037      	b.n	5216 <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x302>
		{
			uint8_t* Pixel = reinterpret_cast<uint8_t*>(Buffer+sizeof(CGraphDMPixelPayloadHeader)+(j*3*sizeof(uint8_t)));
    51a6:	f8d7 2b68 	ldr.w	r2, [r7, #2920]	@ 0xb68
    51aa:	4613      	mov	r3, r2
    51ac:	005b      	lsls	r3, r3, #1
    51ae:	4413      	add	r3, r2
    51b0:	3302      	adds	r3, #2
    51b2:	f107 0210 	add.w	r2, r7, #16
    51b6:	4413      	add	r3, r2
    51b8:	f8c7 3b60 	str.w	r3, [r7, #2912]	@ 0xb60
			Pixel[0] = (uint8_t)(reinterpret_cast<uint32_t*>(dRAM->DacSetpoints)[j] & 0x000000FFUL);
    51bc:	4b2d      	ldr	r3, [pc, #180]	@ (5274 <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x360>)
    51be:	681b      	ldr	r3, [r3, #0]
    51c0:	461a      	mov	r2, r3
    51c2:	f8d7 3b68 	ldr.w	r3, [r7, #2920]	@ 0xb68
    51c6:	009b      	lsls	r3, r3, #2
    51c8:	4413      	add	r3, r2
    51ca:	681b      	ldr	r3, [r3, #0]
    51cc:	b2da      	uxtb	r2, r3
    51ce:	f8d7 3b60 	ldr.w	r3, [r7, #2912]	@ 0xb60
    51d2:	701a      	strb	r2, [r3, #0]
			Pixel[1] = (uint8_t)((reinterpret_cast<uint32_t*>(dRAM->DacSetpoints)[j] & 0x0000FF00UL) >> 8);
    51d4:	4b27      	ldr	r3, [pc, #156]	@ (5274 <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x360>)
    51d6:	681b      	ldr	r3, [r3, #0]
    51d8:	461a      	mov	r2, r3
    51da:	f8d7 3b68 	ldr.w	r3, [r7, #2920]	@ 0xb68
    51de:	009b      	lsls	r3, r3, #2
    51e0:	4413      	add	r3, r2
    51e2:	681b      	ldr	r3, [r3, #0]
    51e4:	0a1a      	lsrs	r2, r3, #8
    51e6:	f8d7 3b60 	ldr.w	r3, [r7, #2912]	@ 0xb60
    51ea:	3301      	adds	r3, #1
    51ec:	b2d2      	uxtb	r2, r2
    51ee:	701a      	strb	r2, [r3, #0]
			Pixel[2] = (uint8_t)((reinterpret_cast<uint32_t*>(dRAM->DacSetpoints)[j] & 0x00FF0000UL) >> 16);
    51f0:	4b20      	ldr	r3, [pc, #128]	@ (5274 <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x360>)
    51f2:	681b      	ldr	r3, [r3, #0]
    51f4:	461a      	mov	r2, r3
    51f6:	f8d7 3b68 	ldr.w	r3, [r7, #2920]	@ 0xb68
    51fa:	009b      	lsls	r3, r3, #2
    51fc:	4413      	add	r3, r2
    51fe:	681b      	ldr	r3, [r3, #0]
    5200:	0c1a      	lsrs	r2, r3, #16
    5202:	f8d7 3b60 	ldr.w	r3, [r7, #2912]	@ 0xb60
    5206:	3302      	adds	r3, #2
    5208:	b2d2      	uxtb	r2, r2
    520a:	701a      	strb	r2, [r3, #0]
		for (size_t j = 0; j < DMMaxActuators; j++)
    520c:	f8d7 3b68 	ldr.w	r3, [r7, #2920]	@ 0xb68
    5210:	3301      	adds	r3, #1
    5212:	f8c7 3b68 	str.w	r3, [r7, #2920]	@ 0xb68
    5216:	f8d7 3b68 	ldr.w	r3, [r7, #2920]	@ 0xb68
    521a:	f5b3 7f70 	cmp.w	r3, #960	@ 0x3c0
    521e:	d3c2      	bcc.n	51a6 <BinaryDMLongPixelsCommand(unsigned long, char const*, unsigned int, void const*)+0x292>
		}
		TxBinaryPacket(Argument, CGraphPayloadTypeDMLongPixels, 0, Buffer, sizeof(CGraphDMPixelPayloadHeader) + (sizeof(uint8_t) * 3 * DMMaxControllerBoards * DMMDacsPerControllerBoard * DMActuatorsPerDac));
    5220:	f107 0310 	add.w	r3, r7, #16
    5224:	f507 6237 	add.w	r2, r7, #2928	@ 0xb70
    5228:	f5a2 6037 	sub.w	r0, r2, #2928	@ 0xb70
    522c:	f640 3242 	movw	r2, #2882	@ 0xb42
    5230:	9200      	str	r2, [sp, #0]
    5232:	2200      	movs	r2, #0
    5234:	f243 010e 	movw	r1, #12302	@ 0x300e
    5238:	6800      	ldr	r0, [r0, #0]
    523a:	f7fd ffe9 	bl	3210 <TxBinaryPacket(void const*, unsigned short, unsigned long, void const*, unsigned int)>
	}
		
    return(ParamsLen);
    523e:	f507 6337 	add.w	r3, r7, #2928	@ 0xb70
    5242:	f6a3 336c 	subw	r3, r3, #2924	@ 0xb6c
    5246:	681b      	ldr	r3, [r3, #0]
    5248:	b25b      	sxtb	r3, r3
}
    524a:	4618      	mov	r0, r3
    524c:	f607 3774 	addw	r7, r7, #2932	@ 0xb74
    5250:	46bd      	mov	sp, r7
    5252:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5254:	2000003c 	.word	0x2000003c
    5258:	0000b0b4 	.word	0x0000b0b4
    525c:	0000b0f8 	.word	0x0000b0f8
    5260:	aaaaaaab 	.word	0xaaaaaaab
    5264:	0000b130 	.word	0x0000b130
    5268:	200009e0 	.word	0x200009e0
    526c:	0000b170 	.word	0x0000b170
    5270:	0000ab88 	.word	0x0000ab88
    5274:	20000040 	.word	0x20000040
    5278:	0000b1c4 	.word	0x0000b1c4
    527c:	0000b1f8 	.word	0x0000b1f8

00005280 <__gnu_cxx::__enable_if<std::__is_integer<int>::__value, double>::__type std::floor<int>(int)>:

  template<typename _Tp>
    inline _GLIBCXX_CONSTEXPR
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    5280:	b580      	push	{r7, lr}
    5282:	b082      	sub	sp, #8
    5284:	af00      	add	r7, sp, #0
    5286:	6078      	str	r0, [r7, #4]
    { return __builtin_floor(__x); }
    5288:	6878      	ldr	r0, [r7, #4]
    528a:	f003 fb77 	bl	897c <__aeabi_i2d>
    528e:	4602      	mov	r2, r0
    5290:	460b      	mov	r3, r1
    5292:	4610      	mov	r0, r2
    5294:	4619      	mov	r1, r3
    5296:	3708      	adds	r7, #8
    5298:	46bd      	mov	sp, r7
    529a:	bd80      	pop	{r7, pc}

0000529c <__static_initialization_and_destruction_0()>:
    529c:	b580      	push	{r7, lr}
    529e:	af00      	add	r7, sp, #0
CGraphDMMappings DMMappings;
    52a0:	4802      	ldr	r0, [pc, #8]	@ (52ac <__static_initialization_and_destruction_0()+0x10>)
    52a2:	f7ff f867 	bl	4374 <CGraphDMMappings::CGraphDMMappings()>
}
    52a6:	bf00      	nop
    52a8:	bd80      	pop	{r7, pc}
    52aa:	bf00      	nop
    52ac:	200009e0 	.word	0x200009e0

000052b0 <_GLOBAL__sub_I_DACaddr>:
    52b0:	b580      	push	{r7, lr}
    52b2:	af00      	add	r7, sp, #0
    52b4:	f7ff fff2 	bl	529c <__static_initialization_and_destruction_0()>
    52b8:	bd80      	pop	{r7, pc}

000052ba <stdout_func>:
	
	extern int stdio_hook_putc(int ch);

	//dump the chars to the display
	static void * stdout_func(void* unused, const char* buf, size_t n )
	{
    52ba:	b580      	push	{r7, lr}
    52bc:	b086      	sub	sp, #24
    52be:	af00      	add	r7, sp, #0
    52c0:	60f8      	str	r0, [r7, #12]
    52c2:	60b9      	str	r1, [r7, #8]
    52c4:	607a      	str	r2, [r7, #4]
		if (NULL == buf) { return(NULL); }
    52c6:	68bb      	ldr	r3, [r7, #8]
    52c8:	2b00      	cmp	r3, #0
    52ca:	d101      	bne.n	52d0 <stdout_func+0x16>
    52cc:	2300      	movs	r3, #0
    52ce:	e012      	b.n	52f6 <stdout_func+0x3c>
		
		for (size_t i = 0; i < n; i++) 
    52d0:	2300      	movs	r3, #0
    52d2:	617b      	str	r3, [r7, #20]
    52d4:	e00a      	b.n	52ec <stdout_func+0x32>
		{
			stdio_hook_putc(buf[i]);
    52d6:	68ba      	ldr	r2, [r7, #8]
    52d8:	697b      	ldr	r3, [r7, #20]
    52da:	4413      	add	r3, r2
    52dc:	f993 3000 	ldrsb.w	r3, [r3]
    52e0:	4618      	mov	r0, r3
    52e2:	f001 fae1 	bl	68a8 <stdio_hook_putc>
		for (size_t i = 0; i < n; i++) 
    52e6:	697b      	ldr	r3, [r7, #20]
    52e8:	3301      	adds	r3, #1
    52ea:	617b      	str	r3, [r7, #20]
    52ec:	697a      	ldr	r2, [r7, #20]
    52ee:	687b      	ldr	r3, [r7, #4]
    52f0:	429a      	cmp	r2, r3
    52f2:	d3f0      	bcc.n	52d6 <stdout_func+0x1c>
		}

		return((void *)(n));
    52f4:	687b      	ldr	r3, [r7, #4]
	}
    52f6:	4618      	mov	r0, r3
    52f8:	3718      	adds	r7, #24
    52fa:	46bd      	mov	sp, r7
    52fc:	bd80      	pop	{r7, pc}
	...

00005300 <formatf>:
		return((void *)(n));
	}
	
	//printf()
	int formatf(const char *fmt, ... )
	{
    5300:	b40f      	push	{r0, r1, r2, r3}
    5302:	b580      	push	{r7, lr}
    5304:	b082      	sub	sp, #8
    5306:	af00      	add	r7, sp, #0
		va_list arg;
		int done;
		
		va_start (arg, fmt);
    5308:	f107 0314 	add.w	r3, r7, #20
    530c:	603b      	str	r3, [r7, #0]
		done = format(stdout_func, NULL, fmt, arg);
    530e:	683b      	ldr	r3, [r7, #0]
    5310:	693a      	ldr	r2, [r7, #16]
    5312:	2100      	movs	r1, #0
    5314:	4805      	ldr	r0, [pc, #20]	@ (532c <formatf+0x2c>)
    5316:	f7fd fa0d 	bl	2734 <format>
    531a:	6078      	str	r0, [r7, #4]
		va_end (arg);
		
		return done;
    531c:	687b      	ldr	r3, [r7, #4]
	}
    531e:	4618      	mov	r0, r3
    5320:	3708      	adds	r7, #8
    5322:	46bd      	mov	sp, r7
    5324:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
    5328:	b004      	add	sp, #16
    532a:	4770      	bx	lr
    532c:	000052bb 	.word	0x000052bb

00005330 <IPacket::IPacket()>:
#include <stdio.h>

class IPacket
{
public:
	IPacket() { }
    5330:	b480      	push	{r7}
    5332:	b083      	sub	sp, #12
    5334:	af00      	add	r7, sp, #0
    5336:	6078      	str	r0, [r7, #4]
    5338:	4a04      	ldr	r2, [pc, #16]	@ (534c <IPacket::IPacket()+0x1c>)
    533a:	687b      	ldr	r3, [r7, #4]
    533c:	601a      	str	r2, [r3, #0]
    533e:	687b      	ldr	r3, [r7, #4]
    5340:	4618      	mov	r0, r3
    5342:	370c      	adds	r7, #12
    5344:	46bd      	mov	sp, r7
    5346:	bc80      	pop	{r7}
    5348:	4770      	bx	lr
    534a:	bf00      	nop
    534c:	0000b83c 	.word	0x0000b83c

00005350 <IPacket::~IPacket()>:
	virtual ~IPacket() { }
    5350:	b480      	push	{r7}
    5352:	b083      	sub	sp, #12
    5354:	af00      	add	r7, sp, #0
    5356:	6078      	str	r0, [r7, #4]
    5358:	4a04      	ldr	r2, [pc, #16]	@ (536c <IPacket::~IPacket()+0x1c>)
    535a:	687b      	ldr	r3, [r7, #4]
    535c:	601a      	str	r2, [r3, #0]
    535e:	687b      	ldr	r3, [r7, #4]
    5360:	4618      	mov	r0, r3
    5362:	370c      	adds	r7, #12
    5364:	46bd      	mov	sp, r7
    5366:	bc80      	pop	{r7}
    5368:	4770      	bx	lr
    536a:	bf00      	nop
    536c:	0000b83c 	.word	0x0000b83c

00005370 <IPacket::~IPacket()>:
    5370:	b580      	push	{r7, lr}
    5372:	b082      	sub	sp, #8
    5374:	af00      	add	r7, sp, #0
    5376:	6078      	str	r0, [r7, #4]
    5378:	6878      	ldr	r0, [r7, #4]
    537a:	f7ff ffe9 	bl	5350 <IPacket::~IPacket()>
    537e:	2104      	movs	r1, #4
    5380:	6878      	ldr	r0, [r7, #4]
    5382:	f003 ff33 	bl	91ec <operator delete(void*, unsigned int)>
    5386:	687b      	ldr	r3, [r7, #4]
    5388:	4618      	mov	r0, r3
    538a:	3708      	adds	r7, #8
    538c:	46bd      	mov	sp, r7
    538e:	bd80      	pop	{r7, pc}

00005390 <CGraphPacketHeader::CGraphPacketHeader()>:
	CGraphPacketHeader() : PacketStartToken(CGraphMagikPacketStartToken), PayloadType(0), PayloadLen(0) { }
    5390:	b480      	push	{r7}
    5392:	b083      	sub	sp, #12
    5394:	af00      	add	r7, sp, #0
    5396:	6078      	str	r0, [r7, #4]
    5398:	687b      	ldr	r3, [r7, #4]
    539a:	2200      	movs	r2, #0
    539c:	f062 0241 	orn	r2, r2, #65	@ 0x41
    53a0:	701a      	strb	r2, [r3, #0]
    53a2:	2200      	movs	r2, #0
    53a4:	f062 0245 	orn	r2, r2, #69	@ 0x45
    53a8:	705a      	strb	r2, [r3, #1]
    53aa:	2200      	movs	r2, #0
    53ac:	f062 0252 	orn	r2, r2, #82	@ 0x52
    53b0:	709a      	strb	r2, [r3, #2]
    53b2:	2200      	movs	r2, #0
    53b4:	f042 021b 	orr.w	r2, r2, #27
    53b8:	70da      	strb	r2, [r3, #3]
    53ba:	687b      	ldr	r3, [r7, #4]
    53bc:	2200      	movs	r2, #0
    53be:	711a      	strb	r2, [r3, #4]
    53c0:	2200      	movs	r2, #0
    53c2:	715a      	strb	r2, [r3, #5]
    53c4:	687b      	ldr	r3, [r7, #4]
    53c6:	2200      	movs	r2, #0
    53c8:	719a      	strb	r2, [r3, #6]
    53ca:	2200      	movs	r2, #0
    53cc:	71da      	strb	r2, [r3, #7]
    53ce:	687b      	ldr	r3, [r7, #4]
    53d0:	4618      	mov	r0, r3
    53d2:	370c      	adds	r7, #12
    53d4:	46bd      	mov	sp, r7
    53d6:	bc80      	pop	{r7}
    53d8:	4770      	bx	lr
	...

000053dc <CGraphPacketHeader::formatf() const>:
	void formatf() const { ::printf("CGraphPacketHeader: StartToken: 0x%lX, PayloadType: %lu, PayloadLen: %lu", (long)PacketStartToken, (unsigned long)PayloadType, (unsigned long)PayloadLen); }
    53dc:	b580      	push	{r7, lr}
    53de:	b082      	sub	sp, #8
    53e0:	af00      	add	r7, sp, #0
    53e2:	6078      	str	r0, [r7, #4]
    53e4:	687b      	ldr	r3, [r7, #4]
    53e6:	681b      	ldr	r3, [r3, #0]
    53e8:	4619      	mov	r1, r3
    53ea:	687b      	ldr	r3, [r7, #4]
    53ec:	889b      	ldrh	r3, [r3, #4]
    53ee:	b29b      	uxth	r3, r3
    53f0:	461a      	mov	r2, r3
    53f2:	687b      	ldr	r3, [r7, #4]
    53f4:	88db      	ldrh	r3, [r3, #6]
    53f6:	b29b      	uxth	r3, r3
    53f8:	4803      	ldr	r0, [pc, #12]	@ (5408 <CGraphPacketHeader::formatf() const+0x2c>)
    53fa:	f001 fd97 	bl	6f2c <iprintf>
    53fe:	bf00      	nop
    5400:	3708      	adds	r7, #8
    5402:	46bd      	mov	sp, r7
    5404:	bd80      	pop	{r7, pc}
    5406:	bf00      	nop
    5408:	0000b23c 	.word	0x0000b23c

0000540c <CGraphPacket::CGraphPacket()>:
	CGraphPacket() { }
    540c:	b580      	push	{r7, lr}
    540e:	b082      	sub	sp, #8
    5410:	af00      	add	r7, sp, #0
    5412:	6078      	str	r0, [r7, #4]
    5414:	687b      	ldr	r3, [r7, #4]
    5416:	4618      	mov	r0, r3
    5418:	f7ff ff8a 	bl	5330 <IPacket::IPacket()>
    541c:	4a03      	ldr	r2, [pc, #12]	@ (542c <CGraphPacket::CGraphPacket()+0x20>)
    541e:	687b      	ldr	r3, [r7, #4]
    5420:	601a      	str	r2, [r3, #0]
    5422:	687b      	ldr	r3, [r7, #4]
    5424:	4618      	mov	r0, r3
    5426:	3708      	adds	r7, #8
    5428:	46bd      	mov	sp, r7
    542a:	bd80      	pop	{r7, pc}
    542c:	0000b7f8 	.word	0x0000b7f8

00005430 <CGraphPacket::~CGraphPacket()>:
	virtual ~CGraphPacket() { }
    5430:	b580      	push	{r7, lr}
    5432:	b082      	sub	sp, #8
    5434:	af00      	add	r7, sp, #0
    5436:	6078      	str	r0, [r7, #4]
    5438:	4a05      	ldr	r2, [pc, #20]	@ (5450 <CGraphPacket::~CGraphPacket()+0x20>)
    543a:	687b      	ldr	r3, [r7, #4]
    543c:	601a      	str	r2, [r3, #0]
    543e:	687b      	ldr	r3, [r7, #4]
    5440:	4618      	mov	r0, r3
    5442:	f7ff ff85 	bl	5350 <IPacket::~IPacket()>
    5446:	687b      	ldr	r3, [r7, #4]
    5448:	4618      	mov	r0, r3
    544a:	3708      	adds	r7, #8
    544c:	46bd      	mov	sp, r7
    544e:	bd80      	pop	{r7, pc}
    5450:	0000b7f8 	.word	0x0000b7f8

00005454 <CGraphPacket::~CGraphPacket()>:
    5454:	b580      	push	{r7, lr}
    5456:	b082      	sub	sp, #8
    5458:	af00      	add	r7, sp, #0
    545a:	6078      	str	r0, [r7, #4]
    545c:	6878      	ldr	r0, [r7, #4]
    545e:	f7ff ffe7 	bl	5430 <CGraphPacket::~CGraphPacket()>
    5462:	2104      	movs	r1, #4
    5464:	6878      	ldr	r0, [r7, #4]
    5466:	f003 fec1 	bl	91ec <operator delete(void*, unsigned int)>
    546a:	687b      	ldr	r3, [r7, #4]
    546c:	4618      	mov	r0, r3
    546e:	3708      	adds	r7, #8
    5470:	46bd      	mov	sp, r7
    5472:	bd80      	pop	{r7, pc}

00005474 <CGraphPacket::FindPacketStart(unsigned char const*, unsigned int, unsigned int&) const>:
	virtual bool FindPacketStart(const uint8_t* Buffer, const size_t BufferLen, size_t& Offset) const override
    5474:	b480      	push	{r7}
    5476:	b087      	sub	sp, #28
    5478:	af00      	add	r7, sp, #0
    547a:	60f8      	str	r0, [r7, #12]
    547c:	60b9      	str	r1, [r7, #8]
    547e:	607a      	str	r2, [r7, #4]
    5480:	603b      	str	r3, [r7, #0]
		for (size_t i = 0; i < (BufferLen - sizeof(uint32_t)); i++) { if (CGraphMagikPacketStartToken == *((const uint32_t*)&(Buffer[i]))) { Offset = i; return(true); } }
    5482:	2300      	movs	r3, #0
    5484:	617b      	str	r3, [r7, #20]
    5486:	e00e      	b.n	54a6 <CGraphPacket::FindPacketStart(unsigned char const*, unsigned int, unsigned int&) const+0x32>
    5488:	68ba      	ldr	r2, [r7, #8]
    548a:	697b      	ldr	r3, [r7, #20]
    548c:	4413      	add	r3, r2
    548e:	681b      	ldr	r3, [r3, #0]
    5490:	4a0a      	ldr	r2, [pc, #40]	@ (54bc <CGraphPacket::FindPacketStart(unsigned char const*, unsigned int, unsigned int&) const+0x48>)
    5492:	4293      	cmp	r3, r2
    5494:	d104      	bne.n	54a0 <CGraphPacket::FindPacketStart(unsigned char const*, unsigned int, unsigned int&) const+0x2c>
    5496:	683b      	ldr	r3, [r7, #0]
    5498:	697a      	ldr	r2, [r7, #20]
    549a:	601a      	str	r2, [r3, #0]
    549c:	2301      	movs	r3, #1
    549e:	e008      	b.n	54b2 <CGraphPacket::FindPacketStart(unsigned char const*, unsigned int, unsigned int&) const+0x3e>
    54a0:	697b      	ldr	r3, [r7, #20]
    54a2:	3301      	adds	r3, #1
    54a4:	617b      	str	r3, [r7, #20]
    54a6:	687b      	ldr	r3, [r7, #4]
    54a8:	3b04      	subs	r3, #4
    54aa:	697a      	ldr	r2, [r7, #20]
    54ac:	429a      	cmp	r2, r3
    54ae:	d3eb      	bcc.n	5488 <CGraphPacket::FindPacketStart(unsigned char const*, unsigned int, unsigned int&) const+0x14>
		return(false);
    54b0:	2300      	movs	r3, #0
	}
    54b2:	4618      	mov	r0, r3
    54b4:	371c      	adds	r7, #28
    54b6:	46bd      	mov	sp, r7
    54b8:	bc80      	pop	{r7}
    54ba:	4770      	bx	lr
    54bc:	1badbabe 	.word	0x1badbabe

000054c0 <CGraphPacket::FindPacketEnd(unsigned char const*, unsigned int, unsigned int&) const>:
        virtual bool FindPacketEnd(const uint8_t* Buffer, const size_t BufferLen, size_t& Offset) const override
    54c0:	b480      	push	{r7}
    54c2:	b087      	sub	sp, #28
    54c4:	af00      	add	r7, sp, #0
    54c6:	60f8      	str	r0, [r7, #12]
    54c8:	60b9      	str	r1, [r7, #8]
    54ca:	607a      	str	r2, [r7, #4]
    54cc:	603b      	str	r3, [r7, #0]
          size_t ii = (BufferLen - sizeof(uint32_t));
    54ce:	687b      	ldr	r3, [r7, #4]
    54d0:	3b04      	subs	r3, #4
    54d2:	617b      	str	r3, [r7, #20]
          if (CGraphMagikPacketEndToken == *((const uint32_t*)&(Buffer[ii]))) { Offset = ii; return(true); }
    54d4:	68ba      	ldr	r2, [r7, #8]
    54d6:	697b      	ldr	r3, [r7, #20]
    54d8:	4413      	add	r3, r2
    54da:	681b      	ldr	r3, [r3, #0]
    54dc:	4a06      	ldr	r2, [pc, #24]	@ (54f8 <CGraphPacket::FindPacketEnd(unsigned char const*, unsigned int, unsigned int&) const+0x38>)
    54de:	4293      	cmp	r3, r2
    54e0:	d104      	bne.n	54ec <CGraphPacket::FindPacketEnd(unsigned char const*, unsigned int, unsigned int&) const+0x2c>
    54e2:	683b      	ldr	r3, [r7, #0]
    54e4:	697a      	ldr	r2, [r7, #20]
    54e6:	601a      	str	r2, [r3, #0]
    54e8:	2301      	movs	r3, #1
    54ea:	e000      	b.n	54ee <CGraphPacket::FindPacketEnd(unsigned char const*, unsigned int, unsigned int&) const+0x2e>
          return(false);
    54ec:	2300      	movs	r3, #0
	}
    54ee:	4618      	mov	r0, r3
    54f0:	371c      	adds	r7, #28
    54f2:	46bd      	mov	sp, r7
    54f4:	bc80      	pop	{r7}
    54f6:	4770      	bx	lr
    54f8:	0a0faded 	.word	0x0a0faded

000054fc <CGraphPacket::HeaderLen() const>:
	virtual size_t HeaderLen() const override { return(sizeof(CGraphPacketHeader)); }
    54fc:	b480      	push	{r7}
    54fe:	b083      	sub	sp, #12
    5500:	af00      	add	r7, sp, #0
    5502:	6078      	str	r0, [r7, #4]
    5504:	2308      	movs	r3, #8
    5506:	4618      	mov	r0, r3
    5508:	370c      	adds	r7, #12
    550a:	46bd      	mov	sp, r7
    550c:	bc80      	pop	{r7}
    550e:	4770      	bx	lr

00005510 <CGraphPacket::FooterLen() const>:
	virtual size_t FooterLen() const override { return(sizeof(CGraphPacketHeader)); }
    5510:	b480      	push	{r7}
    5512:	b083      	sub	sp, #12
    5514:	af00      	add	r7, sp, #0
    5516:	6078      	str	r0, [r7, #4]
    5518:	2308      	movs	r3, #8
    551a:	4618      	mov	r0, r3
    551c:	370c      	adds	r7, #12
    551e:	46bd      	mov	sp, r7
    5520:	bc80      	pop	{r7}
    5522:	4770      	bx	lr

00005524 <CGraphPacket::PayloadOffset() const>:
	virtual size_t PayloadOffset() const override { return(sizeof(CGraphPacketHeader)); }
    5524:	b480      	push	{r7}
    5526:	b083      	sub	sp, #12
    5528:	af00      	add	r7, sp, #0
    552a:	6078      	str	r0, [r7, #4]
    552c:	2308      	movs	r3, #8
    552e:	4618      	mov	r0, r3
    5530:	370c      	adds	r7, #12
    5532:	46bd      	mov	sp, r7
    5534:	bc80      	pop	{r7}
    5536:	4770      	bx	lr

00005538 <CGraphPacket::MaxPayloadLength() const>:
	virtual size_t MaxPayloadLength() const override { return(0xFFFFU); }
    5538:	b480      	push	{r7}
    553a:	b083      	sub	sp, #12
    553c:	af00      	add	r7, sp, #0
    553e:	6078      	str	r0, [r7, #4]
    5540:	f64f 73ff 	movw	r3, #65535	@ 0xffff
    5544:	4618      	mov	r0, r3
    5546:	370c      	adds	r7, #12
    5548:	46bd      	mov	sp, r7
    554a:	bc80      	pop	{r7}
    554c:	4770      	bx	lr

0000554e <CGraphPacket::IsBroadcastSerialNum(unsigned char const*, unsigned int, unsigned int) const>:
	virtual bool IsBroadcastSerialNum(const uint8_t* Buffer, const size_t PacketStartPos, const size_t PacketEndPos) const override { return(false); }
    554e:	b480      	push	{r7}
    5550:	b085      	sub	sp, #20
    5552:	af00      	add	r7, sp, #0
    5554:	60f8      	str	r0, [r7, #12]
    5556:	60b9      	str	r1, [r7, #8]
    5558:	607a      	str	r2, [r7, #4]
    555a:	603b      	str	r3, [r7, #0]
    555c:	2300      	movs	r3, #0
    555e:	4618      	mov	r0, r3
    5560:	3714      	adds	r7, #20
    5562:	46bd      	mov	sp, r7
    5564:	bc80      	pop	{r7}
    5566:	4770      	bx	lr

00005568 <CGraphPacket::SerialNum(unsigned char const*, unsigned int, unsigned int) const>:
	virtual uint64_t SerialNum(const uint8_t* Buffer, const size_t PacketStartPos, const size_t PacketEndPos) const override { return(0); }
    5568:	b480      	push	{r7}
    556a:	b085      	sub	sp, #20
    556c:	af00      	add	r7, sp, #0
    556e:	60f8      	str	r0, [r7, #12]
    5570:	60b9      	str	r1, [r7, #8]
    5572:	607a      	str	r2, [r7, #4]
    5574:	603b      	str	r3, [r7, #0]
    5576:	f04f 0200 	mov.w	r2, #0
    557a:	f04f 0300 	mov.w	r3, #0
    557e:	4610      	mov	r0, r2
    5580:	4619      	mov	r1, r3
    5582:	3714      	adds	r7, #20
    5584:	46bd      	mov	sp, r7
    5586:	bc80      	pop	{r7}
    5588:	4770      	bx	lr

0000558a <CGraphPacket::PayloadLen(unsigned char const*, unsigned int, unsigned int) const>:
	virtual size_t PayloadLen(const uint8_t* Buffer, const size_t BufferCount, const size_t PacketStartPos) const override
    558a:	b480      	push	{r7}
    558c:	b087      	sub	sp, #28
    558e:	af00      	add	r7, sp, #0
    5590:	60f8      	str	r0, [r7, #12]
    5592:	60b9      	str	r1, [r7, #8]
    5594:	607a      	str	r2, [r7, #4]
    5596:	603b      	str	r3, [r7, #0]
		if ((PacketStartPos + sizeof(CGraphPacketHeader)) > BufferCount) { return(0); }
    5598:	683b      	ldr	r3, [r7, #0]
    559a:	3308      	adds	r3, #8
    559c:	687a      	ldr	r2, [r7, #4]
    559e:	429a      	cmp	r2, r3
    55a0:	d201      	bcs.n	55a6 <CGraphPacket::PayloadLen(unsigned char const*, unsigned int, unsigned int) const+0x1c>
    55a2:	2300      	movs	r3, #0
    55a4:	e006      	b.n	55b4 <CGraphPacket::PayloadLen(unsigned char const*, unsigned int, unsigned int) const+0x2a>
		const CGraphPacketHeader* Packet = reinterpret_cast<const CGraphPacketHeader*>(&(Buffer[PacketStartPos]));
    55a6:	68ba      	ldr	r2, [r7, #8]
    55a8:	683b      	ldr	r3, [r7, #0]
    55aa:	4413      	add	r3, r2
    55ac:	617b      	str	r3, [r7, #20]
		return(Packet->PayloadLen);
    55ae:	697b      	ldr	r3, [r7, #20]
    55b0:	88db      	ldrh	r3, [r3, #6]
    55b2:	b29b      	uxth	r3, r3
	}
    55b4:	4618      	mov	r0, r3
    55b6:	371c      	adds	r7, #28
    55b8:	46bd      	mov	sp, r7
    55ba:	bc80      	pop	{r7}
    55bc:	4770      	bx	lr

000055be <CGraphPacket::PayloadType(unsigned char const*, unsigned int, unsigned int) const>:
	virtual uint64_t PayloadType(const uint8_t* Buffer, const size_t BufferCount, const size_t PacketStartPos) const override
    55be:	b4b0      	push	{r4, r5, r7}
    55c0:	b087      	sub	sp, #28
    55c2:	af00      	add	r7, sp, #0
    55c4:	60f8      	str	r0, [r7, #12]
    55c6:	60b9      	str	r1, [r7, #8]
    55c8:	607a      	str	r2, [r7, #4]
    55ca:	603b      	str	r3, [r7, #0]
		if ((PacketStartPos + sizeof(CGraphPacketHeader)) > BufferCount) { return(0); }
    55cc:	683b      	ldr	r3, [r7, #0]
    55ce:	3308      	adds	r3, #8
    55d0:	687a      	ldr	r2, [r7, #4]
    55d2:	429a      	cmp	r2, r3
    55d4:	d204      	bcs.n	55e0 <CGraphPacket::PayloadType(unsigned char const*, unsigned int, unsigned int) const+0x22>
    55d6:	f04f 0400 	mov.w	r4, #0
    55da:	f04f 0500 	mov.w	r5, #0
    55de:	e00a      	b.n	55f6 <CGraphPacket::PayloadType(unsigned char const*, unsigned int, unsigned int) const+0x38>
		const CGraphPacketHeader* Packet = reinterpret_cast<const CGraphPacketHeader*>(&(Buffer[PacketStartPos]));
    55e0:	68ba      	ldr	r2, [r7, #8]
    55e2:	683b      	ldr	r3, [r7, #0]
    55e4:	4413      	add	r3, r2
    55e6:	617b      	str	r3, [r7, #20]
		return(Packet->PayloadType);
    55e8:	697b      	ldr	r3, [r7, #20]
    55ea:	889b      	ldrh	r3, [r3, #4]
    55ec:	b29b      	uxth	r3, r3
    55ee:	b29b      	uxth	r3, r3
    55f0:	2200      	movs	r2, #0
    55f2:	461c      	mov	r4, r3
    55f4:	4615      	mov	r5, r2
	}
    55f6:	4622      	mov	r2, r4
    55f8:	462b      	mov	r3, r5
    55fa:	4610      	mov	r0, r2
    55fc:	4619      	mov	r1, r3
    55fe:	371c      	adds	r7, #28
    5600:	46bd      	mov	sp, r7
    5602:	bcb0      	pop	{r4, r5, r7}
    5604:	4770      	bx	lr

00005606 <CGraphPacket::DoesPayloadTypeMatch(unsigned char const*, unsigned int, unsigned int, unsigned int, unsigned long) const>:
	virtual bool DoesPayloadTypeMatch(const uint8_t* Buffer, const size_t BufferCount, const size_t PacketStartPos, const size_t PacketEndPos, const uint32_t CmdType) const override
    5606:	b480      	push	{r7}
    5608:	b087      	sub	sp, #28
    560a:	af00      	add	r7, sp, #0
    560c:	60f8      	str	r0, [r7, #12]
    560e:	60b9      	str	r1, [r7, #8]
    5610:	607a      	str	r2, [r7, #4]
    5612:	603b      	str	r3, [r7, #0]
		if ( ((PacketStartPos + sizeof(CGraphPacketHeader)) > BufferCount) ) { return(false); }
    5614:	683b      	ldr	r3, [r7, #0]
    5616:	3308      	adds	r3, #8
    5618:	687a      	ldr	r2, [r7, #4]
    561a:	429a      	cmp	r2, r3
    561c:	d201      	bcs.n	5622 <CGraphPacket::DoesPayloadTypeMatch(unsigned char const*, unsigned int, unsigned int, unsigned int, unsigned long) const+0x1c>
    561e:	2300      	movs	r3, #0
    5620:	e00d      	b.n	563e <CGraphPacket::DoesPayloadTypeMatch(unsigned char const*, unsigned int, unsigned int, unsigned int, unsigned long) const+0x38>
		const CGraphPacketHeader* Packet = reinterpret_cast<const CGraphPacketHeader*>(&(Buffer[PacketStartPos]));
    5622:	68ba      	ldr	r2, [r7, #8]
    5624:	683b      	ldr	r3, [r7, #0]
    5626:	4413      	add	r3, r2
    5628:	617b      	str	r3, [r7, #20]
		if (CmdType == Packet->PayloadType) { return(true); }
    562a:	697b      	ldr	r3, [r7, #20]
    562c:	889b      	ldrh	r3, [r3, #4]
    562e:	b29b      	uxth	r3, r3
    5630:	461a      	mov	r2, r3
    5632:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    5634:	4293      	cmp	r3, r2
    5636:	d101      	bne.n	563c <CGraphPacket::DoesPayloadTypeMatch(unsigned char const*, unsigned int, unsigned int, unsigned int, unsigned long) const+0x36>
    5638:	2301      	movs	r3, #1
    563a:	e000      	b.n	563e <CGraphPacket::DoesPayloadTypeMatch(unsigned char const*, unsigned int, unsigned int, unsigned int, unsigned long) const+0x38>
		return(false);
    563c:	2300      	movs	r3, #0
	}
    563e:	4618      	mov	r0, r3
    5640:	371c      	adds	r7, #28
    5642:	46bd      	mov	sp, r7
    5644:	bc80      	pop	{r7}
    5646:	4770      	bx	lr

00005648 <CGraphPacket::IsValid(unsigned char const*, unsigned int, unsigned int, unsigned int) const>:
	virtual bool IsValid(const uint8_t* Buffer, const size_t BufferCount, const size_t PacketStartPos, const size_t PacketEndPos) const override
    5648:	b580      	push	{r7, lr}
    564a:	b088      	sub	sp, #32
    564c:	af00      	add	r7, sp, #0
    564e:	60f8      	str	r0, [r7, #12]
    5650:	60b9      	str	r1, [r7, #8]
    5652:	607a      	str	r2, [r7, #4]
    5654:	603b      	str	r3, [r7, #0]
		if ((PacketStartPos + sizeof(CGraphPacketHeader) + sizeof(CGraphPacketFooter)) > BufferCount) { return(false); }
    5656:	683b      	ldr	r3, [r7, #0]
    5658:	3310      	adds	r3, #16
    565a:	687a      	ldr	r2, [r7, #4]
    565c:	429a      	cmp	r2, r3
    565e:	d201      	bcs.n	5664 <CGraphPacket::IsValid(unsigned char const*, unsigned int, unsigned int, unsigned int) const+0x1c>
    5660:	2300      	movs	r3, #0
    5662:	e038      	b.n	56d6 <CGraphPacket::IsValid(unsigned char const*, unsigned int, unsigned int, unsigned int) const+0x8e>
		const CGraphPacketHeader* Header = reinterpret_cast<const CGraphPacketHeader*>(&(Buffer[PacketStartPos]));
    5664:	68ba      	ldr	r2, [r7, #8]
    5666:	683b      	ldr	r3, [r7, #0]
    5668:	4413      	add	r3, r2
    566a:	61fb      	str	r3, [r7, #28]
		if ((PacketStartPos + sizeof(CGraphPacketHeader) + Header->PayloadLen + sizeof(CGraphPacketFooter)) > BufferCount) { return(false); }
    566c:	69fb      	ldr	r3, [r7, #28]
    566e:	88db      	ldrh	r3, [r3, #6]
    5670:	b29b      	uxth	r3, r3
    5672:	461a      	mov	r2, r3
    5674:	683b      	ldr	r3, [r7, #0]
    5676:	4413      	add	r3, r2
    5678:	3310      	adds	r3, #16
    567a:	687a      	ldr	r2, [r7, #4]
    567c:	429a      	cmp	r2, r3
    567e:	d201      	bcs.n	5684 <CGraphPacket::IsValid(unsigned char const*, unsigned int, unsigned int, unsigned int) const+0x3c>
    5680:	2300      	movs	r3, #0
    5682:	e028      	b.n	56d6 <CGraphPacket::IsValid(unsigned char const*, unsigned int, unsigned int, unsigned int) const+0x8e>
		if (CGraphMagikPacketStartToken != Header->PacketStartToken) { return(false); }
    5684:	69fb      	ldr	r3, [r7, #28]
    5686:	681b      	ldr	r3, [r3, #0]
    5688:	4a15      	ldr	r2, [pc, #84]	@ (56e0 <CGraphPacket::IsValid(unsigned char const*, unsigned int, unsigned int, unsigned int) const+0x98>)
    568a:	4293      	cmp	r3, r2
    568c:	d001      	beq.n	5692 <CGraphPacket::IsValid(unsigned char const*, unsigned int, unsigned int, unsigned int) const+0x4a>
    568e:	2300      	movs	r3, #0
    5690:	e021      	b.n	56d6 <CGraphPacket::IsValid(unsigned char const*, unsigned int, unsigned int, unsigned int) const+0x8e>
		const CGraphPacketFooter* Footer = reinterpret_cast<const CGraphPacketFooter*>(&(Buffer[PacketStartPos + sizeof(CGraphPacketHeader) + Header->PayloadLen]));
    5692:	69fb      	ldr	r3, [r7, #28]
    5694:	88db      	ldrh	r3, [r3, #6]
    5696:	b29b      	uxth	r3, r3
    5698:	461a      	mov	r2, r3
    569a:	683b      	ldr	r3, [r7, #0]
    569c:	4413      	add	r3, r2
    569e:	3308      	adds	r3, #8
    56a0:	68ba      	ldr	r2, [r7, #8]
    56a2:	4413      	add	r3, r2
    56a4:	61bb      	str	r3, [r7, #24]
		if (CGraphMagikPacketEndToken != Footer->PacketEndToken) { return(false); }
    56a6:	69bb      	ldr	r3, [r7, #24]
    56a8:	685b      	ldr	r3, [r3, #4]
    56aa:	4a0e      	ldr	r2, [pc, #56]	@ (56e4 <CGraphPacket::IsValid(unsigned char const*, unsigned int, unsigned int, unsigned int) const+0x9c>)
    56ac:	4293      	cmp	r3, r2
    56ae:	d001      	beq.n	56b4 <CGraphPacket::IsValid(unsigned char const*, unsigned int, unsigned int, unsigned int) const+0x6c>
    56b0:	2300      	movs	r3, #0
    56b2:	e010      	b.n	56d6 <CGraphPacket::IsValid(unsigned char const*, unsigned int, unsigned int, unsigned int) const+0x8e>
		uint32_t CRC = CRC32BZIP2((const uint8_t*)Header, sizeof(CGraphPacketHeader) + Header->PayloadLen);
    56b4:	69fb      	ldr	r3, [r7, #28]
    56b6:	88db      	ldrh	r3, [r3, #6]
    56b8:	b29b      	uxth	r3, r3
    56ba:	3308      	adds	r3, #8
    56bc:	4619      	mov	r1, r3
    56be:	69f8      	ldr	r0, [r7, #28]
    56c0:	f7fb f844 	bl	74c <CRC32BZIP2>
    56c4:	6178      	str	r0, [r7, #20]
		if (CRC != Footer->CRC32BZIP2) { return(false); }		
    56c6:	69bb      	ldr	r3, [r7, #24]
    56c8:	681b      	ldr	r3, [r3, #0]
    56ca:	697a      	ldr	r2, [r7, #20]
    56cc:	429a      	cmp	r2, r3
    56ce:	d001      	beq.n	56d4 <CGraphPacket::IsValid(unsigned char const*, unsigned int, unsigned int, unsigned int) const+0x8c>
    56d0:	2300      	movs	r3, #0
    56d2:	e000      	b.n	56d6 <CGraphPacket::IsValid(unsigned char const*, unsigned int, unsigned int, unsigned int) const+0x8e>
		return(true);
    56d4:	2301      	movs	r3, #1
	}
    56d6:	4618      	mov	r0, r3
    56d8:	3720      	adds	r7, #32
    56da:	46bd      	mov	sp, r7
    56dc:	bd80      	pop	{r7, pc}
    56de:	bf00      	nop
    56e0:	1badbabe 	.word	0x1badbabe
    56e4:	0a0faded 	.word	0x0a0faded

000056e8 <CGraphPacket::MakePacket(unsigned char*, unsigned int, void const*, unsigned short, unsigned int) const>:
	virtual size_t MakePacket(uint8_t* Buffer, const size_t BufferCount, const void* Payload, const uint16_t PayloadType, const size_t PayloadLen) const override
    56e8:	b580      	push	{r7, lr}
    56ea:	b088      	sub	sp, #32
    56ec:	af00      	add	r7, sp, #0
    56ee:	60f8      	str	r0, [r7, #12]
    56f0:	60b9      	str	r1, [r7, #8]
    56f2:	607a      	str	r2, [r7, #4]
    56f4:	603b      	str	r3, [r7, #0]
		if ( (NULL == Buffer) || ((NULL == Payload) && (0 != PayloadLen)) || (BufferCount < (sizeof(CGraphPacketHeader) + PayloadLen + sizeof(CGraphPacketFooter))) ) { return(0); }
    56f6:	68bb      	ldr	r3, [r7, #8]
    56f8:	2b00      	cmp	r3, #0
    56fa:	d00a      	beq.n	5712 <CGraphPacket::MakePacket(unsigned char*, unsigned int, void const*, unsigned short, unsigned int) const+0x2a>
    56fc:	683b      	ldr	r3, [r7, #0]
    56fe:	2b00      	cmp	r3, #0
    5700:	d102      	bne.n	5708 <CGraphPacket::MakePacket(unsigned char*, unsigned int, void const*, unsigned short, unsigned int) const+0x20>
    5702:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    5704:	2b00      	cmp	r3, #0
    5706:	d104      	bne.n	5712 <CGraphPacket::MakePacket(unsigned char*, unsigned int, void const*, unsigned short, unsigned int) const+0x2a>
    5708:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    570a:	3310      	adds	r3, #16
    570c:	687a      	ldr	r2, [r7, #4]
    570e:	429a      	cmp	r2, r3
    5710:	d201      	bcs.n	5716 <CGraphPacket::MakePacket(unsigned char*, unsigned int, void const*, unsigned short, unsigned int) const+0x2e>
    5712:	2300      	movs	r3, #0
    5714:	e03c      	b.n	5790 <CGraphPacket::MakePacket(unsigned char*, unsigned int, void const*, unsigned short, unsigned int) const+0xa8>
		CGraphPacketHeader Header;
    5716:	f107 0310 	add.w	r3, r7, #16
    571a:	4618      	mov	r0, r3
    571c:	f7ff fe38 	bl	5390 <CGraphPacketHeader::CGraphPacketHeader()>
		Header.PayloadType = PayloadType;
    5720:	8d3b      	ldrh	r3, [r7, #40]	@ 0x28
    5722:	82bb      	strh	r3, [r7, #20]
		Header.PayloadLen = PayloadLen;
    5724:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    5726:	b29b      	uxth	r3, r3
    5728:	82fb      	strh	r3, [r7, #22]
		memcpy(Buffer, &Header, sizeof(CGraphPacketHeader));
    572a:	68bb      	ldr	r3, [r7, #8]
    572c:	461a      	mov	r2, r3
    572e:	f107 0310 	add.w	r3, r7, #16
    5732:	cb03      	ldmia	r3!, {r0, r1}
    5734:	6010      	str	r0, [r2, #0]
    5736:	6051      	str	r1, [r2, #4]
		if (NULL != Payload) { memcpy(&(Buffer[sizeof(CGraphPacketHeader)]), Payload, PayloadLen); }
    5738:	683b      	ldr	r3, [r7, #0]
    573a:	2b00      	cmp	r3, #0
    573c:	d006      	beq.n	574c <CGraphPacket::MakePacket(unsigned char*, unsigned int, void const*, unsigned short, unsigned int) const+0x64>
    573e:	68bb      	ldr	r3, [r7, #8]
    5740:	3308      	adds	r3, #8
    5742:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
    5744:	6839      	ldr	r1, [r7, #0]
    5746:	4618      	mov	r0, r3
    5748:	f001 fe85 	bl	7456 <memcpy>
		CGraphPacketFooter* Footer = reinterpret_cast<CGraphPacketFooter*>(&(Buffer[sizeof(CGraphPacketHeader) + PayloadLen]));
    574c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    574e:	3308      	adds	r3, #8
    5750:	68ba      	ldr	r2, [r7, #8]
    5752:	4413      	add	r3, r2
    5754:	61fb      	str	r3, [r7, #28]
		uint32_t CRC = CRC32BZIP2(Buffer, sizeof(CGraphPacketHeader) + PayloadLen);
    5756:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    5758:	3308      	adds	r3, #8
    575a:	4619      	mov	r1, r3
    575c:	68b8      	ldr	r0, [r7, #8]
    575e:	f7fa fff5 	bl	74c <CRC32BZIP2>
    5762:	61b8      	str	r0, [r7, #24]
		Footer->CRC32BZIP2 = CRC;
    5764:	69fb      	ldr	r3, [r7, #28]
    5766:	69ba      	ldr	r2, [r7, #24]
    5768:	601a      	str	r2, [r3, #0]
		Footer->PacketEndToken = CGraphMagikPacketEndToken;
    576a:	69fb      	ldr	r3, [r7, #28]
    576c:	2200      	movs	r2, #0
    576e:	f062 0212 	orn	r2, r2, #18
    5772:	711a      	strb	r2, [r3, #4]
    5774:	2200      	movs	r2, #0
    5776:	f062 0252 	orn	r2, r2, #82	@ 0x52
    577a:	715a      	strb	r2, [r3, #5]
    577c:	2200      	movs	r2, #0
    577e:	f042 020f 	orr.w	r2, r2, #15
    5782:	719a      	strb	r2, [r3, #6]
    5784:	2200      	movs	r2, #0
    5786:	f042 020a 	orr.w	r2, r2, #10
    578a:	71da      	strb	r2, [r3, #7]
		return(sizeof(CGraphPacketHeader) + PayloadLen + sizeof(CGraphPacketFooter));
    578c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    578e:	3310      	adds	r3, #16
	}
    5790:	4618      	mov	r0, r3
    5792:	3720      	adds	r7, #32
    5794:	46bd      	mov	sp, r7
    5796:	bd80      	pop	{r7, pc}

00005798 <IUart::IUart()>:
#include <stdio.h>

class IUart
{
public:
	IUart() { }
    5798:	b480      	push	{r7}
    579a:	b083      	sub	sp, #12
    579c:	af00      	add	r7, sp, #0
    579e:	6078      	str	r0, [r7, #4]
    57a0:	4a04      	ldr	r2, [pc, #16]	@ (57b4 <IUart::IUart()+0x1c>)
    57a2:	687b      	ldr	r3, [r7, #4]
    57a4:	601a      	str	r2, [r3, #0]
    57a6:	687b      	ldr	r3, [r7, #4]
    57a8:	4618      	mov	r0, r3
    57aa:	370c      	adds	r7, #12
    57ac:	46bd      	mov	sp, r7
    57ae:	bc80      	pop	{r7}
    57b0:	4770      	bx	lr
    57b2:	bf00      	nop
    57b4:	0000b7d0 	.word	0x0000b7d0

000057b8 <IUart::~IUart()>:
	virtual ~IUart() { }
    57b8:	b480      	push	{r7}
    57ba:	b083      	sub	sp, #12
    57bc:	af00      	add	r7, sp, #0
    57be:	6078      	str	r0, [r7, #4]
    57c0:	4a04      	ldr	r2, [pc, #16]	@ (57d4 <IUart::~IUart()+0x1c>)
    57c2:	687b      	ldr	r3, [r7, #4]
    57c4:	601a      	str	r2, [r3, #0]
    57c6:	687b      	ldr	r3, [r7, #4]
    57c8:	4618      	mov	r0, r3
    57ca:	370c      	adds	r7, #12
    57cc:	46bd      	mov	sp, r7
    57ce:	bc80      	pop	{r7}
    57d0:	4770      	bx	lr
    57d2:	bf00      	nop
    57d4:	0000b7d0 	.word	0x0000b7d0

000057d8 <IUart::~IUart()>:
    57d8:	b580      	push	{r7, lr}
    57da:	b082      	sub	sp, #8
    57dc:	af00      	add	r7, sp, #0
    57de:	6078      	str	r0, [r7, #4]
    57e0:	6878      	ldr	r0, [r7, #4]
    57e2:	f7ff ffe9 	bl	57b8 <IUart::~IUart()>
    57e6:	2104      	movs	r1, #4
    57e8:	6878      	ldr	r0, [r7, #4]
    57ea:	f003 fcff 	bl	91ec <operator delete(void*, unsigned int)>
    57ee:	687b      	ldr	r3, [r7, #4]
    57f0:	4618      	mov	r0, r3
    57f2:	3708      	adds	r7, #8
    57f4:	46bd      	mov	sp, r7
    57f6:	bd80      	pop	{r7, pc}

000057f8 <IUartParser::IUartParser(IUart&)>:
#include "uart/IUart.h"

class IUartParser
{
public:
	IUartParser(struct IUart& pinout) : Pinout(pinout) { }
    57f8:	b480      	push	{r7}
    57fa:	b083      	sub	sp, #12
    57fc:	af00      	add	r7, sp, #0
    57fe:	6078      	str	r0, [r7, #4]
    5800:	6039      	str	r1, [r7, #0]
    5802:	4a06      	ldr	r2, [pc, #24]	@ (581c <IUartParser::IUartParser(IUart&)+0x24>)
    5804:	687b      	ldr	r3, [r7, #4]
    5806:	601a      	str	r2, [r3, #0]
    5808:	687b      	ldr	r3, [r7, #4]
    580a:	683a      	ldr	r2, [r7, #0]
    580c:	605a      	str	r2, [r3, #4]
    580e:	687b      	ldr	r3, [r7, #4]
    5810:	4618      	mov	r0, r3
    5812:	370c      	adds	r7, #12
    5814:	46bd      	mov	sp, r7
    5816:	bc80      	pop	{r7}
    5818:	4770      	bx	lr
    581a:	bf00      	nop
    581c:	0000b7bc 	.word	0x0000b7bc

00005820 <IUartParser::~IUartParser()>:
	virtual ~IUartParser() { }
    5820:	b480      	push	{r7}
    5822:	b083      	sub	sp, #12
    5824:	af00      	add	r7, sp, #0
    5826:	6078      	str	r0, [r7, #4]
    5828:	4a04      	ldr	r2, [pc, #16]	@ (583c <IUartParser::~IUartParser()+0x1c>)
    582a:	687b      	ldr	r3, [r7, #4]
    582c:	601a      	str	r2, [r3, #0]
    582e:	687b      	ldr	r3, [r7, #4]
    5830:	4618      	mov	r0, r3
    5832:	370c      	adds	r7, #12
    5834:	46bd      	mov	sp, r7
    5836:	bc80      	pop	{r7}
    5838:	4770      	bx	lr
    583a:	bf00      	nop
    583c:	0000b7bc 	.word	0x0000b7bc

00005840 <IUartParser::~IUartParser()>:
    5840:	b580      	push	{r7, lr}
    5842:	b082      	sub	sp, #8
    5844:	af00      	add	r7, sp, #0
    5846:	6078      	str	r0, [r7, #4]
    5848:	6878      	ldr	r0, [r7, #4]
    584a:	f7ff ffe9 	bl	5820 <IUartParser::~IUartParser()>
    584e:	2108      	movs	r1, #8
    5850:	6878      	ldr	r0, [r7, #4]
    5852:	f003 fccb 	bl	91ec <operator delete(void*, unsigned int)>
    5856:	687b      	ldr	r3, [r7, #4]
    5858:	4618      	mov	r0, r3
    585a:	3708      	adds	r7, #8
    585c:	46bd      	mov	sp, r7
    585e:	bd80      	pop	{r7, pc}

00005860 <BinaryUartCallbacks::BinaryUartCallbacks()>:
	BinaryUartCallbacks() { }
    5860:	b480      	push	{r7}
    5862:	b083      	sub	sp, #12
    5864:	af00      	add	r7, sp, #0
    5866:	6078      	str	r0, [r7, #4]
    5868:	4a04      	ldr	r2, [pc, #16]	@ (587c <BinaryUartCallbacks::BinaryUartCallbacks()+0x1c>)
    586a:	687b      	ldr	r3, [r7, #4]
    586c:	601a      	str	r2, [r3, #0]
    586e:	687b      	ldr	r3, [r7, #4]
    5870:	4618      	mov	r0, r3
    5872:	370c      	adds	r7, #12
    5874:	46bd      	mov	sp, r7
    5876:	bc80      	pop	{r7}
    5878:	4770      	bx	lr
    587a:	bf00      	nop
    587c:	0000b79c 	.word	0x0000b79c

00005880 <BinaryUartCallbacks::~BinaryUartCallbacks()>:
	virtual ~BinaryUartCallbacks() { }
    5880:	b480      	push	{r7}
    5882:	b083      	sub	sp, #12
    5884:	af00      	add	r7, sp, #0
    5886:	6078      	str	r0, [r7, #4]
    5888:	4a04      	ldr	r2, [pc, #16]	@ (589c <BinaryUartCallbacks::~BinaryUartCallbacks()+0x1c>)
    588a:	687b      	ldr	r3, [r7, #4]
    588c:	601a      	str	r2, [r3, #0]
    588e:	687b      	ldr	r3, [r7, #4]
    5890:	4618      	mov	r0, r3
    5892:	370c      	adds	r7, #12
    5894:	46bd      	mov	sp, r7
    5896:	bc80      	pop	{r7}
    5898:	4770      	bx	lr
    589a:	bf00      	nop
    589c:	0000b79c 	.word	0x0000b79c

000058a0 <BinaryUartCallbacks::~BinaryUartCallbacks()>:
    58a0:	b580      	push	{r7, lr}
    58a2:	b082      	sub	sp, #8
    58a4:	af00      	add	r7, sp, #0
    58a6:	6078      	str	r0, [r7, #4]
    58a8:	6878      	ldr	r0, [r7, #4]
    58aa:	f7ff ffe9 	bl	5880 <BinaryUartCallbacks::~BinaryUartCallbacks()>
    58ae:	2104      	movs	r1, #4
    58b0:	6878      	ldr	r0, [r7, #4]
    58b2:	f003 fc9b 	bl	91ec <operator delete(void*, unsigned int)>
    58b6:	687b      	ldr	r3, [r7, #4]
    58b8:	4618      	mov	r0, r3
    58ba:	3708      	adds	r7, #8
    58bc:	46bd      	mov	sp, r7
    58be:	bd80      	pop	{r7, pc}

000058c0 <BinaryUartCallbacks::InvalidPacket(unsigned char const*, unsigned int const&)>:
	virtual void InvalidPacket(const uint8_t* Buffer, const size_t& BufferLen) { }
    58c0:	b480      	push	{r7}
    58c2:	b085      	sub	sp, #20
    58c4:	af00      	add	r7, sp, #0
    58c6:	60f8      	str	r0, [r7, #12]
    58c8:	60b9      	str	r1, [r7, #8]
    58ca:	607a      	str	r2, [r7, #4]
    58cc:	bf00      	nop
    58ce:	3714      	adds	r7, #20
    58d0:	46bd      	mov	sp, r7
    58d2:	bc80      	pop	{r7}
    58d4:	4770      	bx	lr

000058d6 <BinaryUartCallbacks::UnHandledPacket(IPacket const*, unsigned int const&)>:
	virtual void UnHandledPacket(const IPacket* Packet, const size_t& PacketLen) { }
    58d6:	b480      	push	{r7}
    58d8:	b085      	sub	sp, #20
    58da:	af00      	add	r7, sp, #0
    58dc:	60f8      	str	r0, [r7, #12]
    58de:	60b9      	str	r1, [r7, #8]
    58e0:	607a      	str	r2, [r7, #4]
    58e2:	bf00      	nop
    58e4:	3714      	adds	r7, #20
    58e6:	46bd      	mov	sp, r7
    58e8:	bc80      	pop	{r7}
    58ea:	4770      	bx	lr

000058ec <BinaryUartCallbacks::EveryPacket(IPacket const*, unsigned int const&)>:
	virtual void EveryPacket(const IPacket* Packet, const size_t& PacketLen) { }
    58ec:	b480      	push	{r7}
    58ee:	b085      	sub	sp, #20
    58f0:	af00      	add	r7, sp, #0
    58f2:	60f8      	str	r0, [r7, #12]
    58f4:	60b9      	str	r1, [r7, #8]
    58f6:	607a      	str	r2, [r7, #4]
    58f8:	bf00      	nop
    58fa:	3714      	adds	r7, #20
    58fc:	46bd      	mov	sp, r7
    58fe:	bc80      	pop	{r7}
    5900:	4770      	bx	lr

00005902 <BinaryUartCallbacks::BufferOverflow(unsigned char const*, unsigned int const&)>:
	virtual void BufferOverflow(const uint8_t* Buffer, const size_t& BufferLen) { }
    5902:	b480      	push	{r7}
    5904:	b085      	sub	sp, #20
    5906:	af00      	add	r7, sp, #0
    5908:	60f8      	str	r0, [r7, #12]
    590a:	60b9      	str	r1, [r7, #8]
    590c:	607a      	str	r2, [r7, #4]
    590e:	bf00      	nop
    5910:	3714      	adds	r7, #20
    5912:	46bd      	mov	sp, r7
    5914:	bc80      	pop	{r7}
    5916:	4770      	bx	lr

00005918 <BinaryUart::BinaryUart(IUart&, IPacket&, BinaryCmd const*, unsigned int, BinaryUartCallbacks&, bool, unsigned long long)>:
    BinaryUart(struct IUart& pinout, struct IPacket& packet, const BinaryCmd* cmds, const size_t numcmds, struct BinaryUartCallbacks& callbacks, const bool verbose = true, const uint64_t serialnum = InvalidSerialNumber)
    5918:	b580      	push	{r7, lr}
    591a:	b084      	sub	sp, #16
    591c:	af00      	add	r7, sp, #0
    591e:	60f8      	str	r0, [r7, #12]
    5920:	60b9      	str	r1, [r7, #8]
    5922:	607a      	str	r2, [r7, #4]
    5924:	603b      	str	r3, [r7, #0]
		SerialNum(serialnum)
    5926:	68fb      	ldr	r3, [r7, #12]
    5928:	68b9      	ldr	r1, [r7, #8]
    592a:	4618      	mov	r0, r3
    592c:	f7ff ff64 	bl	57f8 <IUartParser::IUartParser(IUart&)>
    5930:	4a26      	ldr	r2, [pc, #152]	@ (59cc <BinaryUart::BinaryUart(IUart&, IPacket&, BinaryCmd const*, unsigned int, BinaryUartCallbacks&, bool, unsigned long long)+0xb4>)
    5932:	68fb      	ldr	r3, [r7, #12]
    5934:	601a      	str	r2, [r3, #0]
    5936:	68fb      	ldr	r3, [r7, #12]
    5938:	2200      	movs	r2, #0
    593a:	609a      	str	r2, [r3, #8]
		RxCount(RxCountInit),
    593c:	68fb      	ldr	r3, [r7, #12]
    593e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5942:	2200      	movs	r2, #0
    5944:	819a      	strh	r2, [r3, #12]
		Packet(packet),
    5946:	68fb      	ldr	r3, [r7, #12]
    5948:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    594c:	461a      	mov	r2, r3
    594e:	687b      	ldr	r3, [r7, #4]
    5950:	6113      	str	r3, [r2, #16]
        Cmds(cmds),
    5952:	68fb      	ldr	r3, [r7, #12]
    5954:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5958:	461a      	mov	r2, r3
    595a:	683b      	ldr	r3, [r7, #0]
    595c:	6153      	str	r3, [r2, #20]
        NumCmds(numcmds),
    595e:	68fb      	ldr	r3, [r7, #12]
    5960:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5964:	461a      	mov	r2, r3
    5966:	69bb      	ldr	r3, [r7, #24]
    5968:	6193      	str	r3, [r2, #24]
		Callbacks(callbacks),
    596a:	68fb      	ldr	r3, [r7, #12]
    596c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5970:	461a      	mov	r2, r3
    5972:	69fb      	ldr	r3, [r7, #28]
    5974:	61d3      	str	r3, [r2, #28]
		debug(debugDefault),
    5976:	68fb      	ldr	r3, [r7, #12]
    5978:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    597c:	2200      	movs	r2, #0
    597e:	f883 2020 	strb.w	r2, [r3, #32]
		InPacket(InPacketInit),
    5982:	68fb      	ldr	r3, [r7, #12]
    5984:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5988:	2200      	movs	r2, #0
    598a:	f883 2021 	strb.w	r2, [r3, #33]	@ 0x21
		PacketStart(PacketStartInit),
    598e:	68fb      	ldr	r3, [r7, #12]
    5990:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5994:	461a      	mov	r2, r3
    5996:	2300      	movs	r3, #0
    5998:	6253      	str	r3, [r2, #36]	@ 0x24
		PacketLen(PacketLenInit),
    599a:	68fb      	ldr	r3, [r7, #12]
    599c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    59a0:	461a      	mov	r2, r3
    59a2:	2300      	movs	r3, #0
    59a4:	6293      	str	r3, [r2, #40]	@ 0x28
		SerialNum(serialnum)
    59a6:	68fb      	ldr	r3, [r7, #12]
    59a8:	f503 5381 	add.w	r3, r3, #4128	@ 0x1020
    59ac:	3310      	adds	r3, #16
    59ae:	4619      	mov	r1, r3
    59b0:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
    59b4:	e9c1 2300 	strd	r2, r3, [r1]
		Init(serialnum);
    59b8:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
    59bc:	68f8      	ldr	r0, [r7, #12]
    59be:	f000 f807 	bl	59d0 <BinaryUart::Init(unsigned long long)>
    }
    59c2:	68fb      	ldr	r3, [r7, #12]
    59c4:	4618      	mov	r0, r3
    59c6:	3710      	adds	r7, #16
    59c8:	46bd      	mov	sp, r7
    59ca:	bd80      	pop	{r7, pc}
    59cc:	0000b784 	.word	0x0000b784

000059d0 <BinaryUart::Init(unsigned long long)>:
    int Init(uint64_t serialnum)
    59d0:	b590      	push	{r4, r7, lr}
    59d2:	b085      	sub	sp, #20
    59d4:	af00      	add	r7, sp, #0
    59d6:	60f8      	str	r0, [r7, #12]
    59d8:	e9c7 2300 	strd	r2, r3, [r7]
		SerialNum = serialnum;
    59dc:	68fb      	ldr	r3, [r7, #12]
    59de:	f503 5381 	add.w	r3, r3, #4128	@ 0x1020
    59e2:	3310      	adds	r3, #16
    59e4:	4619      	mov	r1, r3
    59e6:	e9d7 2300 	ldrd	r2, r3, [r7]
    59ea:	e9c1 2300 	strd	r2, r3, [r1]
        RxCount = RxCountInit;
    59ee:	68fb      	ldr	r3, [r7, #12]
    59f0:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    59f4:	2200      	movs	r2, #0
    59f6:	819a      	strh	r2, [r3, #12]
		PacketStart = PacketStartInit;
    59f8:	68fb      	ldr	r3, [r7, #12]
    59fa:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    59fe:	461a      	mov	r2, r3
    5a00:	2300      	movs	r3, #0
    5a02:	6253      	str	r3, [r2, #36]	@ 0x24
		PacketLen = PacketLenInit;
    5a04:	68fb      	ldr	r3, [r7, #12]
    5a06:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5a0a:	461a      	mov	r2, r3
    5a0c:	2300      	movs	r3, #0
    5a0e:	6293      	str	r3, [r2, #40]	@ 0x28
		InPacket = InPacketInit;
    5a10:	68fb      	ldr	r3, [r7, #12]
    5a12:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5a16:	2200      	movs	r2, #0
    5a18:	f883 2021 	strb.w	r2, [r3, #33]	@ 0x21
        memset(RxBuffer, EmptyBufferChar, RxBufferLenBytes);
    5a1c:	68fb      	ldr	r3, [r7, #12]
    5a1e:	330c      	adds	r3, #12
    5a20:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
    5a24:	2100      	movs	r1, #0
    5a26:	4618      	mov	r0, r3
    5a28:	f001 fc30 	bl	728c <memset>
		if (debug) { ::formatf("\n\nBinary Uart: Init(PktH %u, PktF %u).\n\r", Packet.HeaderLen(), Packet.FooterLen()); }
    5a2c:	68fb      	ldr	r3, [r7, #12]
    5a2e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5a32:	f893 3020 	ldrb.w	r3, [r3, #32]
    5a36:	2b00      	cmp	r3, #0
    5a38:	d020      	beq.n	5a7c <BinaryUart::Init(unsigned long long)+0xac>
    5a3a:	68fb      	ldr	r3, [r7, #12]
    5a3c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5a40:	691b      	ldr	r3, [r3, #16]
    5a42:	681b      	ldr	r3, [r3, #0]
    5a44:	3310      	adds	r3, #16
    5a46:	681b      	ldr	r3, [r3, #0]
    5a48:	68fa      	ldr	r2, [r7, #12]
    5a4a:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
    5a4e:	6912      	ldr	r2, [r2, #16]
    5a50:	4610      	mov	r0, r2
    5a52:	4798      	blx	r3
    5a54:	4604      	mov	r4, r0
    5a56:	68fb      	ldr	r3, [r7, #12]
    5a58:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5a5c:	691b      	ldr	r3, [r3, #16]
    5a5e:	681b      	ldr	r3, [r3, #0]
    5a60:	3314      	adds	r3, #20
    5a62:	681b      	ldr	r3, [r3, #0]
    5a64:	68fa      	ldr	r2, [r7, #12]
    5a66:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
    5a6a:	6912      	ldr	r2, [r2, #16]
    5a6c:	4610      	mov	r0, r2
    5a6e:	4798      	blx	r3
    5a70:	4603      	mov	r3, r0
    5a72:	461a      	mov	r2, r3
    5a74:	4621      	mov	r1, r4
    5a76:	4804      	ldr	r0, [pc, #16]	@ (5a88 <BinaryUart::Init(unsigned long long)+0xb8>)
    5a78:	f7ff fc42 	bl	5300 <formatf>
        return(0);
    5a7c:	2300      	movs	r3, #0
    }
    5a7e:	4618      	mov	r0, r3
    5a80:	3714      	adds	r7, #20
    5a82:	46bd      	mov	sp, r7
    5a84:	bd90      	pop	{r4, r7, pc}
    5a86:	bf00      	nop
    5a88:	0000b288 	.word	0x0000b288

00005a8c <BinaryUart::Process()>:
    bool Process() override
    5a8c:	b580      	push	{r7, lr}
    5a8e:	b084      	sub	sp, #16
    5a90:	af00      	add	r7, sp, #0
    5a92:	6078      	str	r0, [r7, #4]
        if ( !(Pinout.dataready()) ) { return(false); }
    5a94:	687b      	ldr	r3, [r7, #4]
    5a96:	685b      	ldr	r3, [r3, #4]
    5a98:	681b      	ldr	r3, [r3, #0]
    5a9a:	3308      	adds	r3, #8
    5a9c:	681b      	ldr	r3, [r3, #0]
    5a9e:	687a      	ldr	r2, [r7, #4]
    5aa0:	6852      	ldr	r2, [r2, #4]
    5aa2:	4610      	mov	r0, r2
    5aa4:	4798      	blx	r3
    5aa6:	4603      	mov	r3, r0
    5aa8:	f083 0301 	eor.w	r3, r3, #1
    5aac:	b2db      	uxtb	r3, r3
    5aae:	2b00      	cmp	r3, #0
    5ab0:	d001      	beq.n	5ab6 <BinaryUart::Process()+0x2a>
    5ab2:	2300      	movs	r3, #0
    5ab4:	e021      	b.n	5afa <BinaryUart::Process()+0x6e>
        uint8_t c = Pinout.getcqq();
    5ab6:	687b      	ldr	r3, [r7, #4]
    5ab8:	685b      	ldr	r3, [r3, #4]
    5aba:	681b      	ldr	r3, [r3, #0]
    5abc:	330c      	adds	r3, #12
    5abe:	681b      	ldr	r3, [r3, #0]
    5ac0:	687a      	ldr	r2, [r7, #4]
    5ac2:	6852      	ldr	r2, [r2, #4]
    5ac4:	4610      	mov	r0, r2
    5ac6:	4798      	blx	r3
    5ac8:	4603      	mov	r3, r0
    5aca:	73fb      	strb	r3, [r7, #15]
        ProcessByte(c);
    5acc:	f997 300f 	ldrsb.w	r3, [r7, #15]
    5ad0:	4619      	mov	r1, r3
    5ad2:	6878      	ldr	r0, [r7, #4]
    5ad4:	f000 f816 	bl	5b04 <BinaryUart::ProcessByte(char)>
        if (!InPacket) {
    5ad8:	687b      	ldr	r3, [r7, #4]
    5ada:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5ade:	f893 3021 	ldrb.w	r3, [r3, #33]	@ 0x21
    5ae2:	f083 0301 	eor.w	r3, r3, #1
    5ae6:	b2db      	uxtb	r3, r3
    5ae8:	2b00      	cmp	r3, #0
    5aea:	d002      	beq.n	5af2 <BinaryUart::Process()+0x66>
          CheckPacketStart();
    5aec:	6878      	ldr	r0, [r7, #4]
    5aee:	f000 f863 	bl	5bb8 <BinaryUart::CheckPacketStart()>
        CheckPacketEnd();  // this returns if a packet was processed
    5af2:	6878      	ldr	r0, [r7, #4]
    5af4:	f000 f8ba 	bl	5c6c <BinaryUart::CheckPacketEnd()>
        return(true); //We just want to know if there's chars in the buffer to put threads to sleep or not...
    5af8:	2301      	movs	r3, #1
	}
    5afa:	4618      	mov	r0, r3
    5afc:	3710      	adds	r7, #16
    5afe:	46bd      	mov	sp, r7
    5b00:	bd80      	pop	{r7, pc}
	...

00005b04 <BinaryUart::ProcessByte(char)>:
	void ProcessByte(const char c)
    5b04:	b580      	push	{r7, lr}
    5b06:	b084      	sub	sp, #16
    5b08:	af00      	add	r7, sp, #0
    5b0a:	6078      	str	r0, [r7, #4]
    5b0c:	460b      	mov	r3, r1
    5b0e:	70fb      	strb	r3, [r7, #3]
		if (RxCount < RxBufferLenBytes)
    5b10:	687b      	ldr	r3, [r7, #4]
    5b12:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5b16:	899b      	ldrh	r3, [r3, #12]
    5b18:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
    5b1c:	d214      	bcs.n	5b48 <BinaryUart::ProcessByte(char)+0x44>
			RxCount++;
    5b1e:	687b      	ldr	r3, [r7, #4]
    5b20:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5b24:	899b      	ldrh	r3, [r3, #12]
    5b26:	3301      	adds	r3, #1
    5b28:	b29a      	uxth	r2, r3
    5b2a:	687b      	ldr	r3, [r7, #4]
    5b2c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5b30:	819a      	strh	r2, [r3, #12]
			RxBuffer[RxCount - 1] = c;
    5b32:	687b      	ldr	r3, [r7, #4]
    5b34:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5b38:	899b      	ldrh	r3, [r3, #12]
    5b3a:	3b01      	subs	r3, #1
    5b3c:	78f9      	ldrb	r1, [r7, #3]
    5b3e:	687a      	ldr	r2, [r7, #4]
    5b40:	4413      	add	r3, r2
    5b42:	460a      	mov	r2, r1
    5b44:	731a      	strb	r2, [r3, #12]
	}
    5b46:	e030      	b.n	5baa <BinaryUart::ProcessByte(char)+0xa6>
			if (debug) { ::formatf("\n\nBinaryUart: Buffer(%p) overflow; this packet will not fit (%zub), flushing buffer.\n\r", RxBuffer, RxCount); }
    5b48:	687b      	ldr	r3, [r7, #4]
    5b4a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5b4e:	f893 3020 	ldrb.w	r3, [r3, #32]
    5b52:	2b00      	cmp	r3, #0
    5b54:	d00a      	beq.n	5b6c <BinaryUart::ProcessByte(char)+0x68>
    5b56:	687b      	ldr	r3, [r7, #4]
    5b58:	f103 010c 	add.w	r1, r3, #12
    5b5c:	687b      	ldr	r3, [r7, #4]
    5b5e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5b62:	899b      	ldrh	r3, [r3, #12]
    5b64:	461a      	mov	r2, r3
    5b66:	4813      	ldr	r0, [pc, #76]	@ (5bb4 <BinaryUart::ProcessByte(char)+0xb0>)
    5b68:	f7ff fbca 	bl	5300 <formatf>
			Callbacks.BufferOverflow(RxBuffer, RxCount);
    5b6c:	687b      	ldr	r3, [r7, #4]
    5b6e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5b72:	69db      	ldr	r3, [r3, #28]
    5b74:	681b      	ldr	r3, [r3, #0]
    5b76:	3314      	adds	r3, #20
    5b78:	681b      	ldr	r3, [r3, #0]
    5b7a:	687a      	ldr	r2, [r7, #4]
    5b7c:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
    5b80:	69d0      	ldr	r0, [r2, #28]
    5b82:	687a      	ldr	r2, [r7, #4]
    5b84:	f102 010c 	add.w	r1, r2, #12
    5b88:	687a      	ldr	r2, [r7, #4]
    5b8a:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
    5b8e:	8992      	ldrh	r2, [r2, #12]
    5b90:	60fa      	str	r2, [r7, #12]
    5b92:	f107 020c 	add.w	r2, r7, #12
    5b96:	4798      	blx	r3
			Init(SerialNum);
    5b98:	687b      	ldr	r3, [r7, #4]
    5b9a:	f503 5381 	add.w	r3, r3, #4128	@ 0x1020
    5b9e:	3310      	adds	r3, #16
    5ba0:	e9d3 2300 	ldrd	r2, r3, [r3]
    5ba4:	6878      	ldr	r0, [r7, #4]
    5ba6:	f7ff ff13 	bl	59d0 <BinaryUart::Init(unsigned long long)>
	}
    5baa:	bf00      	nop
    5bac:	3710      	adds	r7, #16
    5bae:	46bd      	mov	sp, r7
    5bb0:	bd80      	pop	{r7, pc}
    5bb2:	bf00      	nop
    5bb4:	0000b2b4 	.word	0x0000b2b4

00005bb8 <BinaryUart::CheckPacketStart()>:
	void CheckPacketStart()
    5bb8:	b590      	push	{r4, r7, lr}
    5bba:	b083      	sub	sp, #12
    5bbc:	af00      	add	r7, sp, #0
    5bbe:	6078      	str	r0, [r7, #4]
		if ( (!InPacket) && (RxCount >= Packet.HeaderLen()) )
    5bc0:	687b      	ldr	r3, [r7, #4]
    5bc2:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5bc6:	f893 3021 	ldrb.w	r3, [r3, #33]	@ 0x21
    5bca:	f083 0301 	eor.w	r3, r3, #1
    5bce:	b2db      	uxtb	r3, r3
    5bd0:	2b00      	cmp	r3, #0
    5bd2:	d016      	beq.n	5c02 <BinaryUart::CheckPacketStart()+0x4a>
    5bd4:	687b      	ldr	r3, [r7, #4]
    5bd6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5bda:	899b      	ldrh	r3, [r3, #12]
    5bdc:	461c      	mov	r4, r3
    5bde:	687b      	ldr	r3, [r7, #4]
    5be0:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5be4:	691b      	ldr	r3, [r3, #16]
    5be6:	681b      	ldr	r3, [r3, #0]
    5be8:	3310      	adds	r3, #16
    5bea:	681b      	ldr	r3, [r3, #0]
    5bec:	687a      	ldr	r2, [r7, #4]
    5bee:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
    5bf2:	6912      	ldr	r2, [r2, #16]
    5bf4:	4610      	mov	r0, r2
    5bf6:	4798      	blx	r3
    5bf8:	4603      	mov	r3, r0
    5bfa:	429c      	cmp	r4, r3
    5bfc:	d301      	bcc.n	5c02 <BinaryUart::CheckPacketStart()+0x4a>
    5bfe:	2301      	movs	r3, #1
    5c00:	e000      	b.n	5c04 <BinaryUart::CheckPacketStart()+0x4c>
    5c02:	2300      	movs	r3, #0
    5c04:	2b00      	cmp	r3, #0
    5c06:	d02a      	beq.n	5c5e <BinaryUart::CheckPacketStart()+0xa6>
			if (Packet.FindPacketStart(RxBuffer, RxCount, PacketStart)) //This is wasteful, we really only need to look at the 4 newest bytes every time...
    5c08:	687b      	ldr	r3, [r7, #4]
    5c0a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5c0e:	691b      	ldr	r3, [r3, #16]
    5c10:	681b      	ldr	r3, [r3, #0]
    5c12:	3308      	adds	r3, #8
    5c14:	681c      	ldr	r4, [r3, #0]
    5c16:	687b      	ldr	r3, [r7, #4]
    5c18:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5c1c:	6918      	ldr	r0, [r3, #16]
    5c1e:	687b      	ldr	r3, [r7, #4]
    5c20:	f103 010c 	add.w	r1, r3, #12
    5c24:	687b      	ldr	r3, [r7, #4]
    5c26:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5c2a:	899b      	ldrh	r3, [r3, #12]
    5c2c:	461a      	mov	r2, r3
    5c2e:	687b      	ldr	r3, [r7, #4]
    5c30:	f503 5381 	add.w	r3, r3, #4128	@ 0x1020
    5c34:	3304      	adds	r3, #4
    5c36:	47a0      	blx	r4
    5c38:	4603      	mov	r3, r0
    5c3a:	2b00      	cmp	r3, #0
    5c3c:	d00f      	beq.n	5c5e <BinaryUart::CheckPacketStart()+0xa6>
				if (debug) { ::formatf("\n\nBinaryUart: Packet start detected! Buffering.\n\r"); }
    5c3e:	687b      	ldr	r3, [r7, #4]
    5c40:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5c44:	f893 3020 	ldrb.w	r3, [r3, #32]
    5c48:	2b00      	cmp	r3, #0
    5c4a:	d002      	beq.n	5c52 <BinaryUart::CheckPacketStart()+0x9a>
    5c4c:	4806      	ldr	r0, [pc, #24]	@ (5c68 <BinaryUart::CheckPacketStart()+0xb0>)
    5c4e:	f7ff fb57 	bl	5300 <formatf>
				InPacket = true;
    5c52:	687b      	ldr	r3, [r7, #4]
    5c54:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5c58:	2201      	movs	r2, #1
    5c5a:	f883 2021 	strb.w	r2, [r3, #33]	@ 0x21
	}
    5c5e:	bf00      	nop
    5c60:	370c      	adds	r7, #12
    5c62:	46bd      	mov	sp, r7
    5c64:	bd90      	pop	{r4, r7, pc}
    5c66:	bf00      	nop
    5c68:	0000b30c 	.word	0x0000b30c

00005c6c <BinaryUart::CheckPacketEnd()>:
	bool CheckPacketEnd()
    5c6c:	b5f0      	push	{r4, r5, r6, r7, lr}
    5c6e:	b091      	sub	sp, #68	@ 0x44
    5c70:	af02      	add	r7, sp, #8
    5c72:	6078      	str	r0, [r7, #4]
		PacketEnd = 0;
    5c74:	687b      	ldr	r3, [r7, #4]
    5c76:	2200      	movs	r2, #0
    5c78:	609a      	str	r2, [r3, #8]
		bool Processed = false;
    5c7a:	2300      	movs	r3, #0
    5c7c:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
		if (!InPacket || RxCount < (Packet.HeaderLen() + Packet.FooterLen()))
    5c80:	687b      	ldr	r3, [r7, #4]
    5c82:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5c86:	f893 3021 	ldrb.w	r3, [r3, #33]	@ 0x21
    5c8a:	f083 0301 	eor.w	r3, r3, #1
    5c8e:	b2db      	uxtb	r3, r3
    5c90:	2b00      	cmp	r3, #0
    5c92:	d123      	bne.n	5cdc <BinaryUart::CheckPacketEnd()+0x70>
    5c94:	687b      	ldr	r3, [r7, #4]
    5c96:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5c9a:	899b      	ldrh	r3, [r3, #12]
    5c9c:	461d      	mov	r5, r3
    5c9e:	687b      	ldr	r3, [r7, #4]
    5ca0:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5ca4:	691b      	ldr	r3, [r3, #16]
    5ca6:	681b      	ldr	r3, [r3, #0]
    5ca8:	3310      	adds	r3, #16
    5caa:	681b      	ldr	r3, [r3, #0]
    5cac:	687a      	ldr	r2, [r7, #4]
    5cae:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
    5cb2:	6912      	ldr	r2, [r2, #16]
    5cb4:	4610      	mov	r0, r2
    5cb6:	4798      	blx	r3
    5cb8:	4604      	mov	r4, r0
    5cba:	687b      	ldr	r3, [r7, #4]
    5cbc:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5cc0:	691b      	ldr	r3, [r3, #16]
    5cc2:	681b      	ldr	r3, [r3, #0]
    5cc4:	3314      	adds	r3, #20
    5cc6:	681b      	ldr	r3, [r3, #0]
    5cc8:	687a      	ldr	r2, [r7, #4]
    5cca:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
    5cce:	6912      	ldr	r2, [r2, #16]
    5cd0:	4610      	mov	r0, r2
    5cd2:	4798      	blx	r3
    5cd4:	4603      	mov	r3, r0
    5cd6:	4423      	add	r3, r4
    5cd8:	429d      	cmp	r5, r3
    5cda:	d201      	bcs.n	5ce0 <BinaryUart::CheckPacketEnd()+0x74>
    5cdc:	2301      	movs	r3, #1
    5cde:	e000      	b.n	5ce2 <BinaryUart::CheckPacketEnd()+0x76>
    5ce0:	2300      	movs	r3, #0
    5ce2:	2b00      	cmp	r3, #0
    5ce4:	d001      	beq.n	5cea <BinaryUart::CheckPacketEnd()+0x7e>
			return false;
    5ce6:	2300      	movs	r3, #0
    5ce8:	e36c      	b.n	63c4 <BinaryUart::CheckPacketEnd()+0x758>
		if (!Packet.FindPacketEnd(RxBuffer, RxCount, PacketEnd)) {
    5cea:	687b      	ldr	r3, [r7, #4]
    5cec:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5cf0:	691b      	ldr	r3, [r3, #16]
    5cf2:	681b      	ldr	r3, [r3, #0]
    5cf4:	330c      	adds	r3, #12
    5cf6:	681c      	ldr	r4, [r3, #0]
    5cf8:	687b      	ldr	r3, [r7, #4]
    5cfa:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5cfe:	6918      	ldr	r0, [r3, #16]
    5d00:	687b      	ldr	r3, [r7, #4]
    5d02:	f103 010c 	add.w	r1, r3, #12
    5d06:	687b      	ldr	r3, [r7, #4]
    5d08:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5d0c:	899b      	ldrh	r3, [r3, #12]
    5d0e:	461a      	mov	r2, r3
    5d10:	687b      	ldr	r3, [r7, #4]
    5d12:	3308      	adds	r3, #8
    5d14:	47a0      	blx	r4
    5d16:	4603      	mov	r3, r0
    5d18:	f083 0301 	eor.w	r3, r3, #1
    5d1c:	b2db      	uxtb	r3, r3
    5d1e:	2b00      	cmp	r3, #0
    5d20:	d00b      	beq.n	5d3a <BinaryUart::CheckPacketEnd()+0xce>
			if (debug) { ::formatf("\n\nBinaryUart: Still waiting for packet end...\n\r"); }
    5d22:	687b      	ldr	r3, [r7, #4]
    5d24:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5d28:	f893 3020 	ldrb.w	r3, [r3, #32]
    5d2c:	2b00      	cmp	r3, #0
    5d2e:	d002      	beq.n	5d36 <BinaryUart::CheckPacketEnd()+0xca>
    5d30:	4872      	ldr	r0, [pc, #456]	@ (5efc <BinaryUart::CheckPacketEnd()+0x290>)
    5d32:	f7ff fae5 	bl	5300 <formatf>
			return false;
    5d36:	2300      	movs	r3, #0
    5d38:	e344      	b.n	63c4 <BinaryUart::CheckPacketEnd()+0x758>
		if (debug) { ::formatf("\n\nBinaryUart: Packet end detected; Looking for matching packet handlers.\n\r"); }
    5d3a:	687b      	ldr	r3, [r7, #4]
    5d3c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5d40:	f893 3020 	ldrb.w	r3, [r3, #32]
    5d44:	2b00      	cmp	r3, #0
    5d46:	d002      	beq.n	5d4e <BinaryUart::CheckPacketEnd()+0xe2>
    5d48:	486d      	ldr	r0, [pc, #436]	@ (5f00 <BinaryUart::CheckPacketEnd()+0x294>)
    5d4a:	f7ff fad9 	bl	5300 <formatf>
		const size_t payloadLen = Packet.PayloadLen(RxBuffer, RxCount, PacketStart);
    5d4e:	687b      	ldr	r3, [r7, #4]
    5d50:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5d54:	691b      	ldr	r3, [r3, #16]
    5d56:	681b      	ldr	r3, [r3, #0]
    5d58:	3320      	adds	r3, #32
    5d5a:	681c      	ldr	r4, [r3, #0]
    5d5c:	687b      	ldr	r3, [r7, #4]
    5d5e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5d62:	6918      	ldr	r0, [r3, #16]
    5d64:	687b      	ldr	r3, [r7, #4]
    5d66:	f103 010c 	add.w	r1, r3, #12
    5d6a:	687b      	ldr	r3, [r7, #4]
    5d6c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5d70:	899b      	ldrh	r3, [r3, #12]
    5d72:	461a      	mov	r2, r3
    5d74:	687b      	ldr	r3, [r7, #4]
    5d76:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5d7a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
    5d7c:	47a0      	blx	r4
    5d7e:	6278      	str	r0, [r7, #36]	@ 0x24
		if (RxCount < payloadLen + Packet.HeaderLen() + Packet.FooterLen())
    5d80:	687b      	ldr	r3, [r7, #4]
    5d82:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5d86:	899b      	ldrh	r3, [r3, #12]
    5d88:	461d      	mov	r5, r3
    5d8a:	687b      	ldr	r3, [r7, #4]
    5d8c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5d90:	691b      	ldr	r3, [r3, #16]
    5d92:	681b      	ldr	r3, [r3, #0]
    5d94:	3310      	adds	r3, #16
    5d96:	681b      	ldr	r3, [r3, #0]
    5d98:	687a      	ldr	r2, [r7, #4]
    5d9a:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
    5d9e:	6912      	ldr	r2, [r2, #16]
    5da0:	4610      	mov	r0, r2
    5da2:	4798      	blx	r3
    5da4:	4602      	mov	r2, r0
    5da6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    5da8:	18d4      	adds	r4, r2, r3
    5daa:	687b      	ldr	r3, [r7, #4]
    5dac:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5db0:	691b      	ldr	r3, [r3, #16]
    5db2:	681b      	ldr	r3, [r3, #0]
    5db4:	3314      	adds	r3, #20
    5db6:	681b      	ldr	r3, [r3, #0]
    5db8:	687a      	ldr	r2, [r7, #4]
    5dba:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
    5dbe:	6912      	ldr	r2, [r2, #16]
    5dc0:	4610      	mov	r0, r2
    5dc2:	4798      	blx	r3
    5dc4:	4603      	mov	r3, r0
    5dc6:	4423      	add	r3, r4
    5dc8:	429d      	cmp	r5, r3
    5dca:	bf34      	ite	cc
    5dcc:	2301      	movcc	r3, #1
    5dce:	2300      	movcs	r3, #0
    5dd0:	b2db      	uxtb	r3, r3
    5dd2:	2b00      	cmp	r3, #0
    5dd4:	f000 809a 	beq.w	5f0c <BinaryUart::CheckPacketEnd()+0x2a0>
			if ( (payloadLen > RxBufferLenBytes) || (payloadLen > Packet.MaxPayloadLength())  )
    5dd8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    5dda:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
    5dde:	d810      	bhi.n	5e02 <BinaryUart::CheckPacketEnd()+0x196>
    5de0:	687b      	ldr	r3, [r7, #4]
    5de2:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5de6:	691b      	ldr	r3, [r3, #16]
    5de8:	681b      	ldr	r3, [r3, #0]
    5dea:	331c      	adds	r3, #28
    5dec:	681b      	ldr	r3, [r3, #0]
    5dee:	687a      	ldr	r2, [r7, #4]
    5df0:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
    5df4:	6912      	ldr	r2, [r2, #16]
    5df6:	4610      	mov	r0, r2
    5df8:	4798      	blx	r3
    5dfa:	4602      	mov	r2, r0
    5dfc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    5dfe:	4293      	cmp	r3, r2
    5e00:	d901      	bls.n	5e06 <BinaryUart::CheckPacketEnd()+0x19a>
    5e02:	2301      	movs	r3, #1
    5e04:	e000      	b.n	5e08 <BinaryUart::CheckPacketEnd()+0x19c>
    5e06:	2300      	movs	r3, #0
    5e08:	2b00      	cmp	r3, #0
    5e0a:	d04a      	beq.n	5ea2 <BinaryUart::CheckPacketEnd()+0x236>
				if (debug) { ::formatf("\n\nBinaryUart: Short packet (%lu bytes) with unrealistic payload len; ignoring corrupted packet (should have been header() + payload(%lu) + footer().\n\r", RxCount, Packet.PayloadLen(RxBuffer, RxCount, PacketStart)); }
    5e0c:	687b      	ldr	r3, [r7, #4]
    5e0e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5e12:	f893 3020 	ldrb.w	r3, [r3, #32]
    5e16:	2b00      	cmp	r3, #0
    5e18:	d022      	beq.n	5e60 <BinaryUart::CheckPacketEnd()+0x1f4>
    5e1a:	687b      	ldr	r3, [r7, #4]
    5e1c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5e20:	899b      	ldrh	r3, [r3, #12]
    5e22:	461d      	mov	r5, r3
    5e24:	687b      	ldr	r3, [r7, #4]
    5e26:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5e2a:	691b      	ldr	r3, [r3, #16]
    5e2c:	681b      	ldr	r3, [r3, #0]
    5e2e:	3320      	adds	r3, #32
    5e30:	681c      	ldr	r4, [r3, #0]
    5e32:	687b      	ldr	r3, [r7, #4]
    5e34:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5e38:	6918      	ldr	r0, [r3, #16]
    5e3a:	687b      	ldr	r3, [r7, #4]
    5e3c:	f103 010c 	add.w	r1, r3, #12
    5e40:	687b      	ldr	r3, [r7, #4]
    5e42:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5e46:	899b      	ldrh	r3, [r3, #12]
    5e48:	461a      	mov	r2, r3
    5e4a:	687b      	ldr	r3, [r7, #4]
    5e4c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5e50:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
    5e52:	47a0      	blx	r4
    5e54:	4603      	mov	r3, r0
    5e56:	461a      	mov	r2, r3
    5e58:	4629      	mov	r1, r5
    5e5a:	482a      	ldr	r0, [pc, #168]	@ (5f04 <BinaryUart::CheckPacketEnd()+0x298>)
    5e5c:	f7ff fa50 	bl	5300 <formatf>
				Callbacks.InvalidPacket(reinterpret_cast<uint8_t*>(RxBuffer), RxCount);
    5e60:	687b      	ldr	r3, [r7, #4]
    5e62:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5e66:	69db      	ldr	r3, [r3, #28]
    5e68:	681b      	ldr	r3, [r3, #0]
    5e6a:	3308      	adds	r3, #8
    5e6c:	681b      	ldr	r3, [r3, #0]
    5e6e:	687a      	ldr	r2, [r7, #4]
    5e70:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
    5e74:	69d0      	ldr	r0, [r2, #28]
    5e76:	687a      	ldr	r2, [r7, #4]
    5e78:	f102 010c 	add.w	r1, r2, #12
    5e7c:	687a      	ldr	r2, [r7, #4]
    5e7e:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
    5e82:	8992      	ldrh	r2, [r2, #12]
    5e84:	60fa      	str	r2, [r7, #12]
    5e86:	f107 020c 	add.w	r2, r7, #12
    5e8a:	4798      	blx	r3
				Init(SerialNum);
    5e8c:	687b      	ldr	r3, [r7, #4]
    5e8e:	f503 5381 	add.w	r3, r3, #4128	@ 0x1020
    5e92:	3310      	adds	r3, #16
    5e94:	e9d3 2300 	ldrd	r2, r3, [r3]
    5e98:	6878      	ldr	r0, [r7, #4]
    5e9a:	f7ff fd99 	bl	59d0 <BinaryUart::Init(unsigned long long)>
				return false;
    5e9e:	2300      	movs	r3, #0
    5ea0:	e290      	b.n	63c4 <BinaryUart::CheckPacketEnd()+0x758>
				if (debug) { ::formatf("\n\nBinaryUart: Short packet (%lu bytes); we'll assume the packet footer was part of the payload data and keep searching for the packet end (should have been header() + payload(%lu) + footer().\n\r", RxCount, Packet.PayloadLen(RxBuffer, RxCount, PacketStart)); }
    5ea2:	687b      	ldr	r3, [r7, #4]
    5ea4:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5ea8:	f893 3020 	ldrb.w	r3, [r3, #32]
    5eac:	2b00      	cmp	r3, #0
    5eae:	d022      	beq.n	5ef6 <BinaryUart::CheckPacketEnd()+0x28a>
    5eb0:	687b      	ldr	r3, [r7, #4]
    5eb2:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5eb6:	899b      	ldrh	r3, [r3, #12]
    5eb8:	461d      	mov	r5, r3
    5eba:	687b      	ldr	r3, [r7, #4]
    5ebc:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5ec0:	691b      	ldr	r3, [r3, #16]
    5ec2:	681b      	ldr	r3, [r3, #0]
    5ec4:	3320      	adds	r3, #32
    5ec6:	681c      	ldr	r4, [r3, #0]
    5ec8:	687b      	ldr	r3, [r7, #4]
    5eca:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5ece:	6918      	ldr	r0, [r3, #16]
    5ed0:	687b      	ldr	r3, [r7, #4]
    5ed2:	f103 010c 	add.w	r1, r3, #12
    5ed6:	687b      	ldr	r3, [r7, #4]
    5ed8:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5edc:	899b      	ldrh	r3, [r3, #12]
    5ede:	461a      	mov	r2, r3
    5ee0:	687b      	ldr	r3, [r7, #4]
    5ee2:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5ee6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
    5ee8:	47a0      	blx	r4
    5eea:	4603      	mov	r3, r0
    5eec:	461a      	mov	r2, r3
    5eee:	4629      	mov	r1, r5
    5ef0:	4805      	ldr	r0, [pc, #20]	@ (5f08 <BinaryUart::CheckPacketEnd()+0x29c>)
    5ef2:	f7ff fa05 	bl	5300 <formatf>
				return false;
    5ef6:	2300      	movs	r3, #0
    5ef8:	e264      	b.n	63c4 <BinaryUart::CheckPacketEnd()+0x758>
    5efa:	bf00      	nop
    5efc:	0000b340 	.word	0x0000b340
    5f00:	0000b370 	.word	0x0000b370
    5f04:	0000b3bc 	.word	0x0000b3bc
    5f08:	0000b454 	.word	0x0000b454
		if (Packet.IsValid(RxBuffer, RxCount, PacketStart, PacketEnd))
    5f0c:	687b      	ldr	r3, [r7, #4]
    5f0e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5f12:	691b      	ldr	r3, [r3, #16]
    5f14:	681b      	ldr	r3, [r3, #0]
    5f16:	3324      	adds	r3, #36	@ 0x24
    5f18:	681c      	ldr	r4, [r3, #0]
    5f1a:	687b      	ldr	r3, [r7, #4]
    5f1c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5f20:	6918      	ldr	r0, [r3, #16]
    5f22:	687b      	ldr	r3, [r7, #4]
    5f24:	f103 010c 	add.w	r1, r3, #12
    5f28:	687b      	ldr	r3, [r7, #4]
    5f2a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5f2e:	899b      	ldrh	r3, [r3, #12]
    5f30:	461d      	mov	r5, r3
    5f32:	687b      	ldr	r3, [r7, #4]
    5f34:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5f38:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
    5f3a:	687b      	ldr	r3, [r7, #4]
    5f3c:	689b      	ldr	r3, [r3, #8]
    5f3e:	9300      	str	r3, [sp, #0]
    5f40:	4613      	mov	r3, r2
    5f42:	462a      	mov	r2, r5
    5f44:	47a0      	blx	r4
    5f46:	4603      	mov	r3, r0
    5f48:	2b00      	cmp	r3, #0
    5f4a:	f000 81c3 	beq.w	62d4 <BinaryUart::CheckPacketEnd()+0x668>
			if (debug) {
    5f4e:	687b      	ldr	r3, [r7, #4]
    5f50:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5f54:	f893 3020 	ldrb.w	r3, [r3, #32]
    5f58:	2b00      	cmp	r3, #0
    5f5a:	d023      	beq.n	5fa4 <BinaryUart::CheckPacketEnd()+0x338>
				::formatf("\nExpected SerialNum: 0x%.8llX, Packet SerialNum: 0x%.8llX\n",
    5f5c:	687b      	ldr	r3, [r7, #4]
    5f5e:	f503 5381 	add.w	r3, r3, #4128	@ 0x1020
    5f62:	3310      	adds	r3, #16
    5f64:	e9d3 4500 	ldrd	r4, r5, [r3]
						SerialNum, Packet.SerialNum(RxBuffer, PacketStart, PacketEnd));
    5f68:	687b      	ldr	r3, [r7, #4]
    5f6a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5f6e:	691b      	ldr	r3, [r3, #16]
    5f70:	681b      	ldr	r3, [r3, #0]
    5f72:	332c      	adds	r3, #44	@ 0x2c
    5f74:	681e      	ldr	r6, [r3, #0]
    5f76:	687b      	ldr	r3, [r7, #4]
    5f78:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5f7c:	6918      	ldr	r0, [r3, #16]
    5f7e:	687b      	ldr	r3, [r7, #4]
    5f80:	f103 010c 	add.w	r1, r3, #12
				::formatf("\nExpected SerialNum: 0x%.8llX, Packet SerialNum: 0x%.8llX\n",
    5f84:	687b      	ldr	r3, [r7, #4]
    5f86:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5f8a:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
    5f8c:	687b      	ldr	r3, [r7, #4]
    5f8e:	689b      	ldr	r3, [r3, #8]
    5f90:	47b0      	blx	r6
    5f92:	4602      	mov	r2, r0
    5f94:	460b      	mov	r3, r1
    5f96:	e9cd 2300 	strd	r2, r3, [sp]
    5f9a:	4622      	mov	r2, r4
    5f9c:	462b      	mov	r3, r5
    5f9e:	4896      	ldr	r0, [pc, #600]	@ (61f8 <BinaryUart::CheckPacketEnd()+0x58c>)
    5fa0:	f7ff f9ae 	bl	5300 <formatf>
			if ( (SerialNum == InvalidSerialNumber) || (Packet.IsBroadcastSerialNum(RxBuffer, PacketStart, PacketEnd)) || (SerialNum == Packet.SerialNum(RxBuffer, PacketStart, PacketEnd)) )
    5fa4:	687b      	ldr	r3, [r7, #4]
    5fa6:	f503 5381 	add.w	r3, r3, #4128	@ 0x1020
    5faa:	3310      	adds	r3, #16
    5fac:	e9d3 2300 	ldrd	r2, r3, [r3]
    5fb0:	f1b3 3fff 	cmp.w	r3, #4294967295
    5fb4:	bf08      	it	eq
    5fb6:	f1b2 3fff 	cmpeq.w	r2, #4294967295
    5fba:	d038      	beq.n	602e <BinaryUart::CheckPacketEnd()+0x3c2>
    5fbc:	687b      	ldr	r3, [r7, #4]
    5fbe:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5fc2:	691b      	ldr	r3, [r3, #16]
    5fc4:	681b      	ldr	r3, [r3, #0]
    5fc6:	3328      	adds	r3, #40	@ 0x28
    5fc8:	681c      	ldr	r4, [r3, #0]
    5fca:	687b      	ldr	r3, [r7, #4]
    5fcc:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5fd0:	6918      	ldr	r0, [r3, #16]
    5fd2:	687b      	ldr	r3, [r7, #4]
    5fd4:	f103 010c 	add.w	r1, r3, #12
    5fd8:	687b      	ldr	r3, [r7, #4]
    5fda:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5fde:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
    5fe0:	687b      	ldr	r3, [r7, #4]
    5fe2:	689b      	ldr	r3, [r3, #8]
    5fe4:	47a0      	blx	r4
    5fe6:	4603      	mov	r3, r0
    5fe8:	2b00      	cmp	r3, #0
    5fea:	d120      	bne.n	602e <BinaryUart::CheckPacketEnd()+0x3c2>
    5fec:	687b      	ldr	r3, [r7, #4]
    5fee:	f503 5381 	add.w	r3, r3, #4128	@ 0x1020
    5ff2:	3310      	adds	r3, #16
    5ff4:	e9d3 4500 	ldrd	r4, r5, [r3]
    5ff8:	687b      	ldr	r3, [r7, #4]
    5ffa:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    5ffe:	691b      	ldr	r3, [r3, #16]
    6000:	681b      	ldr	r3, [r3, #0]
    6002:	332c      	adds	r3, #44	@ 0x2c
    6004:	681e      	ldr	r6, [r3, #0]
    6006:	687b      	ldr	r3, [r7, #4]
    6008:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    600c:	6918      	ldr	r0, [r3, #16]
    600e:	687b      	ldr	r3, [r7, #4]
    6010:	f103 010c 	add.w	r1, r3, #12
    6014:	687b      	ldr	r3, [r7, #4]
    6016:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    601a:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
    601c:	687b      	ldr	r3, [r7, #4]
    601e:	689b      	ldr	r3, [r3, #8]
    6020:	47b0      	blx	r6
    6022:	4602      	mov	r2, r0
    6024:	460b      	mov	r3, r1
    6026:	429d      	cmp	r5, r3
    6028:	bf08      	it	eq
    602a:	4294      	cmpeq	r4, r2
    602c:	d101      	bne.n	6032 <BinaryUart::CheckPacketEnd()+0x3c6>
    602e:	2301      	movs	r3, #1
    6030:	e000      	b.n	6034 <BinaryUart::CheckPacketEnd()+0x3c8>
    6032:	2300      	movs	r3, #0
    6034:	2b00      	cmp	r3, #0
    6036:	f000 80e3 	beq.w	6200 <BinaryUart::CheckPacketEnd()+0x594>
				bool CmdFound = false;
    603a:	2300      	movs	r3, #0
    603c:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36
				for (size_t i = 0; i < NumCmds; i++)
    6040:	2300      	movs	r3, #0
    6042:	633b      	str	r3, [r7, #48]	@ 0x30
    6044:	e082      	b.n	614c <BinaryUart::CheckPacketEnd()+0x4e0>
					if (Packet.DoesPayloadTypeMatch(RxBuffer, RxCount, PacketStart, PacketEnd, Cmds[i].Name))
    6046:	687b      	ldr	r3, [r7, #4]
    6048:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    604c:	691b      	ldr	r3, [r3, #16]
    604e:	681b      	ldr	r3, [r3, #0]
    6050:	3334      	adds	r3, #52	@ 0x34
    6052:	681c      	ldr	r4, [r3, #0]
    6054:	687b      	ldr	r3, [r7, #4]
    6056:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    605a:	691d      	ldr	r5, [r3, #16]
    605c:	687b      	ldr	r3, [r7, #4]
    605e:	f103 060c 	add.w	r6, r3, #12
    6062:	687b      	ldr	r3, [r7, #4]
    6064:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    6068:	899b      	ldrh	r3, [r3, #12]
    606a:	469c      	mov	ip, r3
    606c:	687b      	ldr	r3, [r7, #4]
    606e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    6072:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
    6074:	603b      	str	r3, [r7, #0]
    6076:	687b      	ldr	r3, [r7, #4]
    6078:	6899      	ldr	r1, [r3, #8]
    607a:	687b      	ldr	r3, [r7, #4]
    607c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    6080:	6958      	ldr	r0, [r3, #20]
    6082:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
    6084:	4613      	mov	r3, r2
    6086:	005b      	lsls	r3, r3, #1
    6088:	4413      	add	r3, r2
    608a:	009b      	lsls	r3, r3, #2
    608c:	4403      	add	r3, r0
    608e:	681b      	ldr	r3, [r3, #0]
    6090:	9301      	str	r3, [sp, #4]
    6092:	9100      	str	r1, [sp, #0]
    6094:	683b      	ldr	r3, [r7, #0]
    6096:	4662      	mov	r2, ip
    6098:	4631      	mov	r1, r6
    609a:	4628      	mov	r0, r5
    609c:	47a0      	blx	r4
    609e:	4603      	mov	r3, r0
    60a0:	2b00      	cmp	r3, #0
    60a2:	d050      	beq.n	6146 <BinaryUart::CheckPacketEnd()+0x4da>
						const char* Params = reinterpret_cast<char*>(&(RxBuffer[PacketStart + Packet.PayloadOffset()]));
    60a4:	687b      	ldr	r3, [r7, #4]
    60a6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    60aa:	6a5c      	ldr	r4, [r3, #36]	@ 0x24
    60ac:	687b      	ldr	r3, [r7, #4]
    60ae:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    60b2:	691b      	ldr	r3, [r3, #16]
    60b4:	681b      	ldr	r3, [r3, #0]
    60b6:	3318      	adds	r3, #24
    60b8:	681b      	ldr	r3, [r3, #0]
    60ba:	687a      	ldr	r2, [r7, #4]
    60bc:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
    60c0:	6912      	ldr	r2, [r2, #16]
    60c2:	4610      	mov	r0, r2
    60c4:	4798      	blx	r3
    60c6:	4603      	mov	r3, r0
    60c8:	4423      	add	r3, r4
    60ca:	3308      	adds	r3, #8
    60cc:	687a      	ldr	r2, [r7, #4]
    60ce:	4413      	add	r3, r2
    60d0:	3304      	adds	r3, #4
    60d2:	623b      	str	r3, [r7, #32]
						Cmds[i].Response(Cmds[i].Name, Params, Packet.PayloadLen(RxBuffer, RxCount, PacketStart), (void*)this);
    60d4:	687b      	ldr	r3, [r7, #4]
    60d6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    60da:	6959      	ldr	r1, [r3, #20]
    60dc:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
    60de:	4613      	mov	r3, r2
    60e0:	005b      	lsls	r3, r3, #1
    60e2:	4413      	add	r3, r2
    60e4:	009b      	lsls	r3, r3, #2
    60e6:	440b      	add	r3, r1
    60e8:	689c      	ldr	r4, [r3, #8]
    60ea:	687b      	ldr	r3, [r7, #4]
    60ec:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    60f0:	6959      	ldr	r1, [r3, #20]
    60f2:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
    60f4:	4613      	mov	r3, r2
    60f6:	005b      	lsls	r3, r3, #1
    60f8:	4413      	add	r3, r2
    60fa:	009b      	lsls	r3, r3, #2
    60fc:	440b      	add	r3, r1
    60fe:	681e      	ldr	r6, [r3, #0]
    6100:	687b      	ldr	r3, [r7, #4]
    6102:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    6106:	691b      	ldr	r3, [r3, #16]
    6108:	681b      	ldr	r3, [r3, #0]
    610a:	3320      	adds	r3, #32
    610c:	681d      	ldr	r5, [r3, #0]
    610e:	687b      	ldr	r3, [r7, #4]
    6110:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    6114:	6918      	ldr	r0, [r3, #16]
    6116:	687b      	ldr	r3, [r7, #4]
    6118:	f103 010c 	add.w	r1, r3, #12
    611c:	687b      	ldr	r3, [r7, #4]
    611e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    6122:	899b      	ldrh	r3, [r3, #12]
    6124:	461a      	mov	r2, r3
    6126:	687b      	ldr	r3, [r7, #4]
    6128:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    612c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
    612e:	47a8      	blx	r5
    6130:	4602      	mov	r2, r0
    6132:	687b      	ldr	r3, [r7, #4]
    6134:	6a39      	ldr	r1, [r7, #32]
    6136:	4630      	mov	r0, r6
    6138:	47a0      	blx	r4
						CmdFound = true;
    613a:	2301      	movs	r3, #1
    613c:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36
						Processed = true;
    6140:	2301      	movs	r3, #1
    6142:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
				for (size_t i = 0; i < NumCmds; i++)
    6146:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    6148:	3301      	adds	r3, #1
    614a:	633b      	str	r3, [r7, #48]	@ 0x30
    614c:	687b      	ldr	r3, [r7, #4]
    614e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    6152:	699b      	ldr	r3, [r3, #24]
    6154:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
    6156:	429a      	cmp	r2, r3
    6158:	f4ff af75 	bcc.w	6046 <BinaryUart::CheckPacketEnd()+0x3da>
				if (!CmdFound)
    615c:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
    6160:	f083 0301 	eor.w	r3, r3, #1
    6164:	b2db      	uxtb	r3, r3
    6166:	2b00      	cmp	r3, #0
    6168:	f000 8094 	beq.w	6294 <BinaryUart::CheckPacketEnd()+0x628>
					if (debug) { ::formatf("\n\nBinaryUart: Unmatched command 0x%.8lX! NumCmds: %lu\n", Packet.PayloadType(RxBuffer, PacketStart, PacketEnd), (unsigned long)NumCmds); }
    616c:	687b      	ldr	r3, [r7, #4]
    616e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    6172:	f893 3020 	ldrb.w	r3, [r3, #32]
    6176:	2b00      	cmp	r3, #0
    6178:	d01e      	beq.n	61b8 <BinaryUart::CheckPacketEnd()+0x54c>
    617a:	687b      	ldr	r3, [r7, #4]
    617c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    6180:	691b      	ldr	r3, [r3, #16]
    6182:	681b      	ldr	r3, [r3, #0]
    6184:	3330      	adds	r3, #48	@ 0x30
    6186:	681c      	ldr	r4, [r3, #0]
    6188:	687b      	ldr	r3, [r7, #4]
    618a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    618e:	6918      	ldr	r0, [r3, #16]
    6190:	687b      	ldr	r3, [r7, #4]
    6192:	f103 010c 	add.w	r1, r3, #12
    6196:	687b      	ldr	r3, [r7, #4]
    6198:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    619c:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
    619e:	687b      	ldr	r3, [r7, #4]
    61a0:	689b      	ldr	r3, [r3, #8]
    61a2:	47a0      	blx	r4
    61a4:	4602      	mov	r2, r0
    61a6:	460b      	mov	r3, r1
    61a8:	6879      	ldr	r1, [r7, #4]
    61aa:	f501 5180 	add.w	r1, r1, #4096	@ 0x1000
    61ae:	6989      	ldr	r1, [r1, #24]
    61b0:	9100      	str	r1, [sp, #0]
    61b2:	4812      	ldr	r0, [pc, #72]	@ (61fc <BinaryUart::CheckPacketEnd()+0x590>)
    61b4:	f7ff f8a4 	bl	5300 <formatf>
					Callbacks.UnHandledPacket(reinterpret_cast<IPacket*>(&RxBuffer[PacketStart]), PacketEnd - PacketStart);
    61b8:	687b      	ldr	r3, [r7, #4]
    61ba:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    61be:	69db      	ldr	r3, [r3, #28]
    61c0:	681b      	ldr	r3, [r3, #0]
    61c2:	330c      	adds	r3, #12
    61c4:	681b      	ldr	r3, [r3, #0]
    61c6:	687a      	ldr	r2, [r7, #4]
    61c8:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
    61cc:	69d0      	ldr	r0, [r2, #28]
    61ce:	687a      	ldr	r2, [r7, #4]
    61d0:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
    61d4:	6a52      	ldr	r2, [r2, #36]	@ 0x24
    61d6:	3208      	adds	r2, #8
    61d8:	6879      	ldr	r1, [r7, #4]
    61da:	440a      	add	r2, r1
    61dc:	1d14      	adds	r4, r2, #4
    61de:	687a      	ldr	r2, [r7, #4]
    61e0:	6891      	ldr	r1, [r2, #8]
    61e2:	687a      	ldr	r2, [r7, #4]
    61e4:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
    61e8:	6a52      	ldr	r2, [r2, #36]	@ 0x24
    61ea:	1a8a      	subs	r2, r1, r2
    61ec:	613a      	str	r2, [r7, #16]
    61ee:	f107 0210 	add.w	r2, r7, #16
    61f2:	4621      	mov	r1, r4
    61f4:	4798      	blx	r3
    61f6:	e04d      	b.n	6294 <BinaryUart::CheckPacketEnd()+0x628>
    61f8:	0000b518 	.word	0x0000b518
    61fc:	0000b554 	.word	0x0000b554
				if (debug) { ::formatf("\n\nBinaryUart: Packet received, but SerialNumber comparison failed (expected: 0x%.8lX; got: 0x%.8lX).\n\r", SerialNum, Packet.SerialNum(RxBuffer, PacketStart, PacketEnd)); }
    6200:	687b      	ldr	r3, [r7, #4]
    6202:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    6206:	f893 3020 	ldrb.w	r3, [r3, #32]
    620a:	2b00      	cmp	r3, #0
    620c:	d023      	beq.n	6256 <BinaryUart::CheckPacketEnd()+0x5ea>
    620e:	687b      	ldr	r3, [r7, #4]
    6210:	f503 5381 	add.w	r3, r3, #4128	@ 0x1020
    6214:	3310      	adds	r3, #16
    6216:	e9d3 4500 	ldrd	r4, r5, [r3]
    621a:	687b      	ldr	r3, [r7, #4]
    621c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    6220:	691b      	ldr	r3, [r3, #16]
    6222:	681b      	ldr	r3, [r3, #0]
    6224:	332c      	adds	r3, #44	@ 0x2c
    6226:	681e      	ldr	r6, [r3, #0]
    6228:	687b      	ldr	r3, [r7, #4]
    622a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    622e:	6918      	ldr	r0, [r3, #16]
    6230:	687b      	ldr	r3, [r7, #4]
    6232:	f103 010c 	add.w	r1, r3, #12
    6236:	687b      	ldr	r3, [r7, #4]
    6238:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    623c:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
    623e:	687b      	ldr	r3, [r7, #4]
    6240:	689b      	ldr	r3, [r3, #8]
    6242:	47b0      	blx	r6
    6244:	4602      	mov	r2, r0
    6246:	460b      	mov	r3, r1
    6248:	e9cd 2300 	strd	r2, r3, [sp]
    624c:	4622      	mov	r2, r4
    624e:	462b      	mov	r3, r5
    6250:	485e      	ldr	r0, [pc, #376]	@ (63cc <BinaryUart::CheckPacketEnd()+0x760>)
    6252:	f7ff f855 	bl	5300 <formatf>
				Callbacks.UnHandledPacket(reinterpret_cast<IPacket*>(&RxBuffer[PacketStart]), PacketEnd - PacketStart);
    6256:	687b      	ldr	r3, [r7, #4]
    6258:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    625c:	69db      	ldr	r3, [r3, #28]
    625e:	681b      	ldr	r3, [r3, #0]
    6260:	330c      	adds	r3, #12
    6262:	681b      	ldr	r3, [r3, #0]
    6264:	687a      	ldr	r2, [r7, #4]
    6266:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
    626a:	69d0      	ldr	r0, [r2, #28]
    626c:	687a      	ldr	r2, [r7, #4]
    626e:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
    6272:	6a52      	ldr	r2, [r2, #36]	@ 0x24
    6274:	3208      	adds	r2, #8
    6276:	6879      	ldr	r1, [r7, #4]
    6278:	440a      	add	r2, r1
    627a:	1d14      	adds	r4, r2, #4
    627c:	687a      	ldr	r2, [r7, #4]
    627e:	6891      	ldr	r1, [r2, #8]
    6280:	687a      	ldr	r2, [r7, #4]
    6282:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
    6286:	6a52      	ldr	r2, [r2, #36]	@ 0x24
    6288:	1a8a      	subs	r2, r1, r2
    628a:	617a      	str	r2, [r7, #20]
    628c:	f107 0214 	add.w	r2, r7, #20
    6290:	4621      	mov	r1, r4
    6292:	4798      	blx	r3
			Callbacks.EveryPacket(reinterpret_cast<IPacket*>(&RxBuffer[PacketStart]), PacketEnd - PacketStart);
    6294:	687b      	ldr	r3, [r7, #4]
    6296:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    629a:	69db      	ldr	r3, [r3, #28]
    629c:	681b      	ldr	r3, [r3, #0]
    629e:	3310      	adds	r3, #16
    62a0:	681b      	ldr	r3, [r3, #0]
    62a2:	687a      	ldr	r2, [r7, #4]
    62a4:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
    62a8:	69d0      	ldr	r0, [r2, #28]
    62aa:	687a      	ldr	r2, [r7, #4]
    62ac:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
    62b0:	6a52      	ldr	r2, [r2, #36]	@ 0x24
    62b2:	3208      	adds	r2, #8
    62b4:	6879      	ldr	r1, [r7, #4]
    62b6:	440a      	add	r2, r1
    62b8:	1d14      	adds	r4, r2, #4
    62ba:	687a      	ldr	r2, [r7, #4]
    62bc:	6891      	ldr	r1, [r2, #8]
    62be:	687a      	ldr	r2, [r7, #4]
    62c0:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
    62c4:	6a52      	ldr	r2, [r2, #36]	@ 0x24
    62c6:	1a8a      	subs	r2, r1, r2
    62c8:	61ba      	str	r2, [r7, #24]
    62ca:	f107 0218 	add.w	r2, r7, #24
    62ce:	4621      	mov	r1, r4
    62d0:	4798      	blx	r3
    62d2:	e01f      	b.n	6314 <BinaryUart::CheckPacketEnd()+0x6a8>
			if (debug) { ::formatf("\n\nBinaryUart: Packet received, but invalid.\n\r"); }
    62d4:	687b      	ldr	r3, [r7, #4]
    62d6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    62da:	f893 3020 	ldrb.w	r3, [r3, #32]
    62de:	2b00      	cmp	r3, #0
    62e0:	d002      	beq.n	62e8 <BinaryUart::CheckPacketEnd()+0x67c>
    62e2:	483b      	ldr	r0, [pc, #236]	@ (63d0 <BinaryUart::CheckPacketEnd()+0x764>)
    62e4:	f7ff f80c 	bl	5300 <formatf>
			Callbacks.InvalidPacket(reinterpret_cast<uint8_t*>(RxBuffer), RxCount);
    62e8:	687b      	ldr	r3, [r7, #4]
    62ea:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    62ee:	69db      	ldr	r3, [r3, #28]
    62f0:	681b      	ldr	r3, [r3, #0]
    62f2:	3308      	adds	r3, #8
    62f4:	681b      	ldr	r3, [r3, #0]
    62f6:	687a      	ldr	r2, [r7, #4]
    62f8:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
    62fc:	69d0      	ldr	r0, [r2, #28]
    62fe:	687a      	ldr	r2, [r7, #4]
    6300:	f102 010c 	add.w	r1, r2, #12
    6304:	687a      	ldr	r2, [r7, #4]
    6306:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
    630a:	8992      	ldrh	r2, [r2, #12]
    630c:	61fa      	str	r2, [r7, #28]
    630e:	f107 021c 	add.w	r2, r7, #28
    6312:	4798      	blx	r3
		InPacket = false;
    6314:	687b      	ldr	r3, [r7, #4]
    6316:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    631a:	2200      	movs	r2, #0
    631c:	f883 2021 	strb.w	r2, [r3, #33]	@ 0x21
		if (RxCount > (PacketEnd + 4) )
    6320:	687b      	ldr	r3, [r7, #4]
    6322:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    6326:	899b      	ldrh	r3, [r3, #12]
    6328:	461a      	mov	r2, r3
    632a:	687b      	ldr	r3, [r7, #4]
    632c:	689b      	ldr	r3, [r3, #8]
    632e:	3304      	adds	r3, #4
    6330:	429a      	cmp	r2, r3
    6332:	d93c      	bls.n	63ae <BinaryUart::CheckPacketEnd()+0x742>
			size_t pos = 0;
    6334:	2300      	movs	r3, #0
    6336:	62fb      	str	r3, [r7, #44]	@ 0x2c
			size_t clr = 0;
    6338:	2300      	movs	r3, #0
    633a:	62bb      	str	r3, [r7, #40]	@ 0x28
			for (; pos < (RxCount - (PacketEnd + 4)); pos++)
    633c:	e010      	b.n	6360 <BinaryUart::CheckPacketEnd()+0x6f4>
				RxBuffer[pos] = RxBuffer[(PacketEnd + 4) + pos];
    633e:	687b      	ldr	r3, [r7, #4]
    6340:	689a      	ldr	r2, [r3, #8]
    6342:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    6344:	4413      	add	r3, r2
    6346:	3304      	adds	r3, #4
    6348:	687a      	ldr	r2, [r7, #4]
    634a:	4413      	add	r3, r2
    634c:	7b19      	ldrb	r1, [r3, #12]
    634e:	687a      	ldr	r2, [r7, #4]
    6350:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    6352:	4413      	add	r3, r2
    6354:	330c      	adds	r3, #12
    6356:	460a      	mov	r2, r1
    6358:	701a      	strb	r2, [r3, #0]
			for (; pos < (RxCount - (PacketEnd + 4)); pos++)
    635a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    635c:	3301      	adds	r3, #1
    635e:	62fb      	str	r3, [r7, #44]	@ 0x2c
    6360:	687b      	ldr	r3, [r7, #4]
    6362:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    6366:	899b      	ldrh	r3, [r3, #12]
    6368:	461a      	mov	r2, r3
    636a:	687b      	ldr	r3, [r7, #4]
    636c:	689b      	ldr	r3, [r3, #8]
    636e:	1ad3      	subs	r3, r2, r3
    6370:	3b04      	subs	r3, #4
    6372:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
    6374:	429a      	cmp	r2, r3
    6376:	d3e2      	bcc.n	633e <BinaryUart::CheckPacketEnd()+0x6d2>
			for (clr = pos; clr < RxCount; clr++)
    6378:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    637a:	62bb      	str	r3, [r7, #40]	@ 0x28
    637c:	e008      	b.n	6390 <BinaryUart::CheckPacketEnd()+0x724>
				RxBuffer[clr] = 0;
    637e:	687a      	ldr	r2, [r7, #4]
    6380:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    6382:	4413      	add	r3, r2
    6384:	330c      	adds	r3, #12
    6386:	2200      	movs	r2, #0
    6388:	701a      	strb	r2, [r3, #0]
			for (clr = pos; clr < RxCount; clr++)
    638a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    638c:	3301      	adds	r3, #1
    638e:	62bb      	str	r3, [r7, #40]	@ 0x28
    6390:	687b      	ldr	r3, [r7, #4]
    6392:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    6396:	899b      	ldrh	r3, [r3, #12]
    6398:	461a      	mov	r2, r3
    639a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    639c:	4293      	cmp	r3, r2
    639e:	d3ee      	bcc.n	637e <BinaryUart::CheckPacketEnd()+0x712>
			RxCount = pos;
    63a0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    63a2:	b29a      	uxth	r2, r3
    63a4:	687b      	ldr	r3, [r7, #4]
    63a6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    63aa:	819a      	strh	r2, [r3, #12]
    63ac:	e008      	b.n	63c0 <BinaryUart::CheckPacketEnd()+0x754>
			Init(SerialNum);
    63ae:	687b      	ldr	r3, [r7, #4]
    63b0:	f503 5381 	add.w	r3, r3, #4128	@ 0x1020
    63b4:	3310      	adds	r3, #16
    63b6:	e9d3 2300 	ldrd	r2, r3, [r3]
    63ba:	6878      	ldr	r0, [r7, #4]
    63bc:	f7ff fb08 	bl	59d0 <BinaryUart::Init(unsigned long long)>
		return(Processed);
    63c0:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
    }
    63c4:	4618      	mov	r0, r3
    63c6:	373c      	adds	r7, #60	@ 0x3c
    63c8:	46bd      	mov	sp, r7
    63ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
    63cc:	0000b58c 	.word	0x0000b58c
    63d0:	0000b5f4 	.word	0x0000b5f4

000063d4 <BinaryUart::TxBinaryPacket(unsigned short, unsigned long, void const*, unsigned int) const>:
	virtual void TxBinaryPacket(const uint16_t PayloadType, const uint32_t SerialNumber, const void* PayloadData, const size_t PayloadLen) const
    63d4:	b590      	push	{r4, r7, lr}
    63d6:	f5ad 5d81 	sub.w	sp, sp, #4128	@ 0x1020
    63da:	b083      	sub	sp, #12
    63dc:	af02      	add	r7, sp, #8
    63de:	f107 0420 	add.w	r4, r7, #32
    63e2:	f844 0c14 	str.w	r0, [r4, #-20]
    63e6:	4608      	mov	r0, r1
    63e8:	f107 0120 	add.w	r1, r7, #32
    63ec:	f841 2c1c 	str.w	r2, [r1, #-28]
    63f0:	f107 0220 	add.w	r2, r7, #32
    63f4:	f842 3c20 	str.w	r3, [r2, #-32]
    63f8:	f107 0320 	add.w	r3, r7, #32
    63fc:	4602      	mov	r2, r0
    63fe:	f823 2c16 	strh.w	r2, [r3, #-22]
		size_t PktLen = Packet.MakePacket(TxBuffer, TxBufferLenBytes, PayloadData, PayloadType, PayloadLen); ///< Build packet
    6402:	f107 0320 	add.w	r3, r7, #32
    6406:	f853 3c14 	ldr.w	r3, [r3, #-20]
    640a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    640e:	691b      	ldr	r3, [r3, #16]
    6410:	681b      	ldr	r3, [r3, #0]
    6412:	3338      	adds	r3, #56	@ 0x38
    6414:	681c      	ldr	r4, [r3, #0]
    6416:	f107 0320 	add.w	r3, r7, #32
    641a:	f853 3c14 	ldr.w	r3, [r3, #-20]
    641e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    6422:	6918      	ldr	r0, [r3, #16]
    6424:	f107 0320 	add.w	r3, r7, #32
    6428:	461a      	mov	r2, r3
    642a:	f107 0120 	add.w	r1, r7, #32
    642e:	390c      	subs	r1, #12
    6430:	f507 5381 	add.w	r3, r7, #4128	@ 0x1020
    6434:	f103 0310 	add.w	r3, r3, #16
    6438:	681b      	ldr	r3, [r3, #0]
    643a:	9301      	str	r3, [sp, #4]
    643c:	f107 0320 	add.w	r3, r7, #32
    6440:	f833 3c16 	ldrh.w	r3, [r3, #-22]
    6444:	9300      	str	r3, [sp, #0]
    6446:	f852 3c20 	ldr.w	r3, [r2, #-32]
    644a:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
    644e:	47a0      	blx	r4
    6450:	f507 5380 	add.w	r3, r7, #4096	@ 0x1000
    6454:	f103 0314 	add.w	r3, r3, #20
    6458:	6018      	str	r0, [r3, #0]
		for (size_t i = 0; i < PktLen; i++) { Pinout.putcqq(TxBuffer[i]); }
    645a:	2300      	movs	r3, #0
    645c:	f507 5280 	add.w	r2, r7, #4096	@ 0x1000
    6460:	f102 021c 	add.w	r2, r2, #28
    6464:	6013      	str	r3, [r2, #0]
    6466:	e025      	b.n	64b4 <BinaryUart::TxBinaryPacket(unsigned short, unsigned long, void const*, unsigned int) const+0xe0>
    6468:	f107 0320 	add.w	r3, r7, #32
    646c:	f853 3c14 	ldr.w	r3, [r3, #-20]
    6470:	685b      	ldr	r3, [r3, #4]
    6472:	681b      	ldr	r3, [r3, #0]
    6474:	3310      	adds	r3, #16
    6476:	681b      	ldr	r3, [r3, #0]
    6478:	f107 0220 	add.w	r2, r7, #32
    647c:	f852 2c14 	ldr.w	r2, [r2, #-20]
    6480:	6850      	ldr	r0, [r2, #4]
    6482:	f107 0220 	add.w	r2, r7, #32
    6486:	4611      	mov	r1, r2
    6488:	f507 5280 	add.w	r2, r7, #4096	@ 0x1000
    648c:	f102 021c 	add.w	r2, r2, #28
    6490:	6812      	ldr	r2, [r2, #0]
    6492:	440a      	add	r2, r1
    6494:	3a0c      	subs	r2, #12
    6496:	7812      	ldrb	r2, [r2, #0]
    6498:	b252      	sxtb	r2, r2
    649a:	4611      	mov	r1, r2
    649c:	4798      	blx	r3
    649e:	f507 5380 	add.w	r3, r7, #4096	@ 0x1000
    64a2:	f103 031c 	add.w	r3, r3, #28
    64a6:	681b      	ldr	r3, [r3, #0]
    64a8:	3301      	adds	r3, #1
    64aa:	f507 5280 	add.w	r2, r7, #4096	@ 0x1000
    64ae:	f102 021c 	add.w	r2, r2, #28
    64b2:	6013      	str	r3, [r2, #0]
    64b4:	f507 5380 	add.w	r3, r7, #4096	@ 0x1000
    64b8:	f103 031c 	add.w	r3, r3, #28
    64bc:	681a      	ldr	r2, [r3, #0]
    64be:	f507 5380 	add.w	r3, r7, #4096	@ 0x1000
    64c2:	f103 0314 	add.w	r3, r3, #20
    64c6:	681b      	ldr	r3, [r3, #0]
    64c8:	429a      	cmp	r2, r3
    64ca:	d3cd      	bcc.n	6468 <BinaryUart::TxBinaryPacket(unsigned short, unsigned long, void const*, unsigned int) const+0x94>
		if (debug)
    64cc:	f107 0320 	add.w	r3, r7, #32
    64d0:	f853 3c14 	ldr.w	r3, [r3, #-20]
    64d4:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
    64d8:	f893 3020 	ldrb.w	r3, [r3, #32]
    64dc:	2b00      	cmp	r3, #0
    64de:	d03c      	beq.n	655a <BinaryUart::TxBinaryPacket(unsigned short, unsigned long, void const*, unsigned int) const+0x186>
			::formatf("\n\nBinary Uart: Sending packet(%u, %u): ", PayloadType, PayloadLen);
    64e0:	f107 0320 	add.w	r3, r7, #32
    64e4:	f833 3c16 	ldrh.w	r3, [r3, #-22]
    64e8:	f507 5281 	add.w	r2, r7, #4128	@ 0x1020
    64ec:	f102 0210 	add.w	r2, r2, #16
    64f0:	6812      	ldr	r2, [r2, #0]
    64f2:	4619      	mov	r1, r3
    64f4:	481c      	ldr	r0, [pc, #112]	@ (6568 <BinaryUart::TxBinaryPacket(unsigned short, unsigned long, void const*, unsigned int) const+0x194>)
    64f6:	f7fe ff03 	bl	5300 <formatf>
			for(size_t i = 0; i < PktLen; i++) { printf("%.2X:", TxBuffer[i]); }
    64fa:	2300      	movs	r3, #0
    64fc:	f507 5280 	add.w	r2, r7, #4096	@ 0x1000
    6500:	f102 0218 	add.w	r2, r2, #24
    6504:	6013      	str	r3, [r2, #0]
    6506:	e019      	b.n	653c <BinaryUart::TxBinaryPacket(unsigned short, unsigned long, void const*, unsigned int) const+0x168>
    6508:	f107 0320 	add.w	r3, r7, #32
    650c:	461a      	mov	r2, r3
    650e:	f507 5380 	add.w	r3, r7, #4096	@ 0x1000
    6512:	f103 0318 	add.w	r3, r3, #24
    6516:	681b      	ldr	r3, [r3, #0]
    6518:	4413      	add	r3, r2
    651a:	3b0c      	subs	r3, #12
    651c:	781b      	ldrb	r3, [r3, #0]
    651e:	4619      	mov	r1, r3
    6520:	4812      	ldr	r0, [pc, #72]	@ (656c <BinaryUart::TxBinaryPacket(unsigned short, unsigned long, void const*, unsigned int) const+0x198>)
    6522:	f000 fd03 	bl	6f2c <iprintf>
    6526:	f507 5380 	add.w	r3, r7, #4096	@ 0x1000
    652a:	f103 0318 	add.w	r3, r3, #24
    652e:	681b      	ldr	r3, [r3, #0]
    6530:	3301      	adds	r3, #1
    6532:	f507 5280 	add.w	r2, r7, #4096	@ 0x1000
    6536:	f102 0218 	add.w	r2, r2, #24
    653a:	6013      	str	r3, [r2, #0]
    653c:	f507 5380 	add.w	r3, r7, #4096	@ 0x1000
    6540:	f103 0318 	add.w	r3, r3, #24
    6544:	681a      	ldr	r2, [r3, #0]
    6546:	f507 5380 	add.w	r3, r7, #4096	@ 0x1000
    654a:	f103 0314 	add.w	r3, r3, #20
    654e:	681b      	ldr	r3, [r3, #0]
    6550:	429a      	cmp	r2, r3
    6552:	d3d9      	bcc.n	6508 <BinaryUart::TxBinaryPacket(unsigned short, unsigned long, void const*, unsigned int) const+0x134>
			printf("\n\n");
    6554:	4806      	ldr	r0, [pc, #24]	@ (6570 <BinaryUart::TxBinaryPacket(unsigned short, unsigned long, void const*, unsigned int) const+0x19c>)
    6556:	f000 fd8d 	bl	7074 <puts>
	}
    655a:	bf00      	nop
    655c:	f507 5781 	add.w	r7, r7, #4128	@ 0x1020
    6560:	3704      	adds	r7, #4
    6562:	46bd      	mov	sp, r7
    6564:	bd90      	pop	{r4, r7, pc}
    6566:	bf00      	nop
    6568:	0000b624 	.word	0x0000b624
    656c:	0000b64c 	.word	0x0000b64c
    6570:	0000b654 	.word	0x0000b654

00006574 <uart_pinout_fpga::uart_pinout_fpga(UartStatusRegister const*, unsigned long const*, unsigned long const*, unsigned long*, char)>:
	uart_pinout_fpga(const UartStatusRegister* statusregister, const uint32_t* readrequestregister, const uint32_t* readdataregister, uint32_t* writedataregister, const char monitorprefacechar) : 
    6574:	b580      	push	{r7, lr}
    6576:	b084      	sub	sp, #16
    6578:	af00      	add	r7, sp, #0
    657a:	60f8      	str	r0, [r7, #12]
    657c:	60b9      	str	r1, [r7, #8]
    657e:	607a      	str	r2, [r7, #4]
    6580:	603b      	str	r3, [r7, #0]
		MonitorPrefaceChar(monitorprefacechar)
    6582:	68fb      	ldr	r3, [r7, #12]
    6584:	4618      	mov	r0, r3
    6586:	f7ff f907 	bl	5798 <IUart::IUart()>
    658a:	4a0d      	ldr	r2, [pc, #52]	@ (65c0 <uart_pinout_fpga::uart_pinout_fpga(UartStatusRegister const*, unsigned long const*, unsigned long const*, unsigned long*, char)+0x4c>)
    658c:	68fb      	ldr	r3, [r7, #12]
    658e:	601a      	str	r2, [r3, #0]
		monitor(false),
    6590:	68fb      	ldr	r3, [r7, #12]
    6592:	2200      	movs	r2, #0
    6594:	711a      	strb	r2, [r3, #4]
		StatusRegister(statusregister),
    6596:	68fb      	ldr	r3, [r7, #12]
    6598:	68ba      	ldr	r2, [r7, #8]
    659a:	609a      	str	r2, [r3, #8]
		ReadRequestRegister(readrequestregister),
    659c:	68fb      	ldr	r3, [r7, #12]
    659e:	687a      	ldr	r2, [r7, #4]
    65a0:	60da      	str	r2, [r3, #12]
		ReadDataRegister(readdataregister),
    65a2:	68fb      	ldr	r3, [r7, #12]
    65a4:	683a      	ldr	r2, [r7, #0]
    65a6:	611a      	str	r2, [r3, #16]
		WriteDataRegister(writedataregister),
    65a8:	68fb      	ldr	r3, [r7, #12]
    65aa:	69ba      	ldr	r2, [r7, #24]
    65ac:	615a      	str	r2, [r3, #20]
		MonitorPrefaceChar(monitorprefacechar)
    65ae:	68fb      	ldr	r3, [r7, #12]
    65b0:	7f3a      	ldrb	r2, [r7, #28]
    65b2:	761a      	strb	r2, [r3, #24]
	{ }
    65b4:	68fb      	ldr	r3, [r7, #12]
    65b6:	4618      	mov	r0, r3
    65b8:	3710      	adds	r7, #16
    65ba:	46bd      	mov	sp, r7
    65bc:	bd80      	pop	{r7, pc}
    65be:	bf00      	nop
    65c0:	0000b75c 	.word	0x0000b75c

000065c4 <uart_pinout_fpga::~uart_pinout_fpga()>:
	virtual ~uart_pinout_fpga() { }
    65c4:	b580      	push	{r7, lr}
    65c6:	b082      	sub	sp, #8
    65c8:	af00      	add	r7, sp, #0
    65ca:	6078      	str	r0, [r7, #4]
    65cc:	4a05      	ldr	r2, [pc, #20]	@ (65e4 <uart_pinout_fpga::~uart_pinout_fpga()+0x20>)
    65ce:	687b      	ldr	r3, [r7, #4]
    65d0:	601a      	str	r2, [r3, #0]
    65d2:	687b      	ldr	r3, [r7, #4]
    65d4:	4618      	mov	r0, r3
    65d6:	f7ff f8ef 	bl	57b8 <IUart::~IUart()>
    65da:	687b      	ldr	r3, [r7, #4]
    65dc:	4618      	mov	r0, r3
    65de:	3708      	adds	r7, #8
    65e0:	46bd      	mov	sp, r7
    65e2:	bd80      	pop	{r7, pc}
    65e4:	0000b75c 	.word	0x0000b75c

000065e8 <uart_pinout_fpga::~uart_pinout_fpga()>:
    65e8:	b580      	push	{r7, lr}
    65ea:	b082      	sub	sp, #8
    65ec:	af00      	add	r7, sp, #0
    65ee:	6078      	str	r0, [r7, #4]
    65f0:	6878      	ldr	r0, [r7, #4]
    65f2:	f7ff ffe7 	bl	65c4 <uart_pinout_fpga::~uart_pinout_fpga()>
    65f6:	211c      	movs	r1, #28
    65f8:	6878      	ldr	r0, [r7, #4]
    65fa:	f002 fdf7 	bl	91ec <operator delete(void*, unsigned int)>
    65fe:	687b      	ldr	r3, [r7, #4]
    6600:	4618      	mov	r0, r3
    6602:	3708      	adds	r7, #8
    6604:	46bd      	mov	sp, r7
    6606:	bd80      	pop	{r7, pc}

00006608 <uart_pinout_fpga::dataready() const>:
	virtual bool dataready() const override
    6608:	b480      	push	{r7}
    660a:	b083      	sub	sp, #12
    660c:	af00      	add	r7, sp, #0
    660e:	6078      	str	r0, [r7, #4]
		if (NULL == StatusRegister) { return(false); }
    6610:	687b      	ldr	r3, [r7, #4]
    6612:	689b      	ldr	r3, [r3, #8]
    6614:	2b00      	cmp	r3, #0
    6616:	d101      	bne.n	661c <uart_pinout_fpga::dataready() const+0x14>
    6618:	2300      	movs	r3, #0
    661a:	e00a      	b.n	6632 <uart_pinout_fpga::dataready() const+0x2a>
		return(0 == StatusRegister->RxFifoEmpty);
    661c:	687b      	ldr	r3, [r7, #4]
    661e:	689b      	ldr	r3, [r3, #8]
    6620:	781b      	ldrb	r3, [r3, #0]
    6622:	f003 0301 	and.w	r3, r3, #1
    6626:	b2db      	uxtb	r3, r3
    6628:	2b00      	cmp	r3, #0
    662a:	bf0c      	ite	eq
    662c:	2301      	moveq	r3, #1
    662e:	2300      	movne	r3, #0
    6630:	b2db      	uxtb	r3, r3
	}
    6632:	4618      	mov	r0, r3
    6634:	370c      	adds	r7, #12
    6636:	46bd      	mov	sp, r7
    6638:	bc80      	pop	{r7}
    663a:	4770      	bx	lr

0000663c <uart_pinout_fpga::getcqq()>:
	virtual char getcqq() override
    663c:	b580      	push	{r7, lr}
    663e:	b084      	sub	sp, #16
    6640:	af00      	add	r7, sp, #0
    6642:	6078      	str	r0, [r7, #4]
		if ( (NULL == ReadRequestRegister) || (NULL == ReadDataRegister) ) { return(false); }
    6644:	687b      	ldr	r3, [r7, #4]
    6646:	68db      	ldr	r3, [r3, #12]
    6648:	2b00      	cmp	r3, #0
    664a:	d003      	beq.n	6654 <uart_pinout_fpga::getcqq()+0x18>
    664c:	687b      	ldr	r3, [r7, #4]
    664e:	691b      	ldr	r3, [r3, #16]
    6650:	2b00      	cmp	r3, #0
    6652:	d101      	bne.n	6658 <uart_pinout_fpga::getcqq()+0x1c>
    6654:	2300      	movs	r3, #0
    6656:	e018      	b.n	668a <uart_pinout_fpga::getcqq()+0x4e>
		volatile uint32_t c = 0;
    6658:	2300      	movs	r3, #0
    665a:	60fb      	str	r3, [r7, #12]
		c = *ReadRequestRegister; //Initiate the read from the fifo (this sends back 0xBAADC0DE if you care to check)
    665c:	687b      	ldr	r3, [r7, #4]
    665e:	68db      	ldr	r3, [r3, #12]
    6660:	681b      	ldr	r3, [r3, #0]
    6662:	60fb      	str	r3, [r7, #12]
		c = *ReadDataRegister;
    6664:	687b      	ldr	r3, [r7, #4]
    6666:	691b      	ldr	r3, [r3, #16]
    6668:	681b      	ldr	r3, [r3, #0]
    666a:	60fb      	str	r3, [r7, #12]
		if (monitor) { formatf("%c%.2x", MonitorPrefaceChar, c); }
    666c:	687b      	ldr	r3, [r7, #4]
    666e:	791b      	ldrb	r3, [r3, #4]
    6670:	2b00      	cmp	r3, #0
    6672:	d008      	beq.n	6686 <uart_pinout_fpga::getcqq()+0x4a>
    6674:	687b      	ldr	r3, [r7, #4]
    6676:	f993 3018 	ldrsb.w	r3, [r3, #24]
    667a:	4619      	mov	r1, r3
    667c:	68fb      	ldr	r3, [r7, #12]
    667e:	461a      	mov	r2, r3
    6680:	4804      	ldr	r0, [pc, #16]	@ (6694 <uart_pinout_fpga::getcqq()+0x58>)
    6682:	f7fe fe3d 	bl	5300 <formatf>
		return((char)(c));
    6686:	68fb      	ldr	r3, [r7, #12]
    6688:	b25b      	sxtb	r3, r3
	}
    668a:	4618      	mov	r0, r3
    668c:	3710      	adds	r7, #16
    668e:	46bd      	mov	sp, r7
    6690:	bd80      	pop	{r7, pc}
    6692:	bf00      	nop
    6694:	0000b658 	.word	0x0000b658

00006698 <uart_pinout_fpga::putcqq(char)>:
	virtual char putcqq(char c) override
    6698:	b480      	push	{r7}
    669a:	b083      	sub	sp, #12
    669c:	af00      	add	r7, sp, #0
    669e:	6078      	str	r0, [r7, #4]
    66a0:	460b      	mov	r3, r1
    66a2:	70fb      	strb	r3, [r7, #3]
		if (NULL != WriteDataRegister) { *WriteDataRegister = c; }
    66a4:	687b      	ldr	r3, [r7, #4]
    66a6:	695b      	ldr	r3, [r3, #20]
    66a8:	2b00      	cmp	r3, #0
    66aa:	d004      	beq.n	66b6 <uart_pinout_fpga::putcqq(char)+0x1e>
    66ac:	687b      	ldr	r3, [r7, #4]
    66ae:	695b      	ldr	r3, [r3, #20]
    66b0:	f997 2003 	ldrsb.w	r2, [r7, #3]
    66b4:	601a      	str	r2, [r3, #0]
		return(c);
    66b6:	f997 3003 	ldrsb.w	r3, [r7, #3]
	}
    66ba:	4618      	mov	r0, r3
    66bc:	370c      	adds	r7, #12
    66be:	46bd      	mov	sp, r7
    66c0:	bc80      	pop	{r7}
    66c2:	4770      	bx	lr

000066c4 <uart_pinout_fpga::flushoutput()>:
	virtual void flushoutput() override { } // if (FW) { FW->UartTxStatusRegister = 0; } //Need to make tx & rx status registers seperate...
    66c4:	b480      	push	{r7}
    66c6:	b083      	sub	sp, #12
    66c8:	af00      	add	r7, sp, #0
    66ca:	6078      	str	r0, [r7, #4]
    66cc:	bf00      	nop
    66ce:	370c      	adds	r7, #12
    66d0:	46bd      	mov	sp, r7
    66d2:	bc80      	pop	{r7}
    66d4:	4770      	bx	lr

000066d6 <uart_pinout_fpga::purgeinput()>:
	virtual void purgeinput() override { } // if (FW) { FW->UartRxStatusRegister = 0; }
    66d6:	b480      	push	{r7}
    66d8:	b083      	sub	sp, #12
    66da:	af00      	add	r7, sp, #0
    66dc:	6078      	str	r0, [r7, #4]
    66de:	bf00      	nop
    66e0:	370c      	adds	r7, #12
    66e2:	46bd      	mov	sp, r7
    66e4:	bc80      	pop	{r7}
    66e6:	4770      	bx	lr

000066e8 <uart_pinout_fpga::isopen() const>:
	virtual bool isopen() const override { return(true); }
    66e8:	b480      	push	{r7}
    66ea:	b083      	sub	sp, #12
    66ec:	af00      	add	r7, sp, #0
    66ee:	6078      	str	r0, [r7, #4]
    66f0:	2301      	movs	r3, #1
    66f2:	4618      	mov	r0, r3
    66f4:	370c      	adds	r7, #12
    66f6:	46bd      	mov	sp, r7
    66f8:	bc80      	pop	{r7}
    66fa:	4770      	bx	lr

000066fc <FPGABinaryUartCallbacks::FPGABinaryUartCallbacks()>:

//uart_pinout_fpga FPGAUartPinout;

struct FPGABinaryUartCallbacks : public BinaryUartCallbacks
{
	FPGABinaryUartCallbacks() { }
    66fc:	b580      	push	{r7, lr}
    66fe:	b082      	sub	sp, #8
    6700:	af00      	add	r7, sp, #0
    6702:	6078      	str	r0, [r7, #4]
    6704:	687b      	ldr	r3, [r7, #4]
    6706:	4618      	mov	r0, r3
    6708:	f7ff f8aa 	bl	5860 <BinaryUartCallbacks::BinaryUartCallbacks()>
    670c:	4a03      	ldr	r2, [pc, #12]	@ (671c <FPGABinaryUartCallbacks::FPGABinaryUartCallbacks()+0x20>)
    670e:	687b      	ldr	r3, [r7, #4]
    6710:	601a      	str	r2, [r3, #0]
    6712:	687b      	ldr	r3, [r7, #4]
    6714:	4618      	mov	r0, r3
    6716:	3708      	adds	r7, #8
    6718:	46bd      	mov	sp, r7
    671a:	bd80      	pop	{r7, pc}
    671c:	0000b73c 	.word	0x0000b73c

00006720 <FPGABinaryUartCallbacks::~FPGABinaryUartCallbacks()>:
	virtual ~FPGABinaryUartCallbacks() { }
    6720:	b580      	push	{r7, lr}
    6722:	b082      	sub	sp, #8
    6724:	af00      	add	r7, sp, #0
    6726:	6078      	str	r0, [r7, #4]
    6728:	4a05      	ldr	r2, [pc, #20]	@ (6740 <FPGABinaryUartCallbacks::~FPGABinaryUartCallbacks()+0x20>)
    672a:	687b      	ldr	r3, [r7, #4]
    672c:	601a      	str	r2, [r3, #0]
    672e:	687b      	ldr	r3, [r7, #4]
    6730:	4618      	mov	r0, r3
    6732:	f7ff f8a5 	bl	5880 <BinaryUartCallbacks::~BinaryUartCallbacks()>
    6736:	687b      	ldr	r3, [r7, #4]
    6738:	4618      	mov	r0, r3
    673a:	3708      	adds	r7, #8
    673c:	46bd      	mov	sp, r7
    673e:	bd80      	pop	{r7, pc}
    6740:	0000b73c 	.word	0x0000b73c

00006744 <FPGABinaryUartCallbacks::~FPGABinaryUartCallbacks()>:
    6744:	b580      	push	{r7, lr}
    6746:	b082      	sub	sp, #8
    6748:	af00      	add	r7, sp, #0
    674a:	6078      	str	r0, [r7, #4]
    674c:	6878      	ldr	r0, [r7, #4]
    674e:	f7ff ffe7 	bl	6720 <FPGABinaryUartCallbacks::~FPGABinaryUartCallbacks()>
    6752:	2104      	movs	r1, #4
    6754:	6878      	ldr	r0, [r7, #4]
    6756:	f002 fd49 	bl	91ec <operator delete(void*, unsigned int)>
    675a:	687b      	ldr	r3, [r7, #4]
    675c:	4618      	mov	r0, r3
    675e:	3708      	adds	r7, #8
    6760:	46bd      	mov	sp, r7
    6762:	bd80      	pop	{r7, pc}

00006764 <FPGABinaryUartCallbacks::InvalidPacket(unsigned char const*, unsigned int const&)>:
	
	//Malformed/corrupted packet handler:
	virtual void InvalidPacket(const uint8_t* Buffer, const size_t& BufferLen)
    6764:	b580      	push	{r7, lr}
    6766:	b086      	sub	sp, #24
    6768:	af00      	add	r7, sp, #0
    676a:	60f8      	str	r0, [r7, #12]
    676c:	60b9      	str	r1, [r7, #8]
    676e:	607a      	str	r2, [r7, #4]
	{ 
		if ( (NULL == Buffer) || (BufferLen < 1) ) { formatf("\nFPGAUartCallbacks: NULL(%u) InvalidPacket!\n\n", BufferLen); return; }
    6770:	68bb      	ldr	r3, [r7, #8]
    6772:	2b00      	cmp	r3, #0
    6774:	d003      	beq.n	677e <FPGABinaryUartCallbacks::InvalidPacket(unsigned char const*, unsigned int const&)+0x1a>
    6776:	687b      	ldr	r3, [r7, #4]
    6778:	681b      	ldr	r3, [r3, #0]
    677a:	2b00      	cmp	r3, #0
    677c:	d106      	bne.n	678c <FPGABinaryUartCallbacks::InvalidPacket(unsigned char const*, unsigned int const&)+0x28>
    677e:	687b      	ldr	r3, [r7, #4]
    6780:	681b      	ldr	r3, [r3, #0]
    6782:	4619      	mov	r1, r3
    6784:	4813      	ldr	r0, [pc, #76]	@ (67d4 <FPGABinaryUartCallbacks::InvalidPacket(unsigned char const*, unsigned int const&)+0x70>)
    6786:	f7fe fdbb 	bl	5300 <formatf>
    678a:	e01f      	b.n	67cc <FPGABinaryUartCallbacks::InvalidPacket(unsigned char const*, unsigned int const&)+0x68>
	
		size_t len = BufferLen;
    678c:	687b      	ldr	r3, [r7, #4]
    678e:	681b      	ldr	r3, [r3, #0]
    6790:	617b      	str	r3, [r7, #20]
		if (len > 32) { len = 32; }
    6792:	697b      	ldr	r3, [r7, #20]
    6794:	2b20      	cmp	r3, #32
    6796:	d901      	bls.n	679c <FPGABinaryUartCallbacks::InvalidPacket(unsigned char const*, unsigned int const&)+0x38>
    6798:	2320      	movs	r3, #32
    679a:	617b      	str	r3, [r7, #20]
		printf("\nFPGAUartCallbacks: InvalidPacket! contents: :");
    679c:	480e      	ldr	r0, [pc, #56]	@ (67d8 <FPGABinaryUartCallbacks::InvalidPacket(unsigned char const*, unsigned int const&)+0x74>)
    679e:	f000 fbc5 	bl	6f2c <iprintf>
		for(size_t i = 0; i < len; i++) { printf("%.2X:", Buffer[i]); }
    67a2:	2300      	movs	r3, #0
    67a4:	613b      	str	r3, [r7, #16]
    67a6:	e00a      	b.n	67be <FPGABinaryUartCallbacks::InvalidPacket(unsigned char const*, unsigned int const&)+0x5a>
    67a8:	68ba      	ldr	r2, [r7, #8]
    67aa:	693b      	ldr	r3, [r7, #16]
    67ac:	4413      	add	r3, r2
    67ae:	781b      	ldrb	r3, [r3, #0]
    67b0:	4619      	mov	r1, r3
    67b2:	480a      	ldr	r0, [pc, #40]	@ (67dc <FPGABinaryUartCallbacks::InvalidPacket(unsigned char const*, unsigned int const&)+0x78>)
    67b4:	f000 fbba 	bl	6f2c <iprintf>
    67b8:	693b      	ldr	r3, [r7, #16]
    67ba:	3301      	adds	r3, #1
    67bc:	613b      	str	r3, [r7, #16]
    67be:	693a      	ldr	r2, [r7, #16]
    67c0:	697b      	ldr	r3, [r7, #20]
    67c2:	429a      	cmp	r2, r3
    67c4:	d3f0      	bcc.n	67a8 <FPGABinaryUartCallbacks::InvalidPacket(unsigned char const*, unsigned int const&)+0x44>
		printf("\n\n");
    67c6:	4806      	ldr	r0, [pc, #24]	@ (67e0 <FPGABinaryUartCallbacks::InvalidPacket(unsigned char const*, unsigned int const&)+0x7c>)
    67c8:	f000 fc54 	bl	7074 <puts>
	}
    67cc:	3718      	adds	r7, #24
    67ce:	46bd      	mov	sp, r7
    67d0:	bd80      	pop	{r7, pc}
    67d2:	bf00      	nop
    67d4:	0000b660 	.word	0x0000b660
    67d8:	0000b690 	.word	0x0000b690
    67dc:	0000b64c 	.word	0x0000b64c
    67e0:	0000b654 	.word	0x0000b654

000067e4 <FPGABinaryUartCallbacks::UnHandledPacket(IPacket const*, unsigned int const&)>:
	
	//Packet with no matching command handler:
	virtual void UnHandledPacket(const IPacket* Packet, const size_t& PacketLen)
    67e4:	b580      	push	{r7, lr}
    67e6:	b086      	sub	sp, #24
    67e8:	af00      	add	r7, sp, #0
    67ea:	60f8      	str	r0, [r7, #12]
    67ec:	60b9      	str	r1, [r7, #8]
    67ee:	607a      	str	r2, [r7, #4]
	{ 
		if ( (NULL == Packet) || (PacketLen < sizeof(CGraphPacketHeader)) ) { printf("\nSocketUartCallbacks: NULL(%u) UnHandledPacket!\n\n", PacketLen); return; }
    67f0:	68bb      	ldr	r3, [r7, #8]
    67f2:	2b00      	cmp	r3, #0
    67f4:	d003      	beq.n	67fe <FPGABinaryUartCallbacks::UnHandledPacket(IPacket const*, unsigned int const&)+0x1a>
    67f6:	687b      	ldr	r3, [r7, #4]
    67f8:	681b      	ldr	r3, [r3, #0]
    67fa:	2b07      	cmp	r3, #7
    67fc:	d806      	bhi.n	680c <FPGABinaryUartCallbacks::UnHandledPacket(IPacket const*, unsigned int const&)+0x28>
    67fe:	687b      	ldr	r3, [r7, #4]
    6800:	681b      	ldr	r3, [r3, #0]
    6802:	4619      	mov	r1, r3
    6804:	480a      	ldr	r0, [pc, #40]	@ (6830 <FPGABinaryUartCallbacks::UnHandledPacket(IPacket const*, unsigned int const&)+0x4c>)
    6806:	f000 fb91 	bl	6f2c <iprintf>
    680a:	e00d      	b.n	6828 <FPGABinaryUartCallbacks::UnHandledPacket(IPacket const*, unsigned int const&)+0x44>
		
		const CGraphPacketHeader* Header = reinterpret_cast<const CGraphPacketHeader*>(Packet);
    680c:	68bb      	ldr	r3, [r7, #8]
    680e:	617b      	str	r3, [r7, #20]
		printf("\nFPGAUartCallbacks: Unhandled packet(%u): ", PacketLen);
    6810:	687b      	ldr	r3, [r7, #4]
    6812:	681b      	ldr	r3, [r3, #0]
    6814:	4619      	mov	r1, r3
    6816:	4807      	ldr	r0, [pc, #28]	@ (6834 <FPGABinaryUartCallbacks::UnHandledPacket(IPacket const*, unsigned int const&)+0x50>)
    6818:	f000 fb88 	bl	6f2c <iprintf>
		Header->formatf();
    681c:	6978      	ldr	r0, [r7, #20]
    681e:	f7fe fddd 	bl	53dc <CGraphPacketHeader::formatf() const>
		printf("\n\n");
    6822:	4805      	ldr	r0, [pc, #20]	@ (6838 <FPGABinaryUartCallbacks::UnHandledPacket(IPacket const*, unsigned int const&)+0x54>)
    6824:	f000 fc26 	bl	7074 <puts>
	}
    6828:	3718      	adds	r7, #24
    682a:	46bd      	mov	sp, r7
    682c:	bd80      	pop	{r7, pc}
    682e:	bf00      	nop
    6830:	0000b6c0 	.word	0x0000b6c0
    6834:	0000b6f4 	.word	0x0000b6f4
    6838:	0000b654 	.word	0x0000b654

0000683c <FPGABinaryUartCallbacks::BufferOverflow(unsigned char const*, unsigned int const&)>:
	
	//In case we need to look at every packet that goes by...
	//~ virtual void EveryPacket(const IPacket& Packet, const size_t& PacketLen) { }
	
	//We just wanna see if this is happening, not much to do about it
	virtual void BufferOverflow(const uint8_t* Buffer, const size_t& BufferLen) 
    683c:	b480      	push	{r7}
    683e:	b085      	sub	sp, #20
    6840:	af00      	add	r7, sp, #0
    6842:	60f8      	str	r0, [r7, #12]
    6844:	60b9      	str	r1, [r7, #8]
    6846:	607a      	str	r2, [r7, #4]
	{ 
		//~ printf("\nFPGABinaryUartCallbacks: BufferOverflow(%zu)!\n", BufferLen);
	}
    6848:	bf00      	nop
    684a:	3714      	adds	r7, #20
    684c:	46bd      	mov	sp, r7
    684e:	bc80      	pop	{r7}
    6850:	4770      	bx	lr

00006852 <RTSCallback::RTS()>:
const char CHAR_ESC = 0x1B;
const char CHAR_TAB = 0x09;

struct RTSCallback
{
	virtual bool RTS() { return(true); }
    6852:	b480      	push	{r7}
    6854:	b083      	sub	sp, #12
    6856:	af00      	add	r7, sp, #0
    6858:	6078      	str	r0, [r7, #4]
    685a:	2301      	movs	r3, #1
    685c:	4618      	mov	r0, r3
    685e:	370c      	adds	r7, #12
    6860:	46bd      	mov	sp, r7
    6862:	bc80      	pop	{r7}
    6864:	4770      	bx	lr
	...

00006868 <RTSCallback::~RTSCallback()>:
	virtual ~RTSCallback() { }
    6868:	b480      	push	{r7}
    686a:	b083      	sub	sp, #12
    686c:	af00      	add	r7, sp, #0
    686e:	6078      	str	r0, [r7, #4]
    6870:	4a04      	ldr	r2, [pc, #16]	@ (6884 <RTSCallback::~RTSCallback()+0x1c>)
    6872:	687b      	ldr	r3, [r7, #4]
    6874:	601a      	str	r2, [r3, #0]
    6876:	687b      	ldr	r3, [r7, #4]
    6878:	4618      	mov	r0, r3
    687a:	370c      	adds	r7, #12
    687c:	46bd      	mov	sp, r7
    687e:	bc80      	pop	{r7}
    6880:	4770      	bx	lr
    6882:	bf00      	nop
    6884:	0000b728 	.word	0x0000b728

00006888 <RTSCallback::~RTSCallback()>:
    6888:	b580      	push	{r7, lr}
    688a:	b082      	sub	sp, #8
    688c:	af00      	add	r7, sp, #0
    688e:	6078      	str	r0, [r7, #4]
    6890:	6878      	ldr	r0, [r7, #4]
    6892:	f7ff ffe9 	bl	6868 <RTSCallback::~RTSCallback()>
    6896:	2104      	movs	r1, #4
    6898:	6878      	ldr	r0, [r7, #4]
    689a:	f002 fca7 	bl	91ec <operator delete(void*, unsigned int)>
    689e:	687b      	ldr	r3, [r7, #4]
    68a0:	4618      	mov	r0, r3
    68a2:	3708      	adds	r7, #8
    68a4:	46bd      	mov	sp, r7
    68a6:	bd80      	pop	{r7, pc}

000068a8 <stdio_hook_putc>:
{	
	unsigned long long fclk_for_delay_loops = 102000000;

	//This code is to make "syscalls.c" replace vendor's "newlib_stubs.c" and make printf() and friends connect to a real serial port in our actual hardware! Only useful if we can compile our own code from makefile and replace vendor's "softconsole" version...
	int stdio_hook_putc(int c) 
	{ 
    68a8:	b580      	push	{r7, lr}
    68aa:	b082      	sub	sp, #8
    68ac:	af00      	add	r7, sp, #0
    68ae:	6078      	str	r0, [r7, #4]
		FPGAUartPinout0.putcqq(c); 
    68b0:	687b      	ldr	r3, [r7, #4]
    68b2:	b25b      	sxtb	r3, r3
    68b4:	4619      	mov	r1, r3
    68b6:	4804      	ldr	r0, [pc, #16]	@ (68c8 <stdio_hook_putc+0x20>)
    68b8:	f7ff feee 	bl	6698 <uart_pinout_fpga::putcqq(char)>
		//FPGAUartPinoutUsb.putcqq(c);
		return(c);
    68bc:	687b      	ldr	r3, [r7, #4]
	}
    68be:	4618      	mov	r0, r3
    68c0:	3708      	adds	r7, #8
    68c2:	46bd      	mov	sp, r7
    68c4:	bd80      	pop	{r7, pc}
    68c6:	bf00      	nop
    68c8:	20001528 	.word	0x20001528

000068cc <Process()>:
        putchar(c);
    }
};

bool Process()
{
    68cc:	b580      	push	{r7, lr}
    68ce:	b082      	sub	sp, #8
    68d0:	af00      	add	r7, sp, #0
    bool Bored = true;
    68d2:	2301      	movs	r3, #1
    68d4:	71fb      	strb	r3, [r7, #7]
		//~ if (UsbUartAscii.remotedataready()) { FPGAUartPinoutUsb.putcqq(UsbUartAscii.remotegetcqq()); }
		//~ if (UsbUartBinary.remotedataready()) { FPGAUartPinoutUsb.putcqq(UsbUartBinary.remotegetcqq()); }
	//~ }
	
        //if (FpgaUartParser3.Process()) { Bored = false; }    
    if (FpgaUartParser2.Process()) { Bored = false; }
    68d6:	480a      	ldr	r0, [pc, #40]	@ (6900 <Process()+0x34>)
    68d8:	f7ff f8d8 	bl	5a8c <BinaryUart::Process()>
    68dc:	4603      	mov	r3, r0
    68de:	2b00      	cmp	r3, #0
    68e0:	d001      	beq.n	68e6 <Process()+0x1a>
    68e2:	2300      	movs	r3, #0
    68e4:	71fb      	strb	r3, [r7, #7]
    //if (FpgaUartParser1.Process()) { Bored = false; }
    if (FpgaUartParser0.Process()) { Bored = false; }
    68e6:	4807      	ldr	r0, [pc, #28]	@ (6904 <Process()+0x38>)
    68e8:	f7ff f8d0 	bl	5a8c <BinaryUart::Process()>
    68ec:	4603      	mov	r3, r0
    68ee:	2b00      	cmp	r3, #0
    68f0:	d001      	beq.n	68f6 <Process()+0x2a>
    68f2:	2300      	movs	r3, #0
    68f4:	71fb      	strb	r3, [r7, #7]
//    uint32_t* DummyData;
//    DummyData = &dval;
//    FpgaUartParser0.TxBinaryPacket(CGraphPayloadTypeDMDac, 0, DummyData, sizeof(uint32_t));
//    FPGAUartPinout0.putcqq('h'); 

    return(Bored);
    68f6:	79fb      	ldrb	r3, [r7, #7]
}
    68f8:	4618      	mov	r0, r3
    68fa:	3708      	adds	r7, #8
    68fc:	46bd      	mov	sp, r7
    68fe:	bd80      	pop	{r7, pc}
    6900:	200035f0 	.word	0x200035f0
    6904:	20001580 	.word	0x20001580

00006908 <main>:

/*==============================================================================
 * main function.
 */
int main(int argc, char *argv[])
{
    6908:	b580      	push	{r7, lr}
    690a:	b082      	sub	sp, #8
    690c:	af00      	add	r7, sp, #0
    690e:	6078      	str	r0, [r7, #4]
    6910:	6039      	str	r1, [r7, #0]
//
//      //give up our timeslice so as not to bog the system:
//      if (Bored) {
//        delayus(100);
//      }
      Process();
    6912:	f7ff ffdb 	bl	68cc <Process()>
    6916:	e7fc      	b.n	6912 <main+0xa>

00006918 <BinaryUart::~BinaryUart()>:
struct BinaryUart : IUartParser
    6918:	b580      	push	{r7, lr}
    691a:	b082      	sub	sp, #8
    691c:	af00      	add	r7, sp, #0
    691e:	6078      	str	r0, [r7, #4]
    6920:	4a05      	ldr	r2, [pc, #20]	@ (6938 <BinaryUart::~BinaryUart()+0x20>)
    6922:	687b      	ldr	r3, [r7, #4]
    6924:	601a      	str	r2, [r3, #0]
    6926:	687b      	ldr	r3, [r7, #4]
    6928:	4618      	mov	r0, r3
    692a:	f7fe ff79 	bl	5820 <IUartParser::~IUartParser()>
    692e:	687b      	ldr	r3, [r7, #4]
    6930:	4618      	mov	r0, r3
    6932:	3708      	adds	r7, #8
    6934:	46bd      	mov	sp, r7
    6936:	bd80      	pop	{r7, pc}
    6938:	0000b784 	.word	0x0000b784

0000693c <BinaryUart::~BinaryUart()>:
    693c:	b580      	push	{r7, lr}
    693e:	b082      	sub	sp, #8
    6940:	af00      	add	r7, sp, #0
    6942:	6078      	str	r0, [r7, #4]
    6944:	6878      	ldr	r0, [r7, #4]
    6946:	f7ff ffe7 	bl	6918 <BinaryUart::~BinaryUart()>
    694a:	f241 0138 	movw	r1, #4152	@ 0x1038
    694e:	6878      	ldr	r0, [r7, #4]
    6950:	f002 fc4c 	bl	91ec <operator delete(void*, unsigned int)>
    6954:	687b      	ldr	r3, [r7, #4]
    6956:	4618      	mov	r0, r3
    6958:	3708      	adds	r7, #8
    695a:	46bd      	mov	sp, r7
    695c:	bd80      	pop	{r7, pc}
	...

00006960 <__static_initialization_and_destruction_0()>:
    }
    return(0);
}
    6960:	b590      	push	{r4, r7, lr}
    6962:	b087      	sub	sp, #28
    6964:	af06      	add	r7, sp, #24
} PacketCallbacks;
    6966:	4844      	ldr	r0, [pc, #272]	@ (6a78 <__static_initialization_and_destruction_0()+0x118>)
    6968:	f7ff fec8 	bl	66fc <FPGABinaryUartCallbacks::FPGABinaryUartCallbacks()>
CGraphPacket FPGAUartProtocol;
    696c:	4843      	ldr	r0, [pc, #268]	@ (6a7c <__static_initialization_and_destruction_0()+0x11c>)
    696e:	f7fe fd4d 	bl	540c <CGraphPacket::CGraphPacket()>
uart_pinout_fpga FPGAUartPinout0(&(DM->UartStatusRegister0), &(DM->UartFifo0), &(DM->UartFifo0ReadData), &(DM->UartFifo0), '~');
    6972:	4b43      	ldr	r3, [pc, #268]	@ (6a80 <__static_initialization_and_destruction_0()+0x120>)
    6974:	681b      	ldr	r3, [r3, #0]
    6976:	f103 0168 	add.w	r1, r3, #104	@ 0x68
    697a:	4b41      	ldr	r3, [pc, #260]	@ (6a80 <__static_initialization_and_destruction_0()+0x120>)
    697c:	681b      	ldr	r3, [r3, #0]
    697e:	f103 0264 	add.w	r2, r3, #100	@ 0x64
    6982:	4b3f      	ldr	r3, [pc, #252]	@ (6a80 <__static_initialization_and_destruction_0()+0x120>)
    6984:	681b      	ldr	r3, [r3, #0]
    6986:	f103 006c 	add.w	r0, r3, #108	@ 0x6c
    698a:	4b3d      	ldr	r3, [pc, #244]	@ (6a80 <__static_initialization_and_destruction_0()+0x120>)
    698c:	681b      	ldr	r3, [r3, #0]
    698e:	3364      	adds	r3, #100	@ 0x64
    6990:	247e      	movs	r4, #126	@ 0x7e
    6992:	9401      	str	r4, [sp, #4]
    6994:	9300      	str	r3, [sp, #0]
    6996:	4603      	mov	r3, r0
    6998:	483a      	ldr	r0, [pc, #232]	@ (6a84 <__static_initialization_and_destruction_0()+0x124>)
    699a:	f7ff fdeb 	bl	6574 <uart_pinout_fpga::uart_pinout_fpga(UartStatusRegister const*, unsigned long const*, unsigned long const*, unsigned long*, char)>
uart_pinout_fpga FPGAUartPinout1(&(DM->UartStatusRegister1), &(DM->UartFifo1), &(DM->UartFifo1ReadData), &(DM->UartFifo1), '!');
    699e:	4b38      	ldr	r3, [pc, #224]	@ (6a80 <__static_initialization_and_destruction_0()+0x120>)
    69a0:	681b      	ldr	r3, [r3, #0]
    69a2:	f103 0174 	add.w	r1, r3, #116	@ 0x74
    69a6:	4b36      	ldr	r3, [pc, #216]	@ (6a80 <__static_initialization_and_destruction_0()+0x120>)
    69a8:	681b      	ldr	r3, [r3, #0]
    69aa:	f103 0270 	add.w	r2, r3, #112	@ 0x70
    69ae:	4b34      	ldr	r3, [pc, #208]	@ (6a80 <__static_initialization_and_destruction_0()+0x120>)
    69b0:	681b      	ldr	r3, [r3, #0]
    69b2:	f103 0078 	add.w	r0, r3, #120	@ 0x78
    69b6:	4b32      	ldr	r3, [pc, #200]	@ (6a80 <__static_initialization_and_destruction_0()+0x120>)
    69b8:	681b      	ldr	r3, [r3, #0]
    69ba:	3370      	adds	r3, #112	@ 0x70
    69bc:	2421      	movs	r4, #33	@ 0x21
    69be:	9401      	str	r4, [sp, #4]
    69c0:	9300      	str	r3, [sp, #0]
    69c2:	4603      	mov	r3, r0
    69c4:	4830      	ldr	r0, [pc, #192]	@ (6a88 <__static_initialization_and_destruction_0()+0x128>)
    69c6:	f7ff fdd5 	bl	6574 <uart_pinout_fpga::uart_pinout_fpga(UartStatusRegister const*, unsigned long const*, unsigned long const*, unsigned long*, char)>
uart_pinout_fpga FPGAUartPinout2(&(DM->UartStatusRegister2), &(DM->UartFifo2), &(DM->UartFifo2ReadData), &(DM->UartFifo2), '@');
    69ca:	4b2d      	ldr	r3, [pc, #180]	@ (6a80 <__static_initialization_and_destruction_0()+0x120>)
    69cc:	681b      	ldr	r3, [r3, #0]
    69ce:	f103 0180 	add.w	r1, r3, #128	@ 0x80
    69d2:	4b2b      	ldr	r3, [pc, #172]	@ (6a80 <__static_initialization_and_destruction_0()+0x120>)
    69d4:	681b      	ldr	r3, [r3, #0]
    69d6:	f103 027c 	add.w	r2, r3, #124	@ 0x7c
    69da:	4b29      	ldr	r3, [pc, #164]	@ (6a80 <__static_initialization_and_destruction_0()+0x120>)
    69dc:	681b      	ldr	r3, [r3, #0]
    69de:	f103 0084 	add.w	r0, r3, #132	@ 0x84
    69e2:	4b27      	ldr	r3, [pc, #156]	@ (6a80 <__static_initialization_and_destruction_0()+0x120>)
    69e4:	681b      	ldr	r3, [r3, #0]
    69e6:	337c      	adds	r3, #124	@ 0x7c
    69e8:	2440      	movs	r4, #64	@ 0x40
    69ea:	9401      	str	r4, [sp, #4]
    69ec:	9300      	str	r3, [sp, #0]
    69ee:	4603      	mov	r3, r0
    69f0:	4826      	ldr	r0, [pc, #152]	@ (6a8c <__static_initialization_and_destruction_0()+0x12c>)
    69f2:	f7ff fdbf 	bl	6574 <uart_pinout_fpga::uart_pinout_fpga(UartStatusRegister const*, unsigned long const*, unsigned long const*, unsigned long*, char)>
BinaryUart FpgaUartParser0(FPGAUartPinout0, FPGAUartProtocol, BinaryCmds, NumBinaryCmds, PacketCallbacks, false); // No serial number given, so Invalid is used by default
    69f6:	4b26      	ldr	r3, [pc, #152]	@ (6a90 <__static_initialization_and_destruction_0()+0x130>)
    69f8:	781b      	ldrb	r3, [r3, #0]
    69fa:	4619      	mov	r1, r3
    69fc:	f04f 32ff 	mov.w	r2, #4294967295
    6a00:	f04f 33ff 	mov.w	r3, #4294967295
    6a04:	e9cd 2304 	strd	r2, r3, [sp, #16]
    6a08:	2300      	movs	r3, #0
    6a0a:	9302      	str	r3, [sp, #8]
    6a0c:	4b1a      	ldr	r3, [pc, #104]	@ (6a78 <__static_initialization_and_destruction_0()+0x118>)
    6a0e:	9301      	str	r3, [sp, #4]
    6a10:	9100      	str	r1, [sp, #0]
    6a12:	4b20      	ldr	r3, [pc, #128]	@ (6a94 <__static_initialization_and_destruction_0()+0x134>)
    6a14:	4a19      	ldr	r2, [pc, #100]	@ (6a7c <__static_initialization_and_destruction_0()+0x11c>)
    6a16:	491b      	ldr	r1, [pc, #108]	@ (6a84 <__static_initialization_and_destruction_0()+0x124>)
    6a18:	481f      	ldr	r0, [pc, #124]	@ (6a98 <__static_initialization_and_destruction_0()+0x138>)
    6a1a:	f7fe ff7d 	bl	5918 <BinaryUart::BinaryUart(IUart&, IPacket&, BinaryCmd const*, unsigned int, BinaryUartCallbacks&, bool, unsigned long long)>
BinaryUart FpgaUartParser1(FPGAUartPinout1, FPGAUartProtocol, BinaryCmds, NumBinaryCmds, PacketCallbacks, false); // No serial number given, so Invalid is used by default
    6a1e:	4b1c      	ldr	r3, [pc, #112]	@ (6a90 <__static_initialization_and_destruction_0()+0x130>)
    6a20:	781b      	ldrb	r3, [r3, #0]
    6a22:	4619      	mov	r1, r3
    6a24:	f04f 32ff 	mov.w	r2, #4294967295
    6a28:	f04f 33ff 	mov.w	r3, #4294967295
    6a2c:	e9cd 2304 	strd	r2, r3, [sp, #16]
    6a30:	2300      	movs	r3, #0
    6a32:	9302      	str	r3, [sp, #8]
    6a34:	4b10      	ldr	r3, [pc, #64]	@ (6a78 <__static_initialization_and_destruction_0()+0x118>)
    6a36:	9301      	str	r3, [sp, #4]
    6a38:	9100      	str	r1, [sp, #0]
    6a3a:	4b16      	ldr	r3, [pc, #88]	@ (6a94 <__static_initialization_and_destruction_0()+0x134>)
    6a3c:	4a0f      	ldr	r2, [pc, #60]	@ (6a7c <__static_initialization_and_destruction_0()+0x11c>)
    6a3e:	4912      	ldr	r1, [pc, #72]	@ (6a88 <__static_initialization_and_destruction_0()+0x128>)
    6a40:	4816      	ldr	r0, [pc, #88]	@ (6a9c <__static_initialization_and_destruction_0()+0x13c>)
    6a42:	f7fe ff69 	bl	5918 <BinaryUart::BinaryUart(IUart&, IPacket&, BinaryCmd const*, unsigned int, BinaryUartCallbacks&, bool, unsigned long long)>
BinaryUart FpgaUartParser2(FPGAUartPinout2, FPGAUartProtocol, BinaryCmds, NumBinaryCmds, PacketCallbacks, false); // No serial number given, so Invalid is used by default
    6a46:	4b12      	ldr	r3, [pc, #72]	@ (6a90 <__static_initialization_and_destruction_0()+0x130>)
    6a48:	781b      	ldrb	r3, [r3, #0]
    6a4a:	4619      	mov	r1, r3
    6a4c:	f04f 32ff 	mov.w	r2, #4294967295
    6a50:	f04f 33ff 	mov.w	r3, #4294967295
    6a54:	e9cd 2304 	strd	r2, r3, [sp, #16]
    6a58:	2300      	movs	r3, #0
    6a5a:	9302      	str	r3, [sp, #8]
    6a5c:	4b06      	ldr	r3, [pc, #24]	@ (6a78 <__static_initialization_and_destruction_0()+0x118>)
    6a5e:	9301      	str	r3, [sp, #4]
    6a60:	9100      	str	r1, [sp, #0]
    6a62:	4b0c      	ldr	r3, [pc, #48]	@ (6a94 <__static_initialization_and_destruction_0()+0x134>)
    6a64:	4a05      	ldr	r2, [pc, #20]	@ (6a7c <__static_initialization_and_destruction_0()+0x11c>)
    6a66:	4909      	ldr	r1, [pc, #36]	@ (6a8c <__static_initialization_and_destruction_0()+0x12c>)
    6a68:	480d      	ldr	r0, [pc, #52]	@ (6aa0 <__static_initialization_and_destruction_0()+0x140>)
    6a6a:	f7fe ff55 	bl	5918 <BinaryUart::BinaryUart(IUart&, IPacket&, BinaryCmd const*, unsigned int, BinaryUartCallbacks&, bool, unsigned long long)>
}
    6a6e:	bf00      	nop
    6a70:	3704      	adds	r7, #4
    6a72:	46bd      	mov	sp, r7
    6a74:	bd90      	pop	{r4, r7, pc}
    6a76:	bf00      	nop
    6a78:	20001520 	.word	0x20001520
    6a7c:	20001524 	.word	0x20001524
    6a80:	2000003c 	.word	0x2000003c
    6a84:	20001528 	.word	0x20001528
    6a88:	20001544 	.word	0x20001544
    6a8c:	20001560 	.word	0x20001560
    6a90:	0000a8e1 	.word	0x0000a8e1
    6a94:	20000200 	.word	0x20000200
    6a98:	20001580 	.word	0x20001580
    6a9c:	200025b8 	.word	0x200025b8
    6aa0:	200035f0 	.word	0x200035f0

00006aa4 <__static_initialization_and_destruction_1()>:
    6aa4:	b580      	push	{r7, lr}
    6aa6:	af00      	add	r7, sp, #0
};

static RTSCallback NoRTS;
    6aa8:	480e      	ldr	r0, [pc, #56]	@ (6ae4 <__static_initialization_and_destruction_1()+0x40>)
    6aaa:	f7ff fedd 	bl	6868 <RTSCallback::~RTSCallback()>
BinaryUart FpgaUartParser2(FPGAUartPinout2, FPGAUartProtocol, BinaryCmds, NumBinaryCmds, PacketCallbacks, false); // No serial number given, so Invalid is used by default
    6aae:	480e      	ldr	r0, [pc, #56]	@ (6ae8 <__static_initialization_and_destruction_1()+0x44>)
    6ab0:	f7ff ff32 	bl	6918 <BinaryUart::~BinaryUart()>
BinaryUart FpgaUartParser1(FPGAUartPinout1, FPGAUartProtocol, BinaryCmds, NumBinaryCmds, PacketCallbacks, false); // No serial number given, so Invalid is used by default
    6ab4:	480d      	ldr	r0, [pc, #52]	@ (6aec <__static_initialization_and_destruction_1()+0x48>)
    6ab6:	f7ff ff2f 	bl	6918 <BinaryUart::~BinaryUart()>
BinaryUart FpgaUartParser0(FPGAUartPinout0, FPGAUartProtocol, BinaryCmds, NumBinaryCmds, PacketCallbacks, false); // No serial number given, so Invalid is used by default
    6aba:	480d      	ldr	r0, [pc, #52]	@ (6af0 <__static_initialization_and_destruction_1()+0x4c>)
    6abc:	f7ff ff2c 	bl	6918 <BinaryUart::~BinaryUart()>
uart_pinout_fpga FPGAUartPinout2(&(DM->UartStatusRegister2), &(DM->UartFifo2), &(DM->UartFifo2ReadData), &(DM->UartFifo2), '@');
    6ac0:	480c      	ldr	r0, [pc, #48]	@ (6af4 <__static_initialization_and_destruction_1()+0x50>)
    6ac2:	f7ff fd7f 	bl	65c4 <uart_pinout_fpga::~uart_pinout_fpga()>
uart_pinout_fpga FPGAUartPinout1(&(DM->UartStatusRegister1), &(DM->UartFifo1), &(DM->UartFifo1ReadData), &(DM->UartFifo1), '!');
    6ac6:	480c      	ldr	r0, [pc, #48]	@ (6af8 <__static_initialization_and_destruction_1()+0x54>)
    6ac8:	f7ff fd7c 	bl	65c4 <uart_pinout_fpga::~uart_pinout_fpga()>
uart_pinout_fpga FPGAUartPinout0(&(DM->UartStatusRegister0), &(DM->UartFifo0), &(DM->UartFifo0ReadData), &(DM->UartFifo0), '~');
    6acc:	480b      	ldr	r0, [pc, #44]	@ (6afc <__static_initialization_and_destruction_1()+0x58>)
    6ace:	f7ff fd79 	bl	65c4 <uart_pinout_fpga::~uart_pinout_fpga()>
CGraphPacket FPGAUartProtocol;
    6ad2:	480b      	ldr	r0, [pc, #44]	@ (6b00 <__static_initialization_and_destruction_1()+0x5c>)
    6ad4:	f7fe fcac 	bl	5430 <CGraphPacket::~CGraphPacket()>
} PacketCallbacks;
    6ad8:	480a      	ldr	r0, [pc, #40]	@ (6b04 <__static_initialization_and_destruction_1()+0x60>)
    6ada:	f7ff fe21 	bl	6720 <FPGABinaryUartCallbacks::~FPGABinaryUartCallbacks()>
}
    6ade:	bf00      	nop
    6ae0:	bd80      	pop	{r7, pc}
    6ae2:	bf00      	nop
    6ae4:	20000044 	.word	0x20000044
    6ae8:	200035f0 	.word	0x200035f0
    6aec:	200025b8 	.word	0x200025b8
    6af0:	20001580 	.word	0x20001580
    6af4:	20001560 	.word	0x20001560
    6af8:	20001544 	.word	0x20001544
    6afc:	20001528 	.word	0x20001528
    6b00:	20001524 	.word	0x20001524
    6b04:	20001520 	.word	0x20001520

00006b08 <_GLOBAL__sub_I_PacketCallbacks>:
    6b08:	b580      	push	{r7, lr}
    6b0a:	af00      	add	r7, sp, #0
    6b0c:	f7ff ff28 	bl	6960 <__static_initialization_and_destruction_0()>
    6b10:	bd80      	pop	{r7, pc}

00006b12 <_GLOBAL__sub_D_PacketCallbacks>:
    6b12:	b580      	push	{r7, lr}
    6b14:	af00      	add	r7, sp, #0
    6b16:	f7ff ffc5 	bl	6aa4 <__static_initialization_and_destruction_1()>
    6b1a:	bd80      	pop	{r7, pc}

00006b1c <atoi>:
    6b1c:	220a      	movs	r2, #10
    6b1e:	2100      	movs	r1, #0
    6b20:	f000 b87c 	b.w	6c1c <strtol>

00006b24 <_strtol_l.isra.0>:
    6b24:	2b24      	cmp	r3, #36	@ 0x24
    6b26:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    6b2a:	4686      	mov	lr, r0
    6b2c:	4690      	mov	r8, r2
    6b2e:	d801      	bhi.n	6b34 <_strtol_l.isra.0+0x10>
    6b30:	2b01      	cmp	r3, #1
    6b32:	d106      	bne.n	6b42 <_strtol_l.isra.0+0x1e>
    6b34:	f000 fc62 	bl	73fc <__errno>
    6b38:	2316      	movs	r3, #22
    6b3a:	6003      	str	r3, [r0, #0]
    6b3c:	2000      	movs	r0, #0
    6b3e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    6b42:	460d      	mov	r5, r1
    6b44:	4833      	ldr	r0, [pc, #204]	@ (6c14 <_strtol_l.isra.0+0xf0>)
    6b46:	462a      	mov	r2, r5
    6b48:	f815 4b01 	ldrb.w	r4, [r5], #1
    6b4c:	5d06      	ldrb	r6, [r0, r4]
    6b4e:	f016 0608 	ands.w	r6, r6, #8
    6b52:	d1f8      	bne.n	6b46 <_strtol_l.isra.0+0x22>
    6b54:	2c2d      	cmp	r4, #45	@ 0x2d
    6b56:	d110      	bne.n	6b7a <_strtol_l.isra.0+0x56>
    6b58:	2601      	movs	r6, #1
    6b5a:	782c      	ldrb	r4, [r5, #0]
    6b5c:	1c95      	adds	r5, r2, #2
    6b5e:	f033 0210 	bics.w	r2, r3, #16
    6b62:	d115      	bne.n	6b90 <_strtol_l.isra.0+0x6c>
    6b64:	2c30      	cmp	r4, #48	@ 0x30
    6b66:	d10d      	bne.n	6b84 <_strtol_l.isra.0+0x60>
    6b68:	782a      	ldrb	r2, [r5, #0]
    6b6a:	f002 02df 	and.w	r2, r2, #223	@ 0xdf
    6b6e:	2a58      	cmp	r2, #88	@ 0x58
    6b70:	d108      	bne.n	6b84 <_strtol_l.isra.0+0x60>
    6b72:	786c      	ldrb	r4, [r5, #1]
    6b74:	3502      	adds	r5, #2
    6b76:	2310      	movs	r3, #16
    6b78:	e00a      	b.n	6b90 <_strtol_l.isra.0+0x6c>
    6b7a:	2c2b      	cmp	r4, #43	@ 0x2b
    6b7c:	bf04      	itt	eq
    6b7e:	782c      	ldrbeq	r4, [r5, #0]
    6b80:	1c95      	addeq	r5, r2, #2
    6b82:	e7ec      	b.n	6b5e <_strtol_l.isra.0+0x3a>
    6b84:	2b00      	cmp	r3, #0
    6b86:	d1f6      	bne.n	6b76 <_strtol_l.isra.0+0x52>
    6b88:	2c30      	cmp	r4, #48	@ 0x30
    6b8a:	bf14      	ite	ne
    6b8c:	230a      	movne	r3, #10
    6b8e:	2308      	moveq	r3, #8
    6b90:	2200      	movs	r2, #0
    6b92:	f106 4c00 	add.w	ip, r6, #2147483648	@ 0x80000000
    6b96:	f10c 3cff 	add.w	ip, ip, #4294967295
    6b9a:	fbbc f9f3 	udiv	r9, ip, r3
    6b9e:	4610      	mov	r0, r2
    6ba0:	fb03 ca19 	mls	sl, r3, r9, ip
    6ba4:	f1a4 0730 	sub.w	r7, r4, #48	@ 0x30
    6ba8:	2f09      	cmp	r7, #9
    6baa:	d80f      	bhi.n	6bcc <_strtol_l.isra.0+0xa8>
    6bac:	463c      	mov	r4, r7
    6bae:	42a3      	cmp	r3, r4
    6bb0:	dd1b      	ble.n	6bea <_strtol_l.isra.0+0xc6>
    6bb2:	1c57      	adds	r7, r2, #1
    6bb4:	d007      	beq.n	6bc6 <_strtol_l.isra.0+0xa2>
    6bb6:	4581      	cmp	r9, r0
    6bb8:	d314      	bcc.n	6be4 <_strtol_l.isra.0+0xc0>
    6bba:	d101      	bne.n	6bc0 <_strtol_l.isra.0+0x9c>
    6bbc:	45a2      	cmp	sl, r4
    6bbe:	db11      	blt.n	6be4 <_strtol_l.isra.0+0xc0>
    6bc0:	2201      	movs	r2, #1
    6bc2:	fb00 4003 	mla	r0, r0, r3, r4
    6bc6:	f815 4b01 	ldrb.w	r4, [r5], #1
    6bca:	e7eb      	b.n	6ba4 <_strtol_l.isra.0+0x80>
    6bcc:	f1a4 0741 	sub.w	r7, r4, #65	@ 0x41
    6bd0:	2f19      	cmp	r7, #25
    6bd2:	d801      	bhi.n	6bd8 <_strtol_l.isra.0+0xb4>
    6bd4:	3c37      	subs	r4, #55	@ 0x37
    6bd6:	e7ea      	b.n	6bae <_strtol_l.isra.0+0x8a>
    6bd8:	f1a4 0761 	sub.w	r7, r4, #97	@ 0x61
    6bdc:	2f19      	cmp	r7, #25
    6bde:	d804      	bhi.n	6bea <_strtol_l.isra.0+0xc6>
    6be0:	3c57      	subs	r4, #87	@ 0x57
    6be2:	e7e4      	b.n	6bae <_strtol_l.isra.0+0x8a>
    6be4:	f04f 32ff 	mov.w	r2, #4294967295
    6be8:	e7ed      	b.n	6bc6 <_strtol_l.isra.0+0xa2>
    6bea:	1c53      	adds	r3, r2, #1
    6bec:	d108      	bne.n	6c00 <_strtol_l.isra.0+0xdc>
    6bee:	2322      	movs	r3, #34	@ 0x22
    6bf0:	4660      	mov	r0, ip
    6bf2:	f8ce 3000 	str.w	r3, [lr]
    6bf6:	f1b8 0f00 	cmp.w	r8, #0
    6bfa:	d0a0      	beq.n	6b3e <_strtol_l.isra.0+0x1a>
    6bfc:	1e69      	subs	r1, r5, #1
    6bfe:	e006      	b.n	6c0e <_strtol_l.isra.0+0xea>
    6c00:	b106      	cbz	r6, 6c04 <_strtol_l.isra.0+0xe0>
    6c02:	4240      	negs	r0, r0
    6c04:	f1b8 0f00 	cmp.w	r8, #0
    6c08:	d099      	beq.n	6b3e <_strtol_l.isra.0+0x1a>
    6c0a:	2a00      	cmp	r2, #0
    6c0c:	d1f6      	bne.n	6bfc <_strtol_l.isra.0+0xd8>
    6c0e:	f8c8 1000 	str.w	r1, [r8]
    6c12:	e794      	b.n	6b3e <_strtol_l.isra.0+0x1a>
    6c14:	0000b879 	.word	0x0000b879

00006c18 <_strtol_r>:
    6c18:	f7ff bf84 	b.w	6b24 <_strtol_l.isra.0>

00006c1c <strtol>:
    6c1c:	4613      	mov	r3, r2
    6c1e:	460a      	mov	r2, r1
    6c20:	4601      	mov	r1, r0
    6c22:	4802      	ldr	r0, [pc, #8]	@ (6c2c <strtol+0x10>)
    6c24:	6800      	ldr	r0, [r0, #0]
    6c26:	f7ff bf7d 	b.w	6b24 <_strtol_l.isra.0>
    6c2a:	bf00      	nop
    6c2c:	20000054 	.word	0x20000054

00006c30 <__sflush_r>:
    6c30:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
    6c34:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    6c36:	0716      	lsls	r6, r2, #28
    6c38:	4605      	mov	r5, r0
    6c3a:	460c      	mov	r4, r1
    6c3c:	d451      	bmi.n	6ce2 <__sflush_r+0xb2>
    6c3e:	684b      	ldr	r3, [r1, #4]
    6c40:	2b00      	cmp	r3, #0
    6c42:	dc02      	bgt.n	6c4a <__sflush_r+0x1a>
    6c44:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
    6c46:	2b00      	cmp	r3, #0
    6c48:	dd49      	ble.n	6cde <__sflush_r+0xae>
    6c4a:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
    6c4c:	2e00      	cmp	r6, #0
    6c4e:	d046      	beq.n	6cde <__sflush_r+0xae>
    6c50:	2300      	movs	r3, #0
    6c52:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
    6c56:	682f      	ldr	r7, [r5, #0]
    6c58:	602b      	str	r3, [r5, #0]
    6c5a:	d031      	beq.n	6cc0 <__sflush_r+0x90>
    6c5c:	6d62      	ldr	r2, [r4, #84]	@ 0x54
    6c5e:	89a3      	ldrh	r3, [r4, #12]
    6c60:	0759      	lsls	r1, r3, #29
    6c62:	d505      	bpl.n	6c70 <__sflush_r+0x40>
    6c64:	6863      	ldr	r3, [r4, #4]
    6c66:	1ad2      	subs	r2, r2, r3
    6c68:	6b63      	ldr	r3, [r4, #52]	@ 0x34
    6c6a:	b10b      	cbz	r3, 6c70 <__sflush_r+0x40>
    6c6c:	6c23      	ldr	r3, [r4, #64]	@ 0x40
    6c6e:	1ad2      	subs	r2, r2, r3
    6c70:	2300      	movs	r3, #0
    6c72:	4628      	mov	r0, r5
    6c74:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
    6c76:	6a21      	ldr	r1, [r4, #32]
    6c78:	47b0      	blx	r6
    6c7a:	1c42      	adds	r2, r0, #1
    6c7c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    6c80:	d106      	bne.n	6c90 <__sflush_r+0x60>
    6c82:	6829      	ldr	r1, [r5, #0]
    6c84:	291d      	cmp	r1, #29
    6c86:	d845      	bhi.n	6d14 <__sflush_r+0xe4>
    6c88:	4a27      	ldr	r2, [pc, #156]	@ (6d28 <__sflush_r+0xf8>)
    6c8a:	40ca      	lsrs	r2, r1
    6c8c:	07d6      	lsls	r6, r2, #31
    6c8e:	d541      	bpl.n	6d14 <__sflush_r+0xe4>
    6c90:	2200      	movs	r2, #0
    6c92:	6062      	str	r2, [r4, #4]
    6c94:	6922      	ldr	r2, [r4, #16]
    6c96:	04d9      	lsls	r1, r3, #19
    6c98:	6022      	str	r2, [r4, #0]
    6c9a:	d504      	bpl.n	6ca6 <__sflush_r+0x76>
    6c9c:	1c42      	adds	r2, r0, #1
    6c9e:	d101      	bne.n	6ca4 <__sflush_r+0x74>
    6ca0:	682b      	ldr	r3, [r5, #0]
    6ca2:	b903      	cbnz	r3, 6ca6 <__sflush_r+0x76>
    6ca4:	6560      	str	r0, [r4, #84]	@ 0x54
    6ca6:	6b61      	ldr	r1, [r4, #52]	@ 0x34
    6ca8:	602f      	str	r7, [r5, #0]
    6caa:	b1c1      	cbz	r1, 6cde <__sflush_r+0xae>
    6cac:	f104 0344 	add.w	r3, r4, #68	@ 0x44
    6cb0:	4299      	cmp	r1, r3
    6cb2:	d002      	beq.n	6cba <__sflush_r+0x8a>
    6cb4:	4628      	mov	r0, r5
    6cb6:	f000 fc03 	bl	74c0 <_free_r>
    6cba:	2300      	movs	r3, #0
    6cbc:	6363      	str	r3, [r4, #52]	@ 0x34
    6cbe:	e00e      	b.n	6cde <__sflush_r+0xae>
    6cc0:	2301      	movs	r3, #1
    6cc2:	4628      	mov	r0, r5
    6cc4:	6a21      	ldr	r1, [r4, #32]
    6cc6:	47b0      	blx	r6
    6cc8:	4602      	mov	r2, r0
    6cca:	1c50      	adds	r0, r2, #1
    6ccc:	d1c7      	bne.n	6c5e <__sflush_r+0x2e>
    6cce:	682b      	ldr	r3, [r5, #0]
    6cd0:	2b00      	cmp	r3, #0
    6cd2:	d0c4      	beq.n	6c5e <__sflush_r+0x2e>
    6cd4:	2b1d      	cmp	r3, #29
    6cd6:	d001      	beq.n	6cdc <__sflush_r+0xac>
    6cd8:	2b16      	cmp	r3, #22
    6cda:	d119      	bne.n	6d10 <__sflush_r+0xe0>
    6cdc:	602f      	str	r7, [r5, #0]
    6cde:	2000      	movs	r0, #0
    6ce0:	e01d      	b.n	6d1e <__sflush_r+0xee>
    6ce2:	690f      	ldr	r7, [r1, #16]
    6ce4:	2f00      	cmp	r7, #0
    6ce6:	d0fa      	beq.n	6cde <__sflush_r+0xae>
    6ce8:	0793      	lsls	r3, r2, #30
    6cea:	bf18      	it	ne
    6cec:	2300      	movne	r3, #0
    6cee:	680e      	ldr	r6, [r1, #0]
    6cf0:	bf08      	it	eq
    6cf2:	694b      	ldreq	r3, [r1, #20]
    6cf4:	1bf6      	subs	r6, r6, r7
    6cf6:	600f      	str	r7, [r1, #0]
    6cf8:	608b      	str	r3, [r1, #8]
    6cfa:	2e00      	cmp	r6, #0
    6cfc:	ddef      	ble.n	6cde <__sflush_r+0xae>
    6cfe:	4633      	mov	r3, r6
    6d00:	463a      	mov	r2, r7
    6d02:	4628      	mov	r0, r5
    6d04:	6a21      	ldr	r1, [r4, #32]
    6d06:	f8d4 c028 	ldr.w	ip, [r4, #40]	@ 0x28
    6d0a:	47e0      	blx	ip
    6d0c:	2800      	cmp	r0, #0
    6d0e:	dc07      	bgt.n	6d20 <__sflush_r+0xf0>
    6d10:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    6d14:	f04f 30ff 	mov.w	r0, #4294967295
    6d18:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
    6d1c:	81a3      	strh	r3, [r4, #12]
    6d1e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    6d20:	4407      	add	r7, r0
    6d22:	1a36      	subs	r6, r6, r0
    6d24:	e7e9      	b.n	6cfa <__sflush_r+0xca>
    6d26:	bf00      	nop
    6d28:	20400001 	.word	0x20400001

00006d2c <_fflush_r>:
    6d2c:	b538      	push	{r3, r4, r5, lr}
    6d2e:	690b      	ldr	r3, [r1, #16]
    6d30:	4605      	mov	r5, r0
    6d32:	460c      	mov	r4, r1
    6d34:	b913      	cbnz	r3, 6d3c <_fflush_r+0x10>
    6d36:	2500      	movs	r5, #0
    6d38:	4628      	mov	r0, r5
    6d3a:	bd38      	pop	{r3, r4, r5, pc}
    6d3c:	b118      	cbz	r0, 6d46 <_fflush_r+0x1a>
    6d3e:	6a03      	ldr	r3, [r0, #32]
    6d40:	b90b      	cbnz	r3, 6d46 <_fflush_r+0x1a>
    6d42:	f000 f8bd 	bl	6ec0 <__sinit>
    6d46:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    6d4a:	2b00      	cmp	r3, #0
    6d4c:	d0f3      	beq.n	6d36 <_fflush_r+0xa>
    6d4e:	6e62      	ldr	r2, [r4, #100]	@ 0x64
    6d50:	07d0      	lsls	r0, r2, #31
    6d52:	d404      	bmi.n	6d5e <_fflush_r+0x32>
    6d54:	0599      	lsls	r1, r3, #22
    6d56:	d402      	bmi.n	6d5e <_fflush_r+0x32>
    6d58:	6da0      	ldr	r0, [r4, #88]	@ 0x58
    6d5a:	f000 fb7a 	bl	7452 <__retarget_lock_acquire_recursive>
    6d5e:	4628      	mov	r0, r5
    6d60:	4621      	mov	r1, r4
    6d62:	f7ff ff65 	bl	6c30 <__sflush_r>
    6d66:	6e63      	ldr	r3, [r4, #100]	@ 0x64
    6d68:	4605      	mov	r5, r0
    6d6a:	07da      	lsls	r2, r3, #31
    6d6c:	d4e4      	bmi.n	6d38 <_fflush_r+0xc>
    6d6e:	89a3      	ldrh	r3, [r4, #12]
    6d70:	059b      	lsls	r3, r3, #22
    6d72:	d4e1      	bmi.n	6d38 <_fflush_r+0xc>
    6d74:	6da0      	ldr	r0, [r4, #88]	@ 0x58
    6d76:	f000 fb6d 	bl	7454 <__retarget_lock_release_recursive>
    6d7a:	e7dd      	b.n	6d38 <_fflush_r+0xc>

00006d7c <fflush>:
    6d7c:	4601      	mov	r1, r0
    6d7e:	b920      	cbnz	r0, 6d8a <fflush+0xe>
    6d80:	4a04      	ldr	r2, [pc, #16]	@ (6d94 <fflush+0x18>)
    6d82:	4905      	ldr	r1, [pc, #20]	@ (6d98 <fflush+0x1c>)
    6d84:	4805      	ldr	r0, [pc, #20]	@ (6d9c <fflush+0x20>)
    6d86:	f000 b8b3 	b.w	6ef0 <_fwalk_sglue>
    6d8a:	4b05      	ldr	r3, [pc, #20]	@ (6da0 <fflush+0x24>)
    6d8c:	6818      	ldr	r0, [r3, #0]
    6d8e:	f7ff bfcd 	b.w	6d2c <_fflush_r>
    6d92:	bf00      	nop
    6d94:	20000048 	.word	0x20000048
    6d98:	00006d2d 	.word	0x00006d2d
    6d9c:	20000058 	.word	0x20000058
    6da0:	20000054 	.word	0x20000054

00006da4 <std>:
    6da4:	2300      	movs	r3, #0
    6da6:	b510      	push	{r4, lr}
    6da8:	4604      	mov	r4, r0
    6daa:	e9c0 3300 	strd	r3, r3, [r0]
    6dae:	e9c0 3304 	strd	r3, r3, [r0, #16]
    6db2:	6083      	str	r3, [r0, #8]
    6db4:	8181      	strh	r1, [r0, #12]
    6db6:	6643      	str	r3, [r0, #100]	@ 0x64
    6db8:	81c2      	strh	r2, [r0, #14]
    6dba:	6183      	str	r3, [r0, #24]
    6dbc:	4619      	mov	r1, r3
    6dbe:	2208      	movs	r2, #8
    6dc0:	305c      	adds	r0, #92	@ 0x5c
    6dc2:	f000 fa63 	bl	728c <memset>
    6dc6:	4b0d      	ldr	r3, [pc, #52]	@ (6dfc <std+0x58>)
    6dc8:	6224      	str	r4, [r4, #32]
    6dca:	6263      	str	r3, [r4, #36]	@ 0x24
    6dcc:	4b0c      	ldr	r3, [pc, #48]	@ (6e00 <std+0x5c>)
    6dce:	62a3      	str	r3, [r4, #40]	@ 0x28
    6dd0:	4b0c      	ldr	r3, [pc, #48]	@ (6e04 <std+0x60>)
    6dd2:	62e3      	str	r3, [r4, #44]	@ 0x2c
    6dd4:	4b0c      	ldr	r3, [pc, #48]	@ (6e08 <std+0x64>)
    6dd6:	6323      	str	r3, [r4, #48]	@ 0x30
    6dd8:	4b0c      	ldr	r3, [pc, #48]	@ (6e0c <std+0x68>)
    6dda:	429c      	cmp	r4, r3
    6ddc:	d006      	beq.n	6dec <std+0x48>
    6dde:	f103 0268 	add.w	r2, r3, #104	@ 0x68
    6de2:	4294      	cmp	r4, r2
    6de4:	d002      	beq.n	6dec <std+0x48>
    6de6:	33d0      	adds	r3, #208	@ 0xd0
    6de8:	429c      	cmp	r4, r3
    6dea:	d105      	bne.n	6df8 <std+0x54>
    6dec:	f104 0058 	add.w	r0, r4, #88	@ 0x58
    6df0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    6df4:	f000 bb2c 	b.w	7450 <__retarget_lock_init_recursive>
    6df8:	bd10      	pop	{r4, pc}
    6dfa:	bf00      	nop
    6dfc:	000070dd 	.word	0x000070dd
    6e00:	00007103 	.word	0x00007103
    6e04:	0000713b 	.word	0x0000713b
    6e08:	00007161 	.word	0x00007161
    6e0c:	20004628 	.word	0x20004628

00006e10 <stdio_exit_handler>:
    6e10:	4a02      	ldr	r2, [pc, #8]	@ (6e1c <stdio_exit_handler+0xc>)
    6e12:	4903      	ldr	r1, [pc, #12]	@ (6e20 <stdio_exit_handler+0x10>)
    6e14:	4803      	ldr	r0, [pc, #12]	@ (6e24 <stdio_exit_handler+0x14>)
    6e16:	f000 b86b 	b.w	6ef0 <_fwalk_sglue>
    6e1a:	bf00      	nop
    6e1c:	20000048 	.word	0x20000048
    6e20:	00006d2d 	.word	0x00006d2d
    6e24:	20000058 	.word	0x20000058

00006e28 <cleanup_stdio>:
    6e28:	6841      	ldr	r1, [r0, #4]
    6e2a:	4b0c      	ldr	r3, [pc, #48]	@ (6e5c <cleanup_stdio+0x34>)
    6e2c:	b510      	push	{r4, lr}
    6e2e:	4299      	cmp	r1, r3
    6e30:	4604      	mov	r4, r0
    6e32:	d001      	beq.n	6e38 <cleanup_stdio+0x10>
    6e34:	f7ff ff7a 	bl	6d2c <_fflush_r>
    6e38:	68a1      	ldr	r1, [r4, #8]
    6e3a:	4b09      	ldr	r3, [pc, #36]	@ (6e60 <cleanup_stdio+0x38>)
    6e3c:	4299      	cmp	r1, r3
    6e3e:	d002      	beq.n	6e46 <cleanup_stdio+0x1e>
    6e40:	4620      	mov	r0, r4
    6e42:	f7ff ff73 	bl	6d2c <_fflush_r>
    6e46:	68e1      	ldr	r1, [r4, #12]
    6e48:	4b06      	ldr	r3, [pc, #24]	@ (6e64 <cleanup_stdio+0x3c>)
    6e4a:	4299      	cmp	r1, r3
    6e4c:	d004      	beq.n	6e58 <cleanup_stdio+0x30>
    6e4e:	4620      	mov	r0, r4
    6e50:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    6e54:	f7ff bf6a 	b.w	6d2c <_fflush_r>
    6e58:	bd10      	pop	{r4, pc}
    6e5a:	bf00      	nop
    6e5c:	20004628 	.word	0x20004628
    6e60:	20004690 	.word	0x20004690
    6e64:	200046f8 	.word	0x200046f8

00006e68 <global_stdio_init.part.0>:
    6e68:	4b0c      	ldr	r3, [pc, #48]	@ (6e9c <global_stdio_init.part.0+0x34>)
    6e6a:	4a0d      	ldr	r2, [pc, #52]	@ (6ea0 <global_stdio_init.part.0+0x38>)
    6e6c:	b510      	push	{r4, lr}
    6e6e:	2104      	movs	r1, #4
    6e70:	601a      	str	r2, [r3, #0]
    6e72:	480c      	ldr	r0, [pc, #48]	@ (6ea4 <global_stdio_init.part.0+0x3c>)
    6e74:	2200      	movs	r2, #0
    6e76:	f7ff ff95 	bl	6da4 <std>
    6e7a:	4b0a      	ldr	r3, [pc, #40]	@ (6ea4 <global_stdio_init.part.0+0x3c>)
    6e7c:	2201      	movs	r2, #1
    6e7e:	461c      	mov	r4, r3
    6e80:	2109      	movs	r1, #9
    6e82:	f103 0068 	add.w	r0, r3, #104	@ 0x68
    6e86:	f7ff ff8d 	bl	6da4 <std>
    6e8a:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
    6e8e:	2202      	movs	r2, #2
    6e90:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    6e94:	2112      	movs	r1, #18
    6e96:	f7ff bf85 	b.w	6da4 <std>
    6e9a:	bf00      	nop
    6e9c:	20004760 	.word	0x20004760
    6ea0:	00006e11 	.word	0x00006e11
    6ea4:	20004628 	.word	0x20004628

00006ea8 <__sfp_lock_acquire>:
    6ea8:	4801      	ldr	r0, [pc, #4]	@ (6eb0 <__sfp_lock_acquire+0x8>)
    6eaa:	f000 bad2 	b.w	7452 <__retarget_lock_acquire_recursive>
    6eae:	bf00      	nop
    6eb0:	20004769 	.word	0x20004769

00006eb4 <__sfp_lock_release>:
    6eb4:	4801      	ldr	r0, [pc, #4]	@ (6ebc <__sfp_lock_release+0x8>)
    6eb6:	f000 bacd 	b.w	7454 <__retarget_lock_release_recursive>
    6eba:	bf00      	nop
    6ebc:	20004769 	.word	0x20004769

00006ec0 <__sinit>:
    6ec0:	b510      	push	{r4, lr}
    6ec2:	4604      	mov	r4, r0
    6ec4:	f7ff fff0 	bl	6ea8 <__sfp_lock_acquire>
    6ec8:	6a23      	ldr	r3, [r4, #32]
    6eca:	b11b      	cbz	r3, 6ed4 <__sinit+0x14>
    6ecc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    6ed0:	f7ff bff0 	b.w	6eb4 <__sfp_lock_release>
    6ed4:	4b04      	ldr	r3, [pc, #16]	@ (6ee8 <__sinit+0x28>)
    6ed6:	6223      	str	r3, [r4, #32]
    6ed8:	4b04      	ldr	r3, [pc, #16]	@ (6eec <__sinit+0x2c>)
    6eda:	681b      	ldr	r3, [r3, #0]
    6edc:	2b00      	cmp	r3, #0
    6ede:	d1f5      	bne.n	6ecc <__sinit+0xc>
    6ee0:	f7ff ffc2 	bl	6e68 <global_stdio_init.part.0>
    6ee4:	e7f2      	b.n	6ecc <__sinit+0xc>
    6ee6:	bf00      	nop
    6ee8:	00006e29 	.word	0x00006e29
    6eec:	20004760 	.word	0x20004760

00006ef0 <_fwalk_sglue>:
    6ef0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    6ef4:	4607      	mov	r7, r0
    6ef6:	4688      	mov	r8, r1
    6ef8:	4614      	mov	r4, r2
    6efa:	2600      	movs	r6, #0
    6efc:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
    6f00:	f1b9 0901 	subs.w	r9, r9, #1
    6f04:	d505      	bpl.n	6f12 <_fwalk_sglue+0x22>
    6f06:	6824      	ldr	r4, [r4, #0]
    6f08:	2c00      	cmp	r4, #0
    6f0a:	d1f7      	bne.n	6efc <_fwalk_sglue+0xc>
    6f0c:	4630      	mov	r0, r6
    6f0e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    6f12:	89ab      	ldrh	r3, [r5, #12]
    6f14:	2b01      	cmp	r3, #1
    6f16:	d907      	bls.n	6f28 <_fwalk_sglue+0x38>
    6f18:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
    6f1c:	3301      	adds	r3, #1
    6f1e:	d003      	beq.n	6f28 <_fwalk_sglue+0x38>
    6f20:	4629      	mov	r1, r5
    6f22:	4638      	mov	r0, r7
    6f24:	47c0      	blx	r8
    6f26:	4306      	orrs	r6, r0
    6f28:	3568      	adds	r5, #104	@ 0x68
    6f2a:	e7e9      	b.n	6f00 <_fwalk_sglue+0x10>

00006f2c <iprintf>:
    6f2c:	b40f      	push	{r0, r1, r2, r3}
    6f2e:	b507      	push	{r0, r1, r2, lr}
    6f30:	4906      	ldr	r1, [pc, #24]	@ (6f4c <iprintf+0x20>)
    6f32:	ab04      	add	r3, sp, #16
    6f34:	6808      	ldr	r0, [r1, #0]
    6f36:	f853 2b04 	ldr.w	r2, [r3], #4
    6f3a:	6881      	ldr	r1, [r0, #8]
    6f3c:	9301      	str	r3, [sp, #4]
    6f3e:	f000 fdc5 	bl	7acc <_vfiprintf_r>
    6f42:	b003      	add	sp, #12
    6f44:	f85d eb04 	ldr.w	lr, [sp], #4
    6f48:	b004      	add	sp, #16
    6f4a:	4770      	bx	lr
    6f4c:	20000054 	.word	0x20000054

00006f50 <_putc_r>:
    6f50:	b570      	push	{r4, r5, r6, lr}
    6f52:	460d      	mov	r5, r1
    6f54:	4614      	mov	r4, r2
    6f56:	4606      	mov	r6, r0
    6f58:	b118      	cbz	r0, 6f62 <_putc_r+0x12>
    6f5a:	6a03      	ldr	r3, [r0, #32]
    6f5c:	b90b      	cbnz	r3, 6f62 <_putc_r+0x12>
    6f5e:	f7ff ffaf 	bl	6ec0 <__sinit>
    6f62:	6e63      	ldr	r3, [r4, #100]	@ 0x64
    6f64:	07d8      	lsls	r0, r3, #31
    6f66:	d405      	bmi.n	6f74 <_putc_r+0x24>
    6f68:	89a3      	ldrh	r3, [r4, #12]
    6f6a:	0599      	lsls	r1, r3, #22
    6f6c:	d402      	bmi.n	6f74 <_putc_r+0x24>
    6f6e:	6da0      	ldr	r0, [r4, #88]	@ 0x58
    6f70:	f000 fa6f 	bl	7452 <__retarget_lock_acquire_recursive>
    6f74:	68a3      	ldr	r3, [r4, #8]
    6f76:	3b01      	subs	r3, #1
    6f78:	2b00      	cmp	r3, #0
    6f7a:	60a3      	str	r3, [r4, #8]
    6f7c:	da05      	bge.n	6f8a <_putc_r+0x3a>
    6f7e:	69a2      	ldr	r2, [r4, #24]
    6f80:	4293      	cmp	r3, r2
    6f82:	db12      	blt.n	6faa <_putc_r+0x5a>
    6f84:	b2eb      	uxtb	r3, r5
    6f86:	2b0a      	cmp	r3, #10
    6f88:	d00f      	beq.n	6faa <_putc_r+0x5a>
    6f8a:	6823      	ldr	r3, [r4, #0]
    6f8c:	1c5a      	adds	r2, r3, #1
    6f8e:	6022      	str	r2, [r4, #0]
    6f90:	701d      	strb	r5, [r3, #0]
    6f92:	b2ed      	uxtb	r5, r5
    6f94:	6e63      	ldr	r3, [r4, #100]	@ 0x64
    6f96:	07da      	lsls	r2, r3, #31
    6f98:	d405      	bmi.n	6fa6 <_putc_r+0x56>
    6f9a:	89a3      	ldrh	r3, [r4, #12]
    6f9c:	059b      	lsls	r3, r3, #22
    6f9e:	d402      	bmi.n	6fa6 <_putc_r+0x56>
    6fa0:	6da0      	ldr	r0, [r4, #88]	@ 0x58
    6fa2:	f000 fa57 	bl	7454 <__retarget_lock_release_recursive>
    6fa6:	4628      	mov	r0, r5
    6fa8:	bd70      	pop	{r4, r5, r6, pc}
    6faa:	4629      	mov	r1, r5
    6fac:	4622      	mov	r2, r4
    6fae:	4630      	mov	r0, r6
    6fb0:	f000 f8da 	bl	7168 <__swbuf_r>
    6fb4:	4605      	mov	r5, r0
    6fb6:	e7ed      	b.n	6f94 <_putc_r+0x44>

00006fb8 <putchar>:
    6fb8:	4b02      	ldr	r3, [pc, #8]	@ (6fc4 <putchar+0xc>)
    6fba:	4601      	mov	r1, r0
    6fbc:	6818      	ldr	r0, [r3, #0]
    6fbe:	6882      	ldr	r2, [r0, #8]
    6fc0:	f7ff bfc6 	b.w	6f50 <_putc_r>
    6fc4:	20000054 	.word	0x20000054

00006fc8 <_puts_r>:
    6fc8:	6a03      	ldr	r3, [r0, #32]
    6fca:	b570      	push	{r4, r5, r6, lr}
    6fcc:	4605      	mov	r5, r0
    6fce:	460e      	mov	r6, r1
    6fd0:	6884      	ldr	r4, [r0, #8]
    6fd2:	b90b      	cbnz	r3, 6fd8 <_puts_r+0x10>
    6fd4:	f7ff ff74 	bl	6ec0 <__sinit>
    6fd8:	6e63      	ldr	r3, [r4, #100]	@ 0x64
    6fda:	07db      	lsls	r3, r3, #31
    6fdc:	d405      	bmi.n	6fea <_puts_r+0x22>
    6fde:	89a3      	ldrh	r3, [r4, #12]
    6fe0:	0598      	lsls	r0, r3, #22
    6fe2:	d402      	bmi.n	6fea <_puts_r+0x22>
    6fe4:	6da0      	ldr	r0, [r4, #88]	@ 0x58
    6fe6:	f000 fa34 	bl	7452 <__retarget_lock_acquire_recursive>
    6fea:	89a3      	ldrh	r3, [r4, #12]
    6fec:	0719      	lsls	r1, r3, #28
    6fee:	d502      	bpl.n	6ff6 <_puts_r+0x2e>
    6ff0:	6923      	ldr	r3, [r4, #16]
    6ff2:	2b00      	cmp	r3, #0
    6ff4:	d135      	bne.n	7062 <_puts_r+0x9a>
    6ff6:	4621      	mov	r1, r4
    6ff8:	4628      	mov	r0, r5
    6ffa:	f000 f8f3 	bl	71e4 <__swsetup_r>
    6ffe:	b380      	cbz	r0, 7062 <_puts_r+0x9a>
    7000:	f04f 35ff 	mov.w	r5, #4294967295
    7004:	6e63      	ldr	r3, [r4, #100]	@ 0x64
    7006:	07da      	lsls	r2, r3, #31
    7008:	d405      	bmi.n	7016 <_puts_r+0x4e>
    700a:	89a3      	ldrh	r3, [r4, #12]
    700c:	059b      	lsls	r3, r3, #22
    700e:	d402      	bmi.n	7016 <_puts_r+0x4e>
    7010:	6da0      	ldr	r0, [r4, #88]	@ 0x58
    7012:	f000 fa1f 	bl	7454 <__retarget_lock_release_recursive>
    7016:	4628      	mov	r0, r5
    7018:	bd70      	pop	{r4, r5, r6, pc}
    701a:	2b00      	cmp	r3, #0
    701c:	da04      	bge.n	7028 <_puts_r+0x60>
    701e:	69a2      	ldr	r2, [r4, #24]
    7020:	4293      	cmp	r3, r2
    7022:	db17      	blt.n	7054 <_puts_r+0x8c>
    7024:	290a      	cmp	r1, #10
    7026:	d015      	beq.n	7054 <_puts_r+0x8c>
    7028:	6823      	ldr	r3, [r4, #0]
    702a:	1c5a      	adds	r2, r3, #1
    702c:	6022      	str	r2, [r4, #0]
    702e:	7019      	strb	r1, [r3, #0]
    7030:	68a3      	ldr	r3, [r4, #8]
    7032:	f816 1f01 	ldrb.w	r1, [r6, #1]!
    7036:	3b01      	subs	r3, #1
    7038:	60a3      	str	r3, [r4, #8]
    703a:	2900      	cmp	r1, #0
    703c:	d1ed      	bne.n	701a <_puts_r+0x52>
    703e:	2b00      	cmp	r3, #0
    7040:	da11      	bge.n	7066 <_puts_r+0x9e>
    7042:	4622      	mov	r2, r4
    7044:	210a      	movs	r1, #10
    7046:	4628      	mov	r0, r5
    7048:	f000 f88e 	bl	7168 <__swbuf_r>
    704c:	3001      	adds	r0, #1
    704e:	d0d7      	beq.n	7000 <_puts_r+0x38>
    7050:	250a      	movs	r5, #10
    7052:	e7d7      	b.n	7004 <_puts_r+0x3c>
    7054:	4622      	mov	r2, r4
    7056:	4628      	mov	r0, r5
    7058:	f000 f886 	bl	7168 <__swbuf_r>
    705c:	3001      	adds	r0, #1
    705e:	d1e7      	bne.n	7030 <_puts_r+0x68>
    7060:	e7ce      	b.n	7000 <_puts_r+0x38>
    7062:	3e01      	subs	r6, #1
    7064:	e7e4      	b.n	7030 <_puts_r+0x68>
    7066:	6823      	ldr	r3, [r4, #0]
    7068:	1c5a      	adds	r2, r3, #1
    706a:	6022      	str	r2, [r4, #0]
    706c:	220a      	movs	r2, #10
    706e:	701a      	strb	r2, [r3, #0]
    7070:	e7ee      	b.n	7050 <_puts_r+0x88>
	...

00007074 <puts>:
    7074:	4b02      	ldr	r3, [pc, #8]	@ (7080 <puts+0xc>)
    7076:	4601      	mov	r1, r0
    7078:	6818      	ldr	r0, [r3, #0]
    707a:	f7ff bfa5 	b.w	6fc8 <_puts_r>
    707e:	bf00      	nop
    7080:	20000054 	.word	0x20000054

00007084 <siscanf>:
    7084:	b40e      	push	{r1, r2, r3}
    7086:	f44f 7201 	mov.w	r2, #516	@ 0x204
    708a:	b570      	push	{r4, r5, r6, lr}
    708c:	2500      	movs	r5, #0
    708e:	b09d      	sub	sp, #116	@ 0x74
    7090:	ac21      	add	r4, sp, #132	@ 0x84
    7092:	f854 6b04 	ldr.w	r6, [r4], #4
    7096:	f8ad 2014 	strh.w	r2, [sp, #20]
    709a:	951b      	str	r5, [sp, #108]	@ 0x6c
    709c:	9002      	str	r0, [sp, #8]
    709e:	9006      	str	r0, [sp, #24]
    70a0:	f000 f9e7 	bl	7472 <strlen>
    70a4:	4b0b      	ldr	r3, [pc, #44]	@ (70d4 <siscanf+0x50>)
    70a6:	9003      	str	r0, [sp, #12]
    70a8:	930b      	str	r3, [sp, #44]	@ 0x2c
    70aa:	f64f 73ff 	movw	r3, #65535	@ 0xffff
    70ae:	9007      	str	r0, [sp, #28]
    70b0:	4809      	ldr	r0, [pc, #36]	@ (70d8 <siscanf+0x54>)
    70b2:	f8ad 3016 	strh.w	r3, [sp, #22]
    70b6:	4632      	mov	r2, r6
    70b8:	4623      	mov	r3, r4
    70ba:	a902      	add	r1, sp, #8
    70bc:	6800      	ldr	r0, [r0, #0]
    70be:	950f      	str	r5, [sp, #60]	@ 0x3c
    70c0:	9514      	str	r5, [sp, #80]	@ 0x50
    70c2:	9401      	str	r4, [sp, #4]
    70c4:	f000 fb5c 	bl	7780 <__ssvfiscanf_r>
    70c8:	b01d      	add	sp, #116	@ 0x74
    70ca:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    70ce:	b003      	add	sp, #12
    70d0:	4770      	bx	lr
    70d2:	bf00      	nop
    70d4:	000070ff 	.word	0x000070ff
    70d8:	20000054 	.word	0x20000054

000070dc <__sread>:
    70dc:	b510      	push	{r4, lr}
    70de:	460c      	mov	r4, r1
    70e0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    70e4:	f000 f978 	bl	73d8 <_read_r>
    70e8:	2800      	cmp	r0, #0
    70ea:	bfab      	itete	ge
    70ec:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
    70ee:	89a3      	ldrhlt	r3, [r4, #12]
    70f0:	181b      	addge	r3, r3, r0
    70f2:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
    70f6:	bfac      	ite	ge
    70f8:	6563      	strge	r3, [r4, #84]	@ 0x54
    70fa:	81a3      	strhlt	r3, [r4, #12]
    70fc:	bd10      	pop	{r4, pc}

000070fe <__seofread>:
    70fe:	2000      	movs	r0, #0
    7100:	4770      	bx	lr

00007102 <__swrite>:
    7102:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7106:	461f      	mov	r7, r3
    7108:	898b      	ldrh	r3, [r1, #12]
    710a:	4605      	mov	r5, r0
    710c:	05db      	lsls	r3, r3, #23
    710e:	460c      	mov	r4, r1
    7110:	4616      	mov	r6, r2
    7112:	d505      	bpl.n	7120 <__swrite+0x1e>
    7114:	2302      	movs	r3, #2
    7116:	2200      	movs	r2, #0
    7118:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    711c:	f000 f94a 	bl	73b4 <_lseek_r>
    7120:	89a3      	ldrh	r3, [r4, #12]
    7122:	4632      	mov	r2, r6
    7124:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
    7128:	81a3      	strh	r3, [r4, #12]
    712a:	4628      	mov	r0, r5
    712c:	463b      	mov	r3, r7
    712e:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    7132:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    7136:	f7f9 baae 	b.w	696 <_write_r>

0000713a <__sseek>:
    713a:	b510      	push	{r4, lr}
    713c:	460c      	mov	r4, r1
    713e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    7142:	f000 f937 	bl	73b4 <_lseek_r>
    7146:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    714a:	1c42      	adds	r2, r0, #1
    714c:	bf0b      	itete	eq
    714e:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
    7152:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
    7156:	81a3      	strheq	r3, [r4, #12]
    7158:	81a3      	strhne	r3, [r4, #12]
    715a:	bf18      	it	ne
    715c:	6560      	strne	r0, [r4, #84]	@ 0x54
    715e:	bd10      	pop	{r4, pc}

00007160 <__sclose>:
    7160:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    7164:	f000 b916 	b.w	7394 <_close_r>

00007168 <__swbuf_r>:
    7168:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    716a:	460e      	mov	r6, r1
    716c:	4614      	mov	r4, r2
    716e:	4605      	mov	r5, r0
    7170:	b118      	cbz	r0, 717a <__swbuf_r+0x12>
    7172:	6a03      	ldr	r3, [r0, #32]
    7174:	b90b      	cbnz	r3, 717a <__swbuf_r+0x12>
    7176:	f7ff fea3 	bl	6ec0 <__sinit>
    717a:	69a3      	ldr	r3, [r4, #24]
    717c:	60a3      	str	r3, [r4, #8]
    717e:	89a3      	ldrh	r3, [r4, #12]
    7180:	071a      	lsls	r2, r3, #28
    7182:	d501      	bpl.n	7188 <__swbuf_r+0x20>
    7184:	6923      	ldr	r3, [r4, #16]
    7186:	b943      	cbnz	r3, 719a <__swbuf_r+0x32>
    7188:	4621      	mov	r1, r4
    718a:	4628      	mov	r0, r5
    718c:	f000 f82a 	bl	71e4 <__swsetup_r>
    7190:	b118      	cbz	r0, 719a <__swbuf_r+0x32>
    7192:	f04f 37ff 	mov.w	r7, #4294967295
    7196:	4638      	mov	r0, r7
    7198:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    719a:	6823      	ldr	r3, [r4, #0]
    719c:	6922      	ldr	r2, [r4, #16]
    719e:	b2f6      	uxtb	r6, r6
    71a0:	1a98      	subs	r0, r3, r2
    71a2:	6963      	ldr	r3, [r4, #20]
    71a4:	4637      	mov	r7, r6
    71a6:	4283      	cmp	r3, r0
    71a8:	dc05      	bgt.n	71b6 <__swbuf_r+0x4e>
    71aa:	4621      	mov	r1, r4
    71ac:	4628      	mov	r0, r5
    71ae:	f7ff fdbd 	bl	6d2c <_fflush_r>
    71b2:	2800      	cmp	r0, #0
    71b4:	d1ed      	bne.n	7192 <__swbuf_r+0x2a>
    71b6:	68a3      	ldr	r3, [r4, #8]
    71b8:	3b01      	subs	r3, #1
    71ba:	60a3      	str	r3, [r4, #8]
    71bc:	6823      	ldr	r3, [r4, #0]
    71be:	1c5a      	adds	r2, r3, #1
    71c0:	6022      	str	r2, [r4, #0]
    71c2:	701e      	strb	r6, [r3, #0]
    71c4:	6962      	ldr	r2, [r4, #20]
    71c6:	1c43      	adds	r3, r0, #1
    71c8:	429a      	cmp	r2, r3
    71ca:	d004      	beq.n	71d6 <__swbuf_r+0x6e>
    71cc:	89a3      	ldrh	r3, [r4, #12]
    71ce:	07db      	lsls	r3, r3, #31
    71d0:	d5e1      	bpl.n	7196 <__swbuf_r+0x2e>
    71d2:	2e0a      	cmp	r6, #10
    71d4:	d1df      	bne.n	7196 <__swbuf_r+0x2e>
    71d6:	4621      	mov	r1, r4
    71d8:	4628      	mov	r0, r5
    71da:	f7ff fda7 	bl	6d2c <_fflush_r>
    71de:	2800      	cmp	r0, #0
    71e0:	d0d9      	beq.n	7196 <__swbuf_r+0x2e>
    71e2:	e7d6      	b.n	7192 <__swbuf_r+0x2a>

000071e4 <__swsetup_r>:
    71e4:	b538      	push	{r3, r4, r5, lr}
    71e6:	4b28      	ldr	r3, [pc, #160]	@ (7288 <__swsetup_r+0xa4>)
    71e8:	4605      	mov	r5, r0
    71ea:	6818      	ldr	r0, [r3, #0]
    71ec:	460c      	mov	r4, r1
    71ee:	b118      	cbz	r0, 71f8 <__swsetup_r+0x14>
    71f0:	6a03      	ldr	r3, [r0, #32]
    71f2:	b90b      	cbnz	r3, 71f8 <__swsetup_r+0x14>
    71f4:	f7ff fe64 	bl	6ec0 <__sinit>
    71f8:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    71fc:	071a      	lsls	r2, r3, #28
    71fe:	d421      	bmi.n	7244 <__swsetup_r+0x60>
    7200:	06d8      	lsls	r0, r3, #27
    7202:	d407      	bmi.n	7214 <__swsetup_r+0x30>
    7204:	2209      	movs	r2, #9
    7206:	602a      	str	r2, [r5, #0]
    7208:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
    720c:	f04f 30ff 	mov.w	r0, #4294967295
    7210:	81a3      	strh	r3, [r4, #12]
    7212:	e030      	b.n	7276 <__swsetup_r+0x92>
    7214:	0759      	lsls	r1, r3, #29
    7216:	d512      	bpl.n	723e <__swsetup_r+0x5a>
    7218:	6b61      	ldr	r1, [r4, #52]	@ 0x34
    721a:	b141      	cbz	r1, 722e <__swsetup_r+0x4a>
    721c:	f104 0344 	add.w	r3, r4, #68	@ 0x44
    7220:	4299      	cmp	r1, r3
    7222:	d002      	beq.n	722a <__swsetup_r+0x46>
    7224:	4628      	mov	r0, r5
    7226:	f000 f94b 	bl	74c0 <_free_r>
    722a:	2300      	movs	r3, #0
    722c:	6363      	str	r3, [r4, #52]	@ 0x34
    722e:	2200      	movs	r2, #0
    7230:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    7234:	6062      	str	r2, [r4, #4]
    7236:	6922      	ldr	r2, [r4, #16]
    7238:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
    723c:	6022      	str	r2, [r4, #0]
    723e:	f043 0308 	orr.w	r3, r3, #8
    7242:	81a3      	strh	r3, [r4, #12]
    7244:	6922      	ldr	r2, [r4, #16]
    7246:	b93a      	cbnz	r2, 7258 <__swsetup_r+0x74>
    7248:	059a      	lsls	r2, r3, #22
    724a:	d501      	bpl.n	7250 <__swsetup_r+0x6c>
    724c:	0618      	lsls	r0, r3, #24
    724e:	d503      	bpl.n	7258 <__swsetup_r+0x74>
    7250:	4621      	mov	r1, r4
    7252:	4628      	mov	r0, r5
    7254:	f001 f864 	bl	8320 <__smakebuf_r>
    7258:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    725c:	f013 0201 	ands.w	r2, r3, #1
    7260:	d00a      	beq.n	7278 <__swsetup_r+0x94>
    7262:	2200      	movs	r2, #0
    7264:	60a2      	str	r2, [r4, #8]
    7266:	6962      	ldr	r2, [r4, #20]
    7268:	4252      	negs	r2, r2
    726a:	61a2      	str	r2, [r4, #24]
    726c:	6922      	ldr	r2, [r4, #16]
    726e:	b942      	cbnz	r2, 7282 <__swsetup_r+0x9e>
    7270:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
    7274:	d1c8      	bne.n	7208 <__swsetup_r+0x24>
    7276:	bd38      	pop	{r3, r4, r5, pc}
    7278:	0799      	lsls	r1, r3, #30
    727a:	bf58      	it	pl
    727c:	6962      	ldrpl	r2, [r4, #20]
    727e:	60a2      	str	r2, [r4, #8]
    7280:	e7f4      	b.n	726c <__swsetup_r+0x88>
    7282:	2000      	movs	r0, #0
    7284:	e7f7      	b.n	7276 <__swsetup_r+0x92>
    7286:	bf00      	nop
    7288:	20000054 	.word	0x20000054

0000728c <memset>:
    728c:	4603      	mov	r3, r0
    728e:	4402      	add	r2, r0
    7290:	4293      	cmp	r3, r2
    7292:	d100      	bne.n	7296 <memset+0xa>
    7294:	4770      	bx	lr
    7296:	f803 1b01 	strb.w	r1, [r3], #1
    729a:	e7f9      	b.n	7290 <memset+0x4>

0000729c <strchr>:
    729c:	4603      	mov	r3, r0
    729e:	b2c9      	uxtb	r1, r1
    72a0:	4618      	mov	r0, r3
    72a2:	f813 2b01 	ldrb.w	r2, [r3], #1
    72a6:	b112      	cbz	r2, 72ae <strchr+0x12>
    72a8:	428a      	cmp	r2, r1
    72aa:	d1f9      	bne.n	72a0 <strchr+0x4>
    72ac:	4770      	bx	lr
    72ae:	2900      	cmp	r1, #0
    72b0:	bf18      	it	ne
    72b2:	2000      	movne	r0, #0
    72b4:	4770      	bx	lr

000072b6 <strncmp>:
    72b6:	b510      	push	{r4, lr}
    72b8:	b16a      	cbz	r2, 72d6 <strncmp+0x20>
    72ba:	3901      	subs	r1, #1
    72bc:	1884      	adds	r4, r0, r2
    72be:	f810 2b01 	ldrb.w	r2, [r0], #1
    72c2:	f811 3f01 	ldrb.w	r3, [r1, #1]!
    72c6:	429a      	cmp	r2, r3
    72c8:	d103      	bne.n	72d2 <strncmp+0x1c>
    72ca:	42a0      	cmp	r0, r4
    72cc:	d001      	beq.n	72d2 <strncmp+0x1c>
    72ce:	2a00      	cmp	r2, #0
    72d0:	d1f5      	bne.n	72be <strncmp+0x8>
    72d2:	1ad0      	subs	r0, r2, r3
    72d4:	bd10      	pop	{r4, pc}
    72d6:	4610      	mov	r0, r2
    72d8:	e7fc      	b.n	72d4 <strncmp+0x1e>
	...

000072dc <strtok>:
    72dc:	4b16      	ldr	r3, [pc, #88]	@ (7338 <strtok+0x5c>)
    72de:	b570      	push	{r4, r5, r6, lr}
    72e0:	681e      	ldr	r6, [r3, #0]
    72e2:	4604      	mov	r4, r0
    72e4:	6c72      	ldr	r2, [r6, #68]	@ 0x44
    72e6:	460d      	mov	r5, r1
    72e8:	b9f2      	cbnz	r2, 7328 <strtok+0x4c>
    72ea:	2050      	movs	r0, #80	@ 0x50
    72ec:	f000 f930 	bl	7550 <malloc>
    72f0:	4602      	mov	r2, r0
    72f2:	6470      	str	r0, [r6, #68]	@ 0x44
    72f4:	b920      	cbnz	r0, 7300 <strtok+0x24>
    72f6:	215b      	movs	r1, #91	@ 0x5b
    72f8:	4b10      	ldr	r3, [pc, #64]	@ (733c <strtok+0x60>)
    72fa:	4811      	ldr	r0, [pc, #68]	@ (7340 <strtok+0x64>)
    72fc:	f000 f8c2 	bl	7484 <__assert_func>
    7300:	2300      	movs	r3, #0
    7302:	e9c0 3300 	strd	r3, r3, [r0]
    7306:	e9c0 3302 	strd	r3, r3, [r0, #8]
    730a:	e9c0 3304 	strd	r3, r3, [r0, #16]
    730e:	e9c0 330a 	strd	r3, r3, [r0, #40]	@ 0x28
    7312:	e9c0 330c 	strd	r3, r3, [r0, #48]	@ 0x30
    7316:	e9c0 330e 	strd	r3, r3, [r0, #56]	@ 0x38
    731a:	e9c0 3310 	strd	r3, r3, [r0, #64]	@ 0x40
    731e:	e9c0 3312 	strd	r3, r3, [r0, #72]	@ 0x48
    7322:	6183      	str	r3, [r0, #24]
    7324:	7703      	strb	r3, [r0, #28]
    7326:	6243      	str	r3, [r0, #36]	@ 0x24
    7328:	4629      	mov	r1, r5
    732a:	4620      	mov	r0, r4
    732c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    7330:	2301      	movs	r3, #1
    7332:	f000 b807 	b.w	7344 <__strtok_r>
    7336:	bf00      	nop
    7338:	20000054 	.word	0x20000054
    733c:	0000b979 	.word	0x0000b979
    7340:	0000b990 	.word	0x0000b990

00007344 <__strtok_r>:
    7344:	b5f0      	push	{r4, r5, r6, r7, lr}
    7346:	4604      	mov	r4, r0
    7348:	b908      	cbnz	r0, 734e <__strtok_r+0xa>
    734a:	6814      	ldr	r4, [r2, #0]
    734c:	b144      	cbz	r4, 7360 <__strtok_r+0x1c>
    734e:	460f      	mov	r7, r1
    7350:	4620      	mov	r0, r4
    7352:	f814 5b01 	ldrb.w	r5, [r4], #1
    7356:	f817 6b01 	ldrb.w	r6, [r7], #1
    735a:	b91e      	cbnz	r6, 7364 <__strtok_r+0x20>
    735c:	b965      	cbnz	r5, 7378 <__strtok_r+0x34>
    735e:	6015      	str	r5, [r2, #0]
    7360:	2000      	movs	r0, #0
    7362:	e005      	b.n	7370 <__strtok_r+0x2c>
    7364:	42b5      	cmp	r5, r6
    7366:	d1f6      	bne.n	7356 <__strtok_r+0x12>
    7368:	2b00      	cmp	r3, #0
    736a:	d1f0      	bne.n	734e <__strtok_r+0xa>
    736c:	6014      	str	r4, [r2, #0]
    736e:	7003      	strb	r3, [r0, #0]
    7370:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7372:	461c      	mov	r4, r3
    7374:	e00c      	b.n	7390 <__strtok_r+0x4c>
    7376:	b91d      	cbnz	r5, 7380 <__strtok_r+0x3c>
    7378:	460e      	mov	r6, r1
    737a:	4627      	mov	r7, r4
    737c:	f814 3b01 	ldrb.w	r3, [r4], #1
    7380:	f816 5b01 	ldrb.w	r5, [r6], #1
    7384:	42ab      	cmp	r3, r5
    7386:	d1f6      	bne.n	7376 <__strtok_r+0x32>
    7388:	2b00      	cmp	r3, #0
    738a:	d0f2      	beq.n	7372 <__strtok_r+0x2e>
    738c:	2300      	movs	r3, #0
    738e:	703b      	strb	r3, [r7, #0]
    7390:	6014      	str	r4, [r2, #0]
    7392:	e7ed      	b.n	7370 <__strtok_r+0x2c>

00007394 <_close_r>:
    7394:	b538      	push	{r3, r4, r5, lr}
    7396:	2300      	movs	r3, #0
    7398:	4d05      	ldr	r5, [pc, #20]	@ (73b0 <_close_r+0x1c>)
    739a:	4604      	mov	r4, r0
    739c:	4608      	mov	r0, r1
    739e:	602b      	str	r3, [r5, #0]
    73a0:	f7f9 f920 	bl	5e4 <_close>
    73a4:	1c43      	adds	r3, r0, #1
    73a6:	d102      	bne.n	73ae <_close_r+0x1a>
    73a8:	682b      	ldr	r3, [r5, #0]
    73aa:	b103      	cbz	r3, 73ae <_close_r+0x1a>
    73ac:	6023      	str	r3, [r4, #0]
    73ae:	bd38      	pop	{r3, r4, r5, pc}
    73b0:	20004764 	.word	0x20004764

000073b4 <_lseek_r>:
    73b4:	b538      	push	{r3, r4, r5, lr}
    73b6:	4604      	mov	r4, r0
    73b8:	4608      	mov	r0, r1
    73ba:	4611      	mov	r1, r2
    73bc:	2200      	movs	r2, #0
    73be:	4d05      	ldr	r5, [pc, #20]	@ (73d4 <_lseek_r+0x20>)
    73c0:	602a      	str	r2, [r5, #0]
    73c2:	461a      	mov	r2, r3
    73c4:	f7f9 f94f 	bl	666 <_lseek>
    73c8:	1c43      	adds	r3, r0, #1
    73ca:	d102      	bne.n	73d2 <_lseek_r+0x1e>
    73cc:	682b      	ldr	r3, [r5, #0]
    73ce:	b103      	cbz	r3, 73d2 <_lseek_r+0x1e>
    73d0:	6023      	str	r3, [r4, #0]
    73d2:	bd38      	pop	{r3, r4, r5, pc}
    73d4:	20004764 	.word	0x20004764

000073d8 <_read_r>:
    73d8:	b538      	push	{r3, r4, r5, lr}
    73da:	4604      	mov	r4, r0
    73dc:	4608      	mov	r0, r1
    73de:	4611      	mov	r1, r2
    73e0:	2200      	movs	r2, #0
    73e2:	4d05      	ldr	r5, [pc, #20]	@ (73f8 <_read_r+0x20>)
    73e4:	602a      	str	r2, [r5, #0]
    73e6:	461a      	mov	r2, r3
    73e8:	f7f9 f949 	bl	67e <_read>
    73ec:	1c43      	adds	r3, r0, #1
    73ee:	d102      	bne.n	73f6 <_read_r+0x1e>
    73f0:	682b      	ldr	r3, [r5, #0]
    73f2:	b103      	cbz	r3, 73f6 <_read_r+0x1e>
    73f4:	6023      	str	r3, [r4, #0]
    73f6:	bd38      	pop	{r3, r4, r5, pc}
    73f8:	20004764 	.word	0x20004764

000073fc <__errno>:
    73fc:	4b01      	ldr	r3, [pc, #4]	@ (7404 <__errno+0x8>)
    73fe:	6818      	ldr	r0, [r3, #0]
    7400:	4770      	bx	lr
    7402:	bf00      	nop
    7404:	20000054 	.word	0x20000054

00007408 <__libc_init_array>:
    7408:	b570      	push	{r4, r5, r6, lr}
    740a:	2600      	movs	r6, #0
    740c:	4d0c      	ldr	r5, [pc, #48]	@ (7440 <__libc_init_array+0x38>)
    740e:	4b0d      	ldr	r3, [pc, #52]	@ (7444 <__libc_init_array+0x3c>)
    7410:	1b5b      	subs	r3, r3, r5
    7412:	109c      	asrs	r4, r3, #2
    7414:	42a6      	cmp	r6, r4
    7416:	d109      	bne.n	742c <__libc_init_array+0x24>
    7418:	2600      	movs	r6, #0
    741a:	f004 fb47 	bl	baac <_init>
    741e:	4d0a      	ldr	r5, [pc, #40]	@ (7448 <__libc_init_array+0x40>)
    7420:	4b0a      	ldr	r3, [pc, #40]	@ (744c <__libc_init_array+0x44>)
    7422:	1b5b      	subs	r3, r3, r5
    7424:	109c      	asrs	r4, r3, #2
    7426:	42a6      	cmp	r6, r4
    7428:	d105      	bne.n	7436 <__libc_init_array+0x2e>
    742a:	bd70      	pop	{r4, r5, r6, pc}
    742c:	f855 3b04 	ldr.w	r3, [r5], #4
    7430:	4798      	blx	r3
    7432:	3601      	adds	r6, #1
    7434:	e7ee      	b.n	7414 <__libc_init_array+0xc>
    7436:	f855 3b04 	ldr.w	r3, [r5], #4
    743a:	4798      	blx	r3
    743c:	3601      	adds	r6, #1
    743e:	e7f2      	b.n	7426 <__libc_init_array+0x1e>
    7440:	0000bac4 	.word	0x0000bac4
    7444:	0000bac4 	.word	0x0000bac4
    7448:	0000bac4 	.word	0x0000bac4
    744c:	0000bad8 	.word	0x0000bad8

00007450 <__retarget_lock_init_recursive>:
    7450:	4770      	bx	lr

00007452 <__retarget_lock_acquire_recursive>:
    7452:	4770      	bx	lr

00007454 <__retarget_lock_release_recursive>:
    7454:	4770      	bx	lr

00007456 <memcpy>:
    7456:	440a      	add	r2, r1
    7458:	4291      	cmp	r1, r2
    745a:	f100 33ff 	add.w	r3, r0, #4294967295
    745e:	d100      	bne.n	7462 <memcpy+0xc>
    7460:	4770      	bx	lr
    7462:	b510      	push	{r4, lr}
    7464:	f811 4b01 	ldrb.w	r4, [r1], #1
    7468:	4291      	cmp	r1, r2
    746a:	f803 4f01 	strb.w	r4, [r3, #1]!
    746e:	d1f9      	bne.n	7464 <memcpy+0xe>
    7470:	bd10      	pop	{r4, pc}

00007472 <strlen>:
    7472:	4603      	mov	r3, r0
    7474:	f813 2b01 	ldrb.w	r2, [r3], #1
    7478:	2a00      	cmp	r2, #0
    747a:	d1fb      	bne.n	7474 <strlen+0x2>
    747c:	1a18      	subs	r0, r3, r0
    747e:	3801      	subs	r0, #1
    7480:	4770      	bx	lr
	...

00007484 <__assert_func>:
    7484:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    7486:	4614      	mov	r4, r2
    7488:	461a      	mov	r2, r3
    748a:	4b09      	ldr	r3, [pc, #36]	@ (74b0 <__assert_func+0x2c>)
    748c:	4605      	mov	r5, r0
    748e:	681b      	ldr	r3, [r3, #0]
    7490:	68d8      	ldr	r0, [r3, #12]
    7492:	b14c      	cbz	r4, 74a8 <__assert_func+0x24>
    7494:	4b07      	ldr	r3, [pc, #28]	@ (74b4 <__assert_func+0x30>)
    7496:	e9cd 3401 	strd	r3, r4, [sp, #4]
    749a:	9100      	str	r1, [sp, #0]
    749c:	462b      	mov	r3, r5
    749e:	4906      	ldr	r1, [pc, #24]	@ (74b8 <__assert_func+0x34>)
    74a0:	f000 ff08 	bl	82b4 <fiprintf>
    74a4:	f001 f826 	bl	84f4 <abort>
    74a8:	4b04      	ldr	r3, [pc, #16]	@ (74bc <__assert_func+0x38>)
    74aa:	461c      	mov	r4, r3
    74ac:	e7f3      	b.n	7496 <__assert_func+0x12>
    74ae:	bf00      	nop
    74b0:	20000054 	.word	0x20000054
    74b4:	0000ba14 	.word	0x0000ba14
    74b8:	0000ba21 	.word	0x0000ba21
    74bc:	0000ba4f 	.word	0x0000ba4f

000074c0 <_free_r>:
    74c0:	b538      	push	{r3, r4, r5, lr}
    74c2:	4605      	mov	r5, r0
    74c4:	2900      	cmp	r1, #0
    74c6:	d040      	beq.n	754a <_free_r+0x8a>
    74c8:	f851 3c04 	ldr.w	r3, [r1, #-4]
    74cc:	1f0c      	subs	r4, r1, #4
    74ce:	2b00      	cmp	r3, #0
    74d0:	bfb8      	it	lt
    74d2:	18e4      	addlt	r4, r4, r3
    74d4:	f000 f8ee 	bl	76b4 <__malloc_lock>
    74d8:	4a1c      	ldr	r2, [pc, #112]	@ (754c <_free_r+0x8c>)
    74da:	6813      	ldr	r3, [r2, #0]
    74dc:	b933      	cbnz	r3, 74ec <_free_r+0x2c>
    74de:	6063      	str	r3, [r4, #4]
    74e0:	6014      	str	r4, [r2, #0]
    74e2:	4628      	mov	r0, r5
    74e4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    74e8:	f000 b8ea 	b.w	76c0 <__malloc_unlock>
    74ec:	42a3      	cmp	r3, r4
    74ee:	d908      	bls.n	7502 <_free_r+0x42>
    74f0:	6820      	ldr	r0, [r4, #0]
    74f2:	1821      	adds	r1, r4, r0
    74f4:	428b      	cmp	r3, r1
    74f6:	bf01      	itttt	eq
    74f8:	6819      	ldreq	r1, [r3, #0]
    74fa:	685b      	ldreq	r3, [r3, #4]
    74fc:	1809      	addeq	r1, r1, r0
    74fe:	6021      	streq	r1, [r4, #0]
    7500:	e7ed      	b.n	74de <_free_r+0x1e>
    7502:	461a      	mov	r2, r3
    7504:	685b      	ldr	r3, [r3, #4]
    7506:	b10b      	cbz	r3, 750c <_free_r+0x4c>
    7508:	42a3      	cmp	r3, r4
    750a:	d9fa      	bls.n	7502 <_free_r+0x42>
    750c:	6811      	ldr	r1, [r2, #0]
    750e:	1850      	adds	r0, r2, r1
    7510:	42a0      	cmp	r0, r4
    7512:	d10b      	bne.n	752c <_free_r+0x6c>
    7514:	6820      	ldr	r0, [r4, #0]
    7516:	4401      	add	r1, r0
    7518:	1850      	adds	r0, r2, r1
    751a:	4283      	cmp	r3, r0
    751c:	6011      	str	r1, [r2, #0]
    751e:	d1e0      	bne.n	74e2 <_free_r+0x22>
    7520:	6818      	ldr	r0, [r3, #0]
    7522:	685b      	ldr	r3, [r3, #4]
    7524:	4408      	add	r0, r1
    7526:	6010      	str	r0, [r2, #0]
    7528:	6053      	str	r3, [r2, #4]
    752a:	e7da      	b.n	74e2 <_free_r+0x22>
    752c:	d902      	bls.n	7534 <_free_r+0x74>
    752e:	230c      	movs	r3, #12
    7530:	602b      	str	r3, [r5, #0]
    7532:	e7d6      	b.n	74e2 <_free_r+0x22>
    7534:	6820      	ldr	r0, [r4, #0]
    7536:	1821      	adds	r1, r4, r0
    7538:	428b      	cmp	r3, r1
    753a:	bf01      	itttt	eq
    753c:	6819      	ldreq	r1, [r3, #0]
    753e:	685b      	ldreq	r3, [r3, #4]
    7540:	1809      	addeq	r1, r1, r0
    7542:	6021      	streq	r1, [r4, #0]
    7544:	6063      	str	r3, [r4, #4]
    7546:	6054      	str	r4, [r2, #4]
    7548:	e7cb      	b.n	74e2 <_free_r+0x22>
    754a:	bd38      	pop	{r3, r4, r5, pc}
    754c:	20004770 	.word	0x20004770

00007550 <malloc>:
    7550:	4b02      	ldr	r3, [pc, #8]	@ (755c <malloc+0xc>)
    7552:	4601      	mov	r1, r0
    7554:	6818      	ldr	r0, [r3, #0]
    7556:	f000 b82d 	b.w	75b4 <_malloc_r>
    755a:	bf00      	nop
    755c:	20000054 	.word	0x20000054

00007560 <free>:
    7560:	4b02      	ldr	r3, [pc, #8]	@ (756c <free+0xc>)
    7562:	4601      	mov	r1, r0
    7564:	6818      	ldr	r0, [r3, #0]
    7566:	f7ff bfab 	b.w	74c0 <_free_r>
    756a:	bf00      	nop
    756c:	20000054 	.word	0x20000054

00007570 <sbrk_aligned>:
    7570:	b570      	push	{r4, r5, r6, lr}
    7572:	4e0f      	ldr	r6, [pc, #60]	@ (75b0 <sbrk_aligned+0x40>)
    7574:	460c      	mov	r4, r1
    7576:	6831      	ldr	r1, [r6, #0]
    7578:	4605      	mov	r5, r0
    757a:	b911      	cbnz	r1, 7582 <sbrk_aligned+0x12>
    757c:	f000 ff9c 	bl	84b8 <_sbrk_r>
    7580:	6030      	str	r0, [r6, #0]
    7582:	4621      	mov	r1, r4
    7584:	4628      	mov	r0, r5
    7586:	f000 ff97 	bl	84b8 <_sbrk_r>
    758a:	1c43      	adds	r3, r0, #1
    758c:	d103      	bne.n	7596 <sbrk_aligned+0x26>
    758e:	f04f 34ff 	mov.w	r4, #4294967295
    7592:	4620      	mov	r0, r4
    7594:	bd70      	pop	{r4, r5, r6, pc}
    7596:	1cc4      	adds	r4, r0, #3
    7598:	f024 0403 	bic.w	r4, r4, #3
    759c:	42a0      	cmp	r0, r4
    759e:	d0f8      	beq.n	7592 <sbrk_aligned+0x22>
    75a0:	1a21      	subs	r1, r4, r0
    75a2:	4628      	mov	r0, r5
    75a4:	f000 ff88 	bl	84b8 <_sbrk_r>
    75a8:	3001      	adds	r0, #1
    75aa:	d1f2      	bne.n	7592 <sbrk_aligned+0x22>
    75ac:	e7ef      	b.n	758e <sbrk_aligned+0x1e>
    75ae:	bf00      	nop
    75b0:	2000476c 	.word	0x2000476c

000075b4 <_malloc_r>:
    75b4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    75b8:	1ccd      	adds	r5, r1, #3
    75ba:	f025 0503 	bic.w	r5, r5, #3
    75be:	3508      	adds	r5, #8
    75c0:	2d0c      	cmp	r5, #12
    75c2:	bf38      	it	cc
    75c4:	250c      	movcc	r5, #12
    75c6:	2d00      	cmp	r5, #0
    75c8:	4606      	mov	r6, r0
    75ca:	db01      	blt.n	75d0 <_malloc_r+0x1c>
    75cc:	42a9      	cmp	r1, r5
    75ce:	d904      	bls.n	75da <_malloc_r+0x26>
    75d0:	230c      	movs	r3, #12
    75d2:	6033      	str	r3, [r6, #0]
    75d4:	2000      	movs	r0, #0
    75d6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    75da:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 76b0 <_malloc_r+0xfc>
    75de:	f000 f869 	bl	76b4 <__malloc_lock>
    75e2:	f8d8 3000 	ldr.w	r3, [r8]
    75e6:	461c      	mov	r4, r3
    75e8:	bb44      	cbnz	r4, 763c <_malloc_r+0x88>
    75ea:	4629      	mov	r1, r5
    75ec:	4630      	mov	r0, r6
    75ee:	f7ff ffbf 	bl	7570 <sbrk_aligned>
    75f2:	1c43      	adds	r3, r0, #1
    75f4:	4604      	mov	r4, r0
    75f6:	d158      	bne.n	76aa <_malloc_r+0xf6>
    75f8:	f8d8 4000 	ldr.w	r4, [r8]
    75fc:	4627      	mov	r7, r4
    75fe:	2f00      	cmp	r7, #0
    7600:	d143      	bne.n	768a <_malloc_r+0xd6>
    7602:	2c00      	cmp	r4, #0
    7604:	d04b      	beq.n	769e <_malloc_r+0xea>
    7606:	6823      	ldr	r3, [r4, #0]
    7608:	4639      	mov	r1, r7
    760a:	4630      	mov	r0, r6
    760c:	eb04 0903 	add.w	r9, r4, r3
    7610:	f000 ff52 	bl	84b8 <_sbrk_r>
    7614:	4581      	cmp	r9, r0
    7616:	d142      	bne.n	769e <_malloc_r+0xea>
    7618:	6821      	ldr	r1, [r4, #0]
    761a:	4630      	mov	r0, r6
    761c:	1a6d      	subs	r5, r5, r1
    761e:	4629      	mov	r1, r5
    7620:	f7ff ffa6 	bl	7570 <sbrk_aligned>
    7624:	3001      	adds	r0, #1
    7626:	d03a      	beq.n	769e <_malloc_r+0xea>
    7628:	6823      	ldr	r3, [r4, #0]
    762a:	442b      	add	r3, r5
    762c:	6023      	str	r3, [r4, #0]
    762e:	f8d8 3000 	ldr.w	r3, [r8]
    7632:	685a      	ldr	r2, [r3, #4]
    7634:	bb62      	cbnz	r2, 7690 <_malloc_r+0xdc>
    7636:	f8c8 7000 	str.w	r7, [r8]
    763a:	e00f      	b.n	765c <_malloc_r+0xa8>
    763c:	6822      	ldr	r2, [r4, #0]
    763e:	1b52      	subs	r2, r2, r5
    7640:	d420      	bmi.n	7684 <_malloc_r+0xd0>
    7642:	2a0b      	cmp	r2, #11
    7644:	d917      	bls.n	7676 <_malloc_r+0xc2>
    7646:	1961      	adds	r1, r4, r5
    7648:	42a3      	cmp	r3, r4
    764a:	6025      	str	r5, [r4, #0]
    764c:	bf18      	it	ne
    764e:	6059      	strne	r1, [r3, #4]
    7650:	6863      	ldr	r3, [r4, #4]
    7652:	bf08      	it	eq
    7654:	f8c8 1000 	streq.w	r1, [r8]
    7658:	5162      	str	r2, [r4, r5]
    765a:	604b      	str	r3, [r1, #4]
    765c:	4630      	mov	r0, r6
    765e:	f000 f82f 	bl	76c0 <__malloc_unlock>
    7662:	f104 000b 	add.w	r0, r4, #11
    7666:	1d23      	adds	r3, r4, #4
    7668:	f020 0007 	bic.w	r0, r0, #7
    766c:	1ac2      	subs	r2, r0, r3
    766e:	bf1c      	itt	ne
    7670:	1a1b      	subne	r3, r3, r0
    7672:	50a3      	strne	r3, [r4, r2]
    7674:	e7af      	b.n	75d6 <_malloc_r+0x22>
    7676:	6862      	ldr	r2, [r4, #4]
    7678:	42a3      	cmp	r3, r4
    767a:	bf0c      	ite	eq
    767c:	f8c8 2000 	streq.w	r2, [r8]
    7680:	605a      	strne	r2, [r3, #4]
    7682:	e7eb      	b.n	765c <_malloc_r+0xa8>
    7684:	4623      	mov	r3, r4
    7686:	6864      	ldr	r4, [r4, #4]
    7688:	e7ae      	b.n	75e8 <_malloc_r+0x34>
    768a:	463c      	mov	r4, r7
    768c:	687f      	ldr	r7, [r7, #4]
    768e:	e7b6      	b.n	75fe <_malloc_r+0x4a>
    7690:	461a      	mov	r2, r3
    7692:	685b      	ldr	r3, [r3, #4]
    7694:	42a3      	cmp	r3, r4
    7696:	d1fb      	bne.n	7690 <_malloc_r+0xdc>
    7698:	2300      	movs	r3, #0
    769a:	6053      	str	r3, [r2, #4]
    769c:	e7de      	b.n	765c <_malloc_r+0xa8>
    769e:	230c      	movs	r3, #12
    76a0:	4630      	mov	r0, r6
    76a2:	6033      	str	r3, [r6, #0]
    76a4:	f000 f80c 	bl	76c0 <__malloc_unlock>
    76a8:	e794      	b.n	75d4 <_malloc_r+0x20>
    76aa:	6005      	str	r5, [r0, #0]
    76ac:	e7d6      	b.n	765c <_malloc_r+0xa8>
    76ae:	bf00      	nop
    76b0:	20004770 	.word	0x20004770

000076b4 <__malloc_lock>:
    76b4:	4801      	ldr	r0, [pc, #4]	@ (76bc <__malloc_lock+0x8>)
    76b6:	f7ff becc 	b.w	7452 <__retarget_lock_acquire_recursive>
    76ba:	bf00      	nop
    76bc:	20004768 	.word	0x20004768

000076c0 <__malloc_unlock>:
    76c0:	4801      	ldr	r0, [pc, #4]	@ (76c8 <__malloc_unlock+0x8>)
    76c2:	f7ff bec7 	b.w	7454 <__retarget_lock_release_recursive>
    76c6:	bf00      	nop
    76c8:	20004768 	.word	0x20004768

000076cc <_sungetc_r>:
    76cc:	b538      	push	{r3, r4, r5, lr}
    76ce:	1c4b      	adds	r3, r1, #1
    76d0:	4614      	mov	r4, r2
    76d2:	d103      	bne.n	76dc <_sungetc_r+0x10>
    76d4:	f04f 35ff 	mov.w	r5, #4294967295
    76d8:	4628      	mov	r0, r5
    76da:	bd38      	pop	{r3, r4, r5, pc}
    76dc:	8993      	ldrh	r3, [r2, #12]
    76de:	b2cd      	uxtb	r5, r1
    76e0:	f023 0320 	bic.w	r3, r3, #32
    76e4:	8193      	strh	r3, [r2, #12]
    76e6:	6b63      	ldr	r3, [r4, #52]	@ 0x34
    76e8:	6852      	ldr	r2, [r2, #4]
    76ea:	b18b      	cbz	r3, 7710 <_sungetc_r+0x44>
    76ec:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
    76ee:	4293      	cmp	r3, r2
    76f0:	dd08      	ble.n	7704 <_sungetc_r+0x38>
    76f2:	6823      	ldr	r3, [r4, #0]
    76f4:	1e5a      	subs	r2, r3, #1
    76f6:	6022      	str	r2, [r4, #0]
    76f8:	f803 5c01 	strb.w	r5, [r3, #-1]
    76fc:	6863      	ldr	r3, [r4, #4]
    76fe:	3301      	adds	r3, #1
    7700:	6063      	str	r3, [r4, #4]
    7702:	e7e9      	b.n	76d8 <_sungetc_r+0xc>
    7704:	4621      	mov	r1, r4
    7706:	f000 fe7d 	bl	8404 <__submore>
    770a:	2800      	cmp	r0, #0
    770c:	d0f1      	beq.n	76f2 <_sungetc_r+0x26>
    770e:	e7e1      	b.n	76d4 <_sungetc_r+0x8>
    7710:	6921      	ldr	r1, [r4, #16]
    7712:	6823      	ldr	r3, [r4, #0]
    7714:	b151      	cbz	r1, 772c <_sungetc_r+0x60>
    7716:	4299      	cmp	r1, r3
    7718:	d208      	bcs.n	772c <_sungetc_r+0x60>
    771a:	f813 1c01 	ldrb.w	r1, [r3, #-1]
    771e:	42a9      	cmp	r1, r5
    7720:	d104      	bne.n	772c <_sungetc_r+0x60>
    7722:	3b01      	subs	r3, #1
    7724:	3201      	adds	r2, #1
    7726:	6023      	str	r3, [r4, #0]
    7728:	6062      	str	r2, [r4, #4]
    772a:	e7d5      	b.n	76d8 <_sungetc_r+0xc>
    772c:	e9c4 320f 	strd	r3, r2, [r4, #60]	@ 0x3c
    7730:	f104 0344 	add.w	r3, r4, #68	@ 0x44
    7734:	6363      	str	r3, [r4, #52]	@ 0x34
    7736:	2303      	movs	r3, #3
    7738:	63a3      	str	r3, [r4, #56]	@ 0x38
    773a:	4623      	mov	r3, r4
    773c:	f803 5f46 	strb.w	r5, [r3, #70]!
    7740:	6023      	str	r3, [r4, #0]
    7742:	2301      	movs	r3, #1
    7744:	e7dc      	b.n	7700 <_sungetc_r+0x34>

00007746 <__ssrefill_r>:
    7746:	b510      	push	{r4, lr}
    7748:	460c      	mov	r4, r1
    774a:	6b49      	ldr	r1, [r1, #52]	@ 0x34
    774c:	b169      	cbz	r1, 776a <__ssrefill_r+0x24>
    774e:	f104 0344 	add.w	r3, r4, #68	@ 0x44
    7752:	4299      	cmp	r1, r3
    7754:	d001      	beq.n	775a <__ssrefill_r+0x14>
    7756:	f7ff feb3 	bl	74c0 <_free_r>
    775a:	2000      	movs	r0, #0
    775c:	6c23      	ldr	r3, [r4, #64]	@ 0x40
    775e:	6360      	str	r0, [r4, #52]	@ 0x34
    7760:	6063      	str	r3, [r4, #4]
    7762:	b113      	cbz	r3, 776a <__ssrefill_r+0x24>
    7764:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
    7766:	6023      	str	r3, [r4, #0]
    7768:	bd10      	pop	{r4, pc}
    776a:	6923      	ldr	r3, [r4, #16]
    776c:	f04f 30ff 	mov.w	r0, #4294967295
    7770:	6023      	str	r3, [r4, #0]
    7772:	2300      	movs	r3, #0
    7774:	6063      	str	r3, [r4, #4]
    7776:	89a3      	ldrh	r3, [r4, #12]
    7778:	f043 0320 	orr.w	r3, r3, #32
    777c:	81a3      	strh	r3, [r4, #12]
    777e:	e7f3      	b.n	7768 <__ssrefill_r+0x22>

00007780 <__ssvfiscanf_r>:
    7780:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7784:	460d      	mov	r5, r1
    7786:	2100      	movs	r1, #0
    7788:	f5ad 7d23 	sub.w	sp, sp, #652	@ 0x28c
    778c:	4607      	mov	r7, r0
    778e:	46e8      	mov	r8, sp
    7790:	ac41      	add	r4, sp, #260	@ 0x104
    7792:	e9c4 1103 	strd	r1, r1, [r4, #12]
    7796:	a901      	add	r1, sp, #4
    7798:	6161      	str	r1, [r4, #20]
    779a:	49ae      	ldr	r1, [pc, #696]	@ (7a54 <__ssvfiscanf_r+0x2d4>)
    779c:	f8df b2b8 	ldr.w	fp, [pc, #696]	@ 7a58 <__ssvfiscanf_r+0x2d8>
    77a0:	f8c4 117c 	str.w	r1, [r4, #380]	@ 0x17c
    77a4:	49ad      	ldr	r1, [pc, #692]	@ (7a5c <__ssvfiscanf_r+0x2dc>)
    77a6:	9300      	str	r3, [sp, #0]
    77a8:	f8c4 1180 	str.w	r1, [r4, #384]	@ 0x180
    77ac:	f892 9000 	ldrb.w	r9, [r2]
    77b0:	f1b9 0f00 	cmp.w	r9, #0
    77b4:	f000 8160 	beq.w	7a78 <__ssvfiscanf_r+0x2f8>
    77b8:	f81b 3009 	ldrb.w	r3, [fp, r9]
    77bc:	1c56      	adds	r6, r2, #1
    77be:	f013 0308 	ands.w	r3, r3, #8
    77c2:	d01b      	beq.n	77fc <__ssvfiscanf_r+0x7c>
    77c4:	686b      	ldr	r3, [r5, #4]
    77c6:	2b00      	cmp	r3, #0
    77c8:	dd10      	ble.n	77ec <__ssvfiscanf_r+0x6c>
    77ca:	682b      	ldr	r3, [r5, #0]
    77cc:	781a      	ldrb	r2, [r3, #0]
    77ce:	f81b 2002 	ldrb.w	r2, [fp, r2]
    77d2:	0712      	lsls	r2, r2, #28
    77d4:	d401      	bmi.n	77da <__ssvfiscanf_r+0x5a>
    77d6:	4632      	mov	r2, r6
    77d8:	e7e8      	b.n	77ac <__ssvfiscanf_r+0x2c>
    77da:	6922      	ldr	r2, [r4, #16]
    77dc:	3301      	adds	r3, #1
    77de:	3201      	adds	r2, #1
    77e0:	6122      	str	r2, [r4, #16]
    77e2:	686a      	ldr	r2, [r5, #4]
    77e4:	602b      	str	r3, [r5, #0]
    77e6:	3a01      	subs	r2, #1
    77e8:	606a      	str	r2, [r5, #4]
    77ea:	e7eb      	b.n	77c4 <__ssvfiscanf_r+0x44>
    77ec:	4629      	mov	r1, r5
    77ee:	4638      	mov	r0, r7
    77f0:	f8d4 3180 	ldr.w	r3, [r4, #384]	@ 0x180
    77f4:	4798      	blx	r3
    77f6:	2800      	cmp	r0, #0
    77f8:	d0e7      	beq.n	77ca <__ssvfiscanf_r+0x4a>
    77fa:	e7ec      	b.n	77d6 <__ssvfiscanf_r+0x56>
    77fc:	f1b9 0f25 	cmp.w	r9, #37	@ 0x25
    7800:	f040 8085 	bne.w	790e <__ssvfiscanf_r+0x18e>
    7804:	6023      	str	r3, [r4, #0]
    7806:	60a3      	str	r3, [r4, #8]
    7808:	7853      	ldrb	r3, [r2, #1]
    780a:	2b2a      	cmp	r3, #42	@ 0x2a
    780c:	bf04      	itt	eq
    780e:	2310      	moveq	r3, #16
    7810:	1c96      	addeq	r6, r2, #2
    7812:	f04f 020a 	mov.w	r2, #10
    7816:	bf08      	it	eq
    7818:	6023      	streq	r3, [r4, #0]
    781a:	46b2      	mov	sl, r6
    781c:	f81a 1b01 	ldrb.w	r1, [sl], #1
    7820:	f1a1 0330 	sub.w	r3, r1, #48	@ 0x30
    7824:	2b09      	cmp	r3, #9
    7826:	d91d      	bls.n	7864 <__ssvfiscanf_r+0xe4>
    7828:	4b8d      	ldr	r3, [pc, #564]	@ (7a60 <__ssvfiscanf_r+0x2e0>)
    782a:	2203      	movs	r2, #3
    782c:	4618      	mov	r0, r3
    782e:	f000 fe53 	bl	84d8 <memchr>
    7832:	b138      	cbz	r0, 7844 <__ssvfiscanf_r+0xc4>
    7834:	4b8a      	ldr	r3, [pc, #552]	@ (7a60 <__ssvfiscanf_r+0x2e0>)
    7836:	4656      	mov	r6, sl
    7838:	1ac0      	subs	r0, r0, r3
    783a:	2301      	movs	r3, #1
    783c:	6822      	ldr	r2, [r4, #0]
    783e:	4083      	lsls	r3, r0
    7840:	4313      	orrs	r3, r2
    7842:	6023      	str	r3, [r4, #0]
    7844:	f816 3b01 	ldrb.w	r3, [r6], #1
    7848:	2b78      	cmp	r3, #120	@ 0x78
    784a:	d806      	bhi.n	785a <__ssvfiscanf_r+0xda>
    784c:	2b57      	cmp	r3, #87	@ 0x57
    784e:	d810      	bhi.n	7872 <__ssvfiscanf_r+0xf2>
    7850:	2b25      	cmp	r3, #37	@ 0x25
    7852:	d05c      	beq.n	790e <__ssvfiscanf_r+0x18e>
    7854:	d856      	bhi.n	7904 <__ssvfiscanf_r+0x184>
    7856:	2b00      	cmp	r3, #0
    7858:	d075      	beq.n	7946 <__ssvfiscanf_r+0x1c6>
    785a:	2303      	movs	r3, #3
    785c:	61a3      	str	r3, [r4, #24]
    785e:	230a      	movs	r3, #10
    7860:	6063      	str	r3, [r4, #4]
    7862:	e088      	b.n	7976 <__ssvfiscanf_r+0x1f6>
    7864:	68a3      	ldr	r3, [r4, #8]
    7866:	4656      	mov	r6, sl
    7868:	fb02 1103 	mla	r1, r2, r3, r1
    786c:	3930      	subs	r1, #48	@ 0x30
    786e:	60a1      	str	r1, [r4, #8]
    7870:	e7d3      	b.n	781a <__ssvfiscanf_r+0x9a>
    7872:	f1a3 0258 	sub.w	r2, r3, #88	@ 0x58
    7876:	2a20      	cmp	r2, #32
    7878:	d8ef      	bhi.n	785a <__ssvfiscanf_r+0xda>
    787a:	a101      	add	r1, pc, #4	@ (adr r1, 7880 <__ssvfiscanf_r+0x100>)
    787c:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
    7880:	00007955 	.word	0x00007955
    7884:	0000785b 	.word	0x0000785b
    7888:	0000785b 	.word	0x0000785b
    788c:	000079b1 	.word	0x000079b1
    7890:	0000785b 	.word	0x0000785b
    7894:	0000785b 	.word	0x0000785b
    7898:	0000785b 	.word	0x0000785b
    789c:	0000785b 	.word	0x0000785b
    78a0:	0000785b 	.word	0x0000785b
    78a4:	0000785b 	.word	0x0000785b
    78a8:	0000785b 	.word	0x0000785b
    78ac:	000079c7 	.word	0x000079c7
    78b0:	000079ad 	.word	0x000079ad
    78b4:	0000790b 	.word	0x0000790b
    78b8:	0000790b 	.word	0x0000790b
    78bc:	0000790b 	.word	0x0000790b
    78c0:	0000785b 	.word	0x0000785b
    78c4:	00007967 	.word	0x00007967
    78c8:	0000785b 	.word	0x0000785b
    78cc:	0000785b 	.word	0x0000785b
    78d0:	0000785b 	.word	0x0000785b
    78d4:	0000785b 	.word	0x0000785b
    78d8:	000079d7 	.word	0x000079d7
    78dc:	0000796f 	.word	0x0000796f
    78e0:	0000794d 	.word	0x0000794d
    78e4:	0000785b 	.word	0x0000785b
    78e8:	0000785b 	.word	0x0000785b
    78ec:	000079d3 	.word	0x000079d3
    78f0:	0000785b 	.word	0x0000785b
    78f4:	000079ad 	.word	0x000079ad
    78f8:	0000785b 	.word	0x0000785b
    78fc:	0000785b 	.word	0x0000785b
    7900:	00007955 	.word	0x00007955
    7904:	3b45      	subs	r3, #69	@ 0x45
    7906:	2b02      	cmp	r3, #2
    7908:	d8a7      	bhi.n	785a <__ssvfiscanf_r+0xda>
    790a:	2305      	movs	r3, #5
    790c:	e032      	b.n	7974 <__ssvfiscanf_r+0x1f4>
    790e:	686b      	ldr	r3, [r5, #4]
    7910:	2b00      	cmp	r3, #0
    7912:	dd0d      	ble.n	7930 <__ssvfiscanf_r+0x1b0>
    7914:	682b      	ldr	r3, [r5, #0]
    7916:	781a      	ldrb	r2, [r3, #0]
    7918:	454a      	cmp	r2, r9
    791a:	f040 80ad 	bne.w	7a78 <__ssvfiscanf_r+0x2f8>
    791e:	3301      	adds	r3, #1
    7920:	686a      	ldr	r2, [r5, #4]
    7922:	602b      	str	r3, [r5, #0]
    7924:	6923      	ldr	r3, [r4, #16]
    7926:	3a01      	subs	r2, #1
    7928:	3301      	adds	r3, #1
    792a:	606a      	str	r2, [r5, #4]
    792c:	6123      	str	r3, [r4, #16]
    792e:	e752      	b.n	77d6 <__ssvfiscanf_r+0x56>
    7930:	4629      	mov	r1, r5
    7932:	4638      	mov	r0, r7
    7934:	f8d4 3180 	ldr.w	r3, [r4, #384]	@ 0x180
    7938:	4798      	blx	r3
    793a:	2800      	cmp	r0, #0
    793c:	d0ea      	beq.n	7914 <__ssvfiscanf_r+0x194>
    793e:	68e0      	ldr	r0, [r4, #12]
    7940:	2800      	cmp	r0, #0
    7942:	f040 8091 	bne.w	7a68 <__ssvfiscanf_r+0x2e8>
    7946:	f04f 30ff 	mov.w	r0, #4294967295
    794a:	e091      	b.n	7a70 <__ssvfiscanf_r+0x2f0>
    794c:	6822      	ldr	r2, [r4, #0]
    794e:	f042 0220 	orr.w	r2, r2, #32
    7952:	6022      	str	r2, [r4, #0]
    7954:	6822      	ldr	r2, [r4, #0]
    7956:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
    795a:	6022      	str	r2, [r4, #0]
    795c:	2210      	movs	r2, #16
    795e:	2b6e      	cmp	r3, #110	@ 0x6e
    7960:	6062      	str	r2, [r4, #4]
    7962:	d806      	bhi.n	7972 <__ssvfiscanf_r+0x1f2>
    7964:	e001      	b.n	796a <__ssvfiscanf_r+0x1ea>
    7966:	2300      	movs	r3, #0
    7968:	6063      	str	r3, [r4, #4]
    796a:	2303      	movs	r3, #3
    796c:	e002      	b.n	7974 <__ssvfiscanf_r+0x1f4>
    796e:	2308      	movs	r3, #8
    7970:	6063      	str	r3, [r4, #4]
    7972:	2304      	movs	r3, #4
    7974:	61a3      	str	r3, [r4, #24]
    7976:	686b      	ldr	r3, [r5, #4]
    7978:	2b00      	cmp	r3, #0
    797a:	dd3c      	ble.n	79f6 <__ssvfiscanf_r+0x276>
    797c:	6823      	ldr	r3, [r4, #0]
    797e:	0659      	lsls	r1, r3, #25
    7980:	d405      	bmi.n	798e <__ssvfiscanf_r+0x20e>
    7982:	682b      	ldr	r3, [r5, #0]
    7984:	781a      	ldrb	r2, [r3, #0]
    7986:	f81b 2002 	ldrb.w	r2, [fp, r2]
    798a:	0712      	lsls	r2, r2, #28
    798c:	d43b      	bmi.n	7a06 <__ssvfiscanf_r+0x286>
    798e:	69a3      	ldr	r3, [r4, #24]
    7990:	2b02      	cmp	r3, #2
    7992:	dc4b      	bgt.n	7a2c <__ssvfiscanf_r+0x2ac>
    7994:	4643      	mov	r3, r8
    7996:	462a      	mov	r2, r5
    7998:	4621      	mov	r1, r4
    799a:	4638      	mov	r0, r7
    799c:	f000 fb40 	bl	8020 <_scanf_chars>
    79a0:	2801      	cmp	r0, #1
    79a2:	d069      	beq.n	7a78 <__ssvfiscanf_r+0x2f8>
    79a4:	2802      	cmp	r0, #2
    79a6:	f47f af16 	bne.w	77d6 <__ssvfiscanf_r+0x56>
    79aa:	e7c8      	b.n	793e <__ssvfiscanf_r+0x1be>
    79ac:	220a      	movs	r2, #10
    79ae:	e7d6      	b.n	795e <__ssvfiscanf_r+0x1de>
    79b0:	4631      	mov	r1, r6
    79b2:	a801      	add	r0, sp, #4
    79b4:	f000 fced 	bl	8392 <__sccl>
    79b8:	6823      	ldr	r3, [r4, #0]
    79ba:	4606      	mov	r6, r0
    79bc:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
    79c0:	6023      	str	r3, [r4, #0]
    79c2:	2301      	movs	r3, #1
    79c4:	e7d6      	b.n	7974 <__ssvfiscanf_r+0x1f4>
    79c6:	6823      	ldr	r3, [r4, #0]
    79c8:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
    79cc:	6023      	str	r3, [r4, #0]
    79ce:	2300      	movs	r3, #0
    79d0:	e7d0      	b.n	7974 <__ssvfiscanf_r+0x1f4>
    79d2:	2302      	movs	r3, #2
    79d4:	e7ce      	b.n	7974 <__ssvfiscanf_r+0x1f4>
    79d6:	6820      	ldr	r0, [r4, #0]
    79d8:	06c3      	lsls	r3, r0, #27
    79da:	f53f aefc 	bmi.w	77d6 <__ssvfiscanf_r+0x56>
    79de:	f8d8 3000 	ldr.w	r3, [r8]
    79e2:	6922      	ldr	r2, [r4, #16]
    79e4:	1d19      	adds	r1, r3, #4
    79e6:	f8c8 1000 	str.w	r1, [r8]
    79ea:	681b      	ldr	r3, [r3, #0]
    79ec:	07c0      	lsls	r0, r0, #31
    79ee:	bf4c      	ite	mi
    79f0:	801a      	strhmi	r2, [r3, #0]
    79f2:	601a      	strpl	r2, [r3, #0]
    79f4:	e6ef      	b.n	77d6 <__ssvfiscanf_r+0x56>
    79f6:	4629      	mov	r1, r5
    79f8:	4638      	mov	r0, r7
    79fa:	f8d4 3180 	ldr.w	r3, [r4, #384]	@ 0x180
    79fe:	4798      	blx	r3
    7a00:	2800      	cmp	r0, #0
    7a02:	d0bb      	beq.n	797c <__ssvfiscanf_r+0x1fc>
    7a04:	e79b      	b.n	793e <__ssvfiscanf_r+0x1be>
    7a06:	6922      	ldr	r2, [r4, #16]
    7a08:	3201      	adds	r2, #1
    7a0a:	6122      	str	r2, [r4, #16]
    7a0c:	686a      	ldr	r2, [r5, #4]
    7a0e:	3a01      	subs	r2, #1
    7a10:	2a00      	cmp	r2, #0
    7a12:	606a      	str	r2, [r5, #4]
    7a14:	dd02      	ble.n	7a1c <__ssvfiscanf_r+0x29c>
    7a16:	3301      	adds	r3, #1
    7a18:	602b      	str	r3, [r5, #0]
    7a1a:	e7b2      	b.n	7982 <__ssvfiscanf_r+0x202>
    7a1c:	4629      	mov	r1, r5
    7a1e:	4638      	mov	r0, r7
    7a20:	f8d4 3180 	ldr.w	r3, [r4, #384]	@ 0x180
    7a24:	4798      	blx	r3
    7a26:	2800      	cmp	r0, #0
    7a28:	d0ab      	beq.n	7982 <__ssvfiscanf_r+0x202>
    7a2a:	e788      	b.n	793e <__ssvfiscanf_r+0x1be>
    7a2c:	2b04      	cmp	r3, #4
    7a2e:	dc06      	bgt.n	7a3e <__ssvfiscanf_r+0x2be>
    7a30:	4643      	mov	r3, r8
    7a32:	462a      	mov	r2, r5
    7a34:	4621      	mov	r1, r4
    7a36:	4638      	mov	r0, r7
    7a38:	f000 fb4c 	bl	80d4 <_scanf_i>
    7a3c:	e7b0      	b.n	79a0 <__ssvfiscanf_r+0x220>
    7a3e:	4b09      	ldr	r3, [pc, #36]	@ (7a64 <__ssvfiscanf_r+0x2e4>)
    7a40:	2b00      	cmp	r3, #0
    7a42:	f43f aec8 	beq.w	77d6 <__ssvfiscanf_r+0x56>
    7a46:	4643      	mov	r3, r8
    7a48:	462a      	mov	r2, r5
    7a4a:	4621      	mov	r1, r4
    7a4c:	4638      	mov	r0, r7
    7a4e:	f3af 8000 	nop.w
    7a52:	e7a5      	b.n	79a0 <__ssvfiscanf_r+0x220>
    7a54:	000076cd 	.word	0x000076cd
    7a58:	0000b879 	.word	0x0000b879
    7a5c:	00007747 	.word	0x00007747
    7a60:	0000ba50 	.word	0x0000ba50
    7a64:	00000000 	.word	0x00000000
    7a68:	89ab      	ldrh	r3, [r5, #12]
    7a6a:	065b      	lsls	r3, r3, #25
    7a6c:	f53f af6b 	bmi.w	7946 <__ssvfiscanf_r+0x1c6>
    7a70:	f50d 7d23 	add.w	sp, sp, #652	@ 0x28c
    7a74:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7a78:	68e0      	ldr	r0, [r4, #12]
    7a7a:	e7f9      	b.n	7a70 <__ssvfiscanf_r+0x2f0>

00007a7c <__sfputc_r>:
    7a7c:	6893      	ldr	r3, [r2, #8]
    7a7e:	b410      	push	{r4}
    7a80:	3b01      	subs	r3, #1
    7a82:	2b00      	cmp	r3, #0
    7a84:	6093      	str	r3, [r2, #8]
    7a86:	da07      	bge.n	7a98 <__sfputc_r+0x1c>
    7a88:	6994      	ldr	r4, [r2, #24]
    7a8a:	42a3      	cmp	r3, r4
    7a8c:	db01      	blt.n	7a92 <__sfputc_r+0x16>
    7a8e:	290a      	cmp	r1, #10
    7a90:	d102      	bne.n	7a98 <__sfputc_r+0x1c>
    7a92:	bc10      	pop	{r4}
    7a94:	f7ff bb68 	b.w	7168 <__swbuf_r>
    7a98:	6813      	ldr	r3, [r2, #0]
    7a9a:	1c58      	adds	r0, r3, #1
    7a9c:	6010      	str	r0, [r2, #0]
    7a9e:	7019      	strb	r1, [r3, #0]
    7aa0:	4608      	mov	r0, r1
    7aa2:	bc10      	pop	{r4}
    7aa4:	4770      	bx	lr

00007aa6 <__sfputs_r>:
    7aa6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    7aa8:	4606      	mov	r6, r0
    7aaa:	460f      	mov	r7, r1
    7aac:	4614      	mov	r4, r2
    7aae:	18d5      	adds	r5, r2, r3
    7ab0:	42ac      	cmp	r4, r5
    7ab2:	d101      	bne.n	7ab8 <__sfputs_r+0x12>
    7ab4:	2000      	movs	r0, #0
    7ab6:	e007      	b.n	7ac8 <__sfputs_r+0x22>
    7ab8:	463a      	mov	r2, r7
    7aba:	4630      	mov	r0, r6
    7abc:	f814 1b01 	ldrb.w	r1, [r4], #1
    7ac0:	f7ff ffdc 	bl	7a7c <__sfputc_r>
    7ac4:	1c43      	adds	r3, r0, #1
    7ac6:	d1f3      	bne.n	7ab0 <__sfputs_r+0xa>
    7ac8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

00007acc <_vfiprintf_r>:
    7acc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7ad0:	460d      	mov	r5, r1
    7ad2:	4614      	mov	r4, r2
    7ad4:	4698      	mov	r8, r3
    7ad6:	4606      	mov	r6, r0
    7ad8:	b09d      	sub	sp, #116	@ 0x74
    7ada:	b118      	cbz	r0, 7ae4 <_vfiprintf_r+0x18>
    7adc:	6a03      	ldr	r3, [r0, #32]
    7ade:	b90b      	cbnz	r3, 7ae4 <_vfiprintf_r+0x18>
    7ae0:	f7ff f9ee 	bl	6ec0 <__sinit>
    7ae4:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
    7ae6:	07d9      	lsls	r1, r3, #31
    7ae8:	d405      	bmi.n	7af6 <_vfiprintf_r+0x2a>
    7aea:	89ab      	ldrh	r3, [r5, #12]
    7aec:	059a      	lsls	r2, r3, #22
    7aee:	d402      	bmi.n	7af6 <_vfiprintf_r+0x2a>
    7af0:	6da8      	ldr	r0, [r5, #88]	@ 0x58
    7af2:	f7ff fcae 	bl	7452 <__retarget_lock_acquire_recursive>
    7af6:	89ab      	ldrh	r3, [r5, #12]
    7af8:	071b      	lsls	r3, r3, #28
    7afa:	d501      	bpl.n	7b00 <_vfiprintf_r+0x34>
    7afc:	692b      	ldr	r3, [r5, #16]
    7afe:	b99b      	cbnz	r3, 7b28 <_vfiprintf_r+0x5c>
    7b00:	4629      	mov	r1, r5
    7b02:	4630      	mov	r0, r6
    7b04:	f7ff fb6e 	bl	71e4 <__swsetup_r>
    7b08:	b170      	cbz	r0, 7b28 <_vfiprintf_r+0x5c>
    7b0a:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
    7b0c:	07dc      	lsls	r4, r3, #31
    7b0e:	d504      	bpl.n	7b1a <_vfiprintf_r+0x4e>
    7b10:	f04f 30ff 	mov.w	r0, #4294967295
    7b14:	b01d      	add	sp, #116	@ 0x74
    7b16:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7b1a:	89ab      	ldrh	r3, [r5, #12]
    7b1c:	0598      	lsls	r0, r3, #22
    7b1e:	d4f7      	bmi.n	7b10 <_vfiprintf_r+0x44>
    7b20:	6da8      	ldr	r0, [r5, #88]	@ 0x58
    7b22:	f7ff fc97 	bl	7454 <__retarget_lock_release_recursive>
    7b26:	e7f3      	b.n	7b10 <_vfiprintf_r+0x44>
    7b28:	2300      	movs	r3, #0
    7b2a:	9309      	str	r3, [sp, #36]	@ 0x24
    7b2c:	2320      	movs	r3, #32
    7b2e:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
    7b32:	2330      	movs	r3, #48	@ 0x30
    7b34:	f04f 0901 	mov.w	r9, #1
    7b38:	f8cd 800c 	str.w	r8, [sp, #12]
    7b3c:	f8df 81a8 	ldr.w	r8, [pc, #424]	@ 7ce8 <_vfiprintf_r+0x21c>
    7b40:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
    7b44:	4623      	mov	r3, r4
    7b46:	469a      	mov	sl, r3
    7b48:	f813 2b01 	ldrb.w	r2, [r3], #1
    7b4c:	b10a      	cbz	r2, 7b52 <_vfiprintf_r+0x86>
    7b4e:	2a25      	cmp	r2, #37	@ 0x25
    7b50:	d1f9      	bne.n	7b46 <_vfiprintf_r+0x7a>
    7b52:	ebba 0b04 	subs.w	fp, sl, r4
    7b56:	d00b      	beq.n	7b70 <_vfiprintf_r+0xa4>
    7b58:	465b      	mov	r3, fp
    7b5a:	4622      	mov	r2, r4
    7b5c:	4629      	mov	r1, r5
    7b5e:	4630      	mov	r0, r6
    7b60:	f7ff ffa1 	bl	7aa6 <__sfputs_r>
    7b64:	3001      	adds	r0, #1
    7b66:	f000 80a7 	beq.w	7cb8 <_vfiprintf_r+0x1ec>
    7b6a:	9a09      	ldr	r2, [sp, #36]	@ 0x24
    7b6c:	445a      	add	r2, fp
    7b6e:	9209      	str	r2, [sp, #36]	@ 0x24
    7b70:	f89a 3000 	ldrb.w	r3, [sl]
    7b74:	2b00      	cmp	r3, #0
    7b76:	f000 809f 	beq.w	7cb8 <_vfiprintf_r+0x1ec>
    7b7a:	2300      	movs	r3, #0
    7b7c:	f04f 32ff 	mov.w	r2, #4294967295
    7b80:	e9cd 2305 	strd	r2, r3, [sp, #20]
    7b84:	f10a 0a01 	add.w	sl, sl, #1
    7b88:	9304      	str	r3, [sp, #16]
    7b8a:	9307      	str	r3, [sp, #28]
    7b8c:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
    7b90:	931a      	str	r3, [sp, #104]	@ 0x68
    7b92:	4654      	mov	r4, sl
    7b94:	2205      	movs	r2, #5
    7b96:	f814 1b01 	ldrb.w	r1, [r4], #1
    7b9a:	4853      	ldr	r0, [pc, #332]	@ (7ce8 <_vfiprintf_r+0x21c>)
    7b9c:	f000 fc9c 	bl	84d8 <memchr>
    7ba0:	9a04      	ldr	r2, [sp, #16]
    7ba2:	b9d8      	cbnz	r0, 7bdc <_vfiprintf_r+0x110>
    7ba4:	06d1      	lsls	r1, r2, #27
    7ba6:	bf44      	itt	mi
    7ba8:	2320      	movmi	r3, #32
    7baa:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
    7bae:	0713      	lsls	r3, r2, #28
    7bb0:	bf44      	itt	mi
    7bb2:	232b      	movmi	r3, #43	@ 0x2b
    7bb4:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
    7bb8:	f89a 3000 	ldrb.w	r3, [sl]
    7bbc:	2b2a      	cmp	r3, #42	@ 0x2a
    7bbe:	d015      	beq.n	7bec <_vfiprintf_r+0x120>
    7bc0:	4654      	mov	r4, sl
    7bc2:	2000      	movs	r0, #0
    7bc4:	f04f 0c0a 	mov.w	ip, #10
    7bc8:	9a07      	ldr	r2, [sp, #28]
    7bca:	4621      	mov	r1, r4
    7bcc:	f811 3b01 	ldrb.w	r3, [r1], #1
    7bd0:	3b30      	subs	r3, #48	@ 0x30
    7bd2:	2b09      	cmp	r3, #9
    7bd4:	d94b      	bls.n	7c6e <_vfiprintf_r+0x1a2>
    7bd6:	b1b0      	cbz	r0, 7c06 <_vfiprintf_r+0x13a>
    7bd8:	9207      	str	r2, [sp, #28]
    7bda:	e014      	b.n	7c06 <_vfiprintf_r+0x13a>
    7bdc:	eba0 0308 	sub.w	r3, r0, r8
    7be0:	fa09 f303 	lsl.w	r3, r9, r3
    7be4:	4313      	orrs	r3, r2
    7be6:	46a2      	mov	sl, r4
    7be8:	9304      	str	r3, [sp, #16]
    7bea:	e7d2      	b.n	7b92 <_vfiprintf_r+0xc6>
    7bec:	9b03      	ldr	r3, [sp, #12]
    7bee:	1d19      	adds	r1, r3, #4
    7bf0:	681b      	ldr	r3, [r3, #0]
    7bf2:	9103      	str	r1, [sp, #12]
    7bf4:	2b00      	cmp	r3, #0
    7bf6:	bfbb      	ittet	lt
    7bf8:	425b      	neglt	r3, r3
    7bfa:	f042 0202 	orrlt.w	r2, r2, #2
    7bfe:	9307      	strge	r3, [sp, #28]
    7c00:	9307      	strlt	r3, [sp, #28]
    7c02:	bfb8      	it	lt
    7c04:	9204      	strlt	r2, [sp, #16]
    7c06:	7823      	ldrb	r3, [r4, #0]
    7c08:	2b2e      	cmp	r3, #46	@ 0x2e
    7c0a:	d10a      	bne.n	7c22 <_vfiprintf_r+0x156>
    7c0c:	7863      	ldrb	r3, [r4, #1]
    7c0e:	2b2a      	cmp	r3, #42	@ 0x2a
    7c10:	d132      	bne.n	7c78 <_vfiprintf_r+0x1ac>
    7c12:	9b03      	ldr	r3, [sp, #12]
    7c14:	3402      	adds	r4, #2
    7c16:	1d1a      	adds	r2, r3, #4
    7c18:	681b      	ldr	r3, [r3, #0]
    7c1a:	9203      	str	r2, [sp, #12]
    7c1c:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
    7c20:	9305      	str	r3, [sp, #20]
    7c22:	f8df a0c8 	ldr.w	sl, [pc, #200]	@ 7cec <_vfiprintf_r+0x220>
    7c26:	2203      	movs	r2, #3
    7c28:	4650      	mov	r0, sl
    7c2a:	7821      	ldrb	r1, [r4, #0]
    7c2c:	f000 fc54 	bl	84d8 <memchr>
    7c30:	b138      	cbz	r0, 7c42 <_vfiprintf_r+0x176>
    7c32:	2240      	movs	r2, #64	@ 0x40
    7c34:	9b04      	ldr	r3, [sp, #16]
    7c36:	eba0 000a 	sub.w	r0, r0, sl
    7c3a:	4082      	lsls	r2, r0
    7c3c:	4313      	orrs	r3, r2
    7c3e:	3401      	adds	r4, #1
    7c40:	9304      	str	r3, [sp, #16]
    7c42:	f814 1b01 	ldrb.w	r1, [r4], #1
    7c46:	2206      	movs	r2, #6
    7c48:	4829      	ldr	r0, [pc, #164]	@ (7cf0 <_vfiprintf_r+0x224>)
    7c4a:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
    7c4e:	f000 fc43 	bl	84d8 <memchr>
    7c52:	2800      	cmp	r0, #0
    7c54:	d03f      	beq.n	7cd6 <_vfiprintf_r+0x20a>
    7c56:	4b27      	ldr	r3, [pc, #156]	@ (7cf4 <_vfiprintf_r+0x228>)
    7c58:	bb1b      	cbnz	r3, 7ca2 <_vfiprintf_r+0x1d6>
    7c5a:	9b03      	ldr	r3, [sp, #12]
    7c5c:	3307      	adds	r3, #7
    7c5e:	f023 0307 	bic.w	r3, r3, #7
    7c62:	3308      	adds	r3, #8
    7c64:	9303      	str	r3, [sp, #12]
    7c66:	9b09      	ldr	r3, [sp, #36]	@ 0x24
    7c68:	443b      	add	r3, r7
    7c6a:	9309      	str	r3, [sp, #36]	@ 0x24
    7c6c:	e76a      	b.n	7b44 <_vfiprintf_r+0x78>
    7c6e:	460c      	mov	r4, r1
    7c70:	2001      	movs	r0, #1
    7c72:	fb0c 3202 	mla	r2, ip, r2, r3
    7c76:	e7a8      	b.n	7bca <_vfiprintf_r+0xfe>
    7c78:	2300      	movs	r3, #0
    7c7a:	f04f 0c0a 	mov.w	ip, #10
    7c7e:	4619      	mov	r1, r3
    7c80:	3401      	adds	r4, #1
    7c82:	9305      	str	r3, [sp, #20]
    7c84:	4620      	mov	r0, r4
    7c86:	f810 2b01 	ldrb.w	r2, [r0], #1
    7c8a:	3a30      	subs	r2, #48	@ 0x30
    7c8c:	2a09      	cmp	r2, #9
    7c8e:	d903      	bls.n	7c98 <_vfiprintf_r+0x1cc>
    7c90:	2b00      	cmp	r3, #0
    7c92:	d0c6      	beq.n	7c22 <_vfiprintf_r+0x156>
    7c94:	9105      	str	r1, [sp, #20]
    7c96:	e7c4      	b.n	7c22 <_vfiprintf_r+0x156>
    7c98:	4604      	mov	r4, r0
    7c9a:	2301      	movs	r3, #1
    7c9c:	fb0c 2101 	mla	r1, ip, r1, r2
    7ca0:	e7f0      	b.n	7c84 <_vfiprintf_r+0x1b8>
    7ca2:	ab03      	add	r3, sp, #12
    7ca4:	9300      	str	r3, [sp, #0]
    7ca6:	462a      	mov	r2, r5
    7ca8:	4630      	mov	r0, r6
    7caa:	4b13      	ldr	r3, [pc, #76]	@ (7cf8 <_vfiprintf_r+0x22c>)
    7cac:	a904      	add	r1, sp, #16
    7cae:	f3af 8000 	nop.w
    7cb2:	4607      	mov	r7, r0
    7cb4:	1c78      	adds	r0, r7, #1
    7cb6:	d1d6      	bne.n	7c66 <_vfiprintf_r+0x19a>
    7cb8:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
    7cba:	07d9      	lsls	r1, r3, #31
    7cbc:	d405      	bmi.n	7cca <_vfiprintf_r+0x1fe>
    7cbe:	89ab      	ldrh	r3, [r5, #12]
    7cc0:	059a      	lsls	r2, r3, #22
    7cc2:	d402      	bmi.n	7cca <_vfiprintf_r+0x1fe>
    7cc4:	6da8      	ldr	r0, [r5, #88]	@ 0x58
    7cc6:	f7ff fbc5 	bl	7454 <__retarget_lock_release_recursive>
    7cca:	89ab      	ldrh	r3, [r5, #12]
    7ccc:	065b      	lsls	r3, r3, #25
    7cce:	f53f af1f 	bmi.w	7b10 <_vfiprintf_r+0x44>
    7cd2:	9809      	ldr	r0, [sp, #36]	@ 0x24
    7cd4:	e71e      	b.n	7b14 <_vfiprintf_r+0x48>
    7cd6:	ab03      	add	r3, sp, #12
    7cd8:	9300      	str	r3, [sp, #0]
    7cda:	462a      	mov	r2, r5
    7cdc:	4630      	mov	r0, r6
    7cde:	4b06      	ldr	r3, [pc, #24]	@ (7cf8 <_vfiprintf_r+0x22c>)
    7ce0:	a904      	add	r1, sp, #16
    7ce2:	f000 f87d 	bl	7de0 <_printf_i>
    7ce6:	e7e4      	b.n	7cb2 <_vfiprintf_r+0x1e6>
    7ce8:	0000ba54 	.word	0x0000ba54
    7cec:	0000ba50 	.word	0x0000ba50
    7cf0:	0000ba5a 	.word	0x0000ba5a
    7cf4:	00000000 	.word	0x00000000
    7cf8:	00007aa7 	.word	0x00007aa7

00007cfc <_printf_common>:
    7cfc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    7d00:	4616      	mov	r6, r2
    7d02:	4698      	mov	r8, r3
    7d04:	688a      	ldr	r2, [r1, #8]
    7d06:	690b      	ldr	r3, [r1, #16]
    7d08:	4607      	mov	r7, r0
    7d0a:	4293      	cmp	r3, r2
    7d0c:	bfb8      	it	lt
    7d0e:	4613      	movlt	r3, r2
    7d10:	6033      	str	r3, [r6, #0]
    7d12:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
    7d16:	460c      	mov	r4, r1
    7d18:	f8dd 9020 	ldr.w	r9, [sp, #32]
    7d1c:	b10a      	cbz	r2, 7d22 <_printf_common+0x26>
    7d1e:	3301      	adds	r3, #1
    7d20:	6033      	str	r3, [r6, #0]
    7d22:	6823      	ldr	r3, [r4, #0]
    7d24:	0699      	lsls	r1, r3, #26
    7d26:	bf42      	ittt	mi
    7d28:	6833      	ldrmi	r3, [r6, #0]
    7d2a:	3302      	addmi	r3, #2
    7d2c:	6033      	strmi	r3, [r6, #0]
    7d2e:	6825      	ldr	r5, [r4, #0]
    7d30:	f015 0506 	ands.w	r5, r5, #6
    7d34:	d106      	bne.n	7d44 <_printf_common+0x48>
    7d36:	f104 0a19 	add.w	sl, r4, #25
    7d3a:	68e3      	ldr	r3, [r4, #12]
    7d3c:	6832      	ldr	r2, [r6, #0]
    7d3e:	1a9b      	subs	r3, r3, r2
    7d40:	42ab      	cmp	r3, r5
    7d42:	dc2b      	bgt.n	7d9c <_printf_common+0xa0>
    7d44:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
    7d48:	6822      	ldr	r2, [r4, #0]
    7d4a:	3b00      	subs	r3, #0
    7d4c:	bf18      	it	ne
    7d4e:	2301      	movne	r3, #1
    7d50:	0692      	lsls	r2, r2, #26
    7d52:	d430      	bmi.n	7db6 <_printf_common+0xba>
    7d54:	4641      	mov	r1, r8
    7d56:	4638      	mov	r0, r7
    7d58:	f104 0243 	add.w	r2, r4, #67	@ 0x43
    7d5c:	47c8      	blx	r9
    7d5e:	3001      	adds	r0, #1
    7d60:	d023      	beq.n	7daa <_printf_common+0xae>
    7d62:	6823      	ldr	r3, [r4, #0]
    7d64:	6922      	ldr	r2, [r4, #16]
    7d66:	f003 0306 	and.w	r3, r3, #6
    7d6a:	2b04      	cmp	r3, #4
    7d6c:	bf14      	ite	ne
    7d6e:	2500      	movne	r5, #0
    7d70:	6833      	ldreq	r3, [r6, #0]
    7d72:	f04f 0600 	mov.w	r6, #0
    7d76:	bf08      	it	eq
    7d78:	68e5      	ldreq	r5, [r4, #12]
    7d7a:	f104 041a 	add.w	r4, r4, #26
    7d7e:	bf08      	it	eq
    7d80:	1aed      	subeq	r5, r5, r3
    7d82:	f854 3c12 	ldr.w	r3, [r4, #-18]
    7d86:	bf08      	it	eq
    7d88:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
    7d8c:	4293      	cmp	r3, r2
    7d8e:	bfc4      	itt	gt
    7d90:	1a9b      	subgt	r3, r3, r2
    7d92:	18ed      	addgt	r5, r5, r3
    7d94:	42b5      	cmp	r5, r6
    7d96:	d11a      	bne.n	7dce <_printf_common+0xd2>
    7d98:	2000      	movs	r0, #0
    7d9a:	e008      	b.n	7dae <_printf_common+0xb2>
    7d9c:	2301      	movs	r3, #1
    7d9e:	4652      	mov	r2, sl
    7da0:	4641      	mov	r1, r8
    7da2:	4638      	mov	r0, r7
    7da4:	47c8      	blx	r9
    7da6:	3001      	adds	r0, #1
    7da8:	d103      	bne.n	7db2 <_printf_common+0xb6>
    7daa:	f04f 30ff 	mov.w	r0, #4294967295
    7dae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    7db2:	3501      	adds	r5, #1
    7db4:	e7c1      	b.n	7d3a <_printf_common+0x3e>
    7db6:	2030      	movs	r0, #48	@ 0x30
    7db8:	18e1      	adds	r1, r4, r3
    7dba:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
    7dbe:	1c5a      	adds	r2, r3, #1
    7dc0:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
    7dc4:	4422      	add	r2, r4
    7dc6:	3302      	adds	r3, #2
    7dc8:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
    7dcc:	e7c2      	b.n	7d54 <_printf_common+0x58>
    7dce:	2301      	movs	r3, #1
    7dd0:	4622      	mov	r2, r4
    7dd2:	4641      	mov	r1, r8
    7dd4:	4638      	mov	r0, r7
    7dd6:	47c8      	blx	r9
    7dd8:	3001      	adds	r0, #1
    7dda:	d0e6      	beq.n	7daa <_printf_common+0xae>
    7ddc:	3601      	adds	r6, #1
    7dde:	e7d9      	b.n	7d94 <_printf_common+0x98>

00007de0 <_printf_i>:
    7de0:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    7de4:	7e0f      	ldrb	r7, [r1, #24]
    7de6:	4691      	mov	r9, r2
    7de8:	2f78      	cmp	r7, #120	@ 0x78
    7dea:	4680      	mov	r8, r0
    7dec:	460c      	mov	r4, r1
    7dee:	469a      	mov	sl, r3
    7df0:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
    7df2:	f101 0243 	add.w	r2, r1, #67	@ 0x43
    7df6:	d807      	bhi.n	7e08 <_printf_i+0x28>
    7df8:	2f62      	cmp	r7, #98	@ 0x62
    7dfa:	d80a      	bhi.n	7e12 <_printf_i+0x32>
    7dfc:	2f00      	cmp	r7, #0
    7dfe:	f000 80d2 	beq.w	7fa6 <_printf_i+0x1c6>
    7e02:	2f58      	cmp	r7, #88	@ 0x58
    7e04:	f000 80b7 	beq.w	7f76 <_printf_i+0x196>
    7e08:	f104 0642 	add.w	r6, r4, #66	@ 0x42
    7e0c:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
    7e10:	e03a      	b.n	7e88 <_printf_i+0xa8>
    7e12:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
    7e16:	2b15      	cmp	r3, #21
    7e18:	d8f6      	bhi.n	7e08 <_printf_i+0x28>
    7e1a:	a101      	add	r1, pc, #4	@ (adr r1, 7e20 <_printf_i+0x40>)
    7e1c:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
    7e20:	00007e79 	.word	0x00007e79
    7e24:	00007e8d 	.word	0x00007e8d
    7e28:	00007e09 	.word	0x00007e09
    7e2c:	00007e09 	.word	0x00007e09
    7e30:	00007e09 	.word	0x00007e09
    7e34:	00007e09 	.word	0x00007e09
    7e38:	00007e8d 	.word	0x00007e8d
    7e3c:	00007e09 	.word	0x00007e09
    7e40:	00007e09 	.word	0x00007e09
    7e44:	00007e09 	.word	0x00007e09
    7e48:	00007e09 	.word	0x00007e09
    7e4c:	00007f8d 	.word	0x00007f8d
    7e50:	00007eb7 	.word	0x00007eb7
    7e54:	00007f43 	.word	0x00007f43
    7e58:	00007e09 	.word	0x00007e09
    7e5c:	00007e09 	.word	0x00007e09
    7e60:	00007faf 	.word	0x00007faf
    7e64:	00007e09 	.word	0x00007e09
    7e68:	00007eb7 	.word	0x00007eb7
    7e6c:	00007e09 	.word	0x00007e09
    7e70:	00007e09 	.word	0x00007e09
    7e74:	00007f4b 	.word	0x00007f4b
    7e78:	6833      	ldr	r3, [r6, #0]
    7e7a:	1d1a      	adds	r2, r3, #4
    7e7c:	681b      	ldr	r3, [r3, #0]
    7e7e:	6032      	str	r2, [r6, #0]
    7e80:	f104 0642 	add.w	r6, r4, #66	@ 0x42
    7e84:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
    7e88:	2301      	movs	r3, #1
    7e8a:	e09d      	b.n	7fc8 <_printf_i+0x1e8>
    7e8c:	6833      	ldr	r3, [r6, #0]
    7e8e:	6820      	ldr	r0, [r4, #0]
    7e90:	1d19      	adds	r1, r3, #4
    7e92:	6031      	str	r1, [r6, #0]
    7e94:	0606      	lsls	r6, r0, #24
    7e96:	d501      	bpl.n	7e9c <_printf_i+0xbc>
    7e98:	681d      	ldr	r5, [r3, #0]
    7e9a:	e003      	b.n	7ea4 <_printf_i+0xc4>
    7e9c:	0645      	lsls	r5, r0, #25
    7e9e:	d5fb      	bpl.n	7e98 <_printf_i+0xb8>
    7ea0:	f9b3 5000 	ldrsh.w	r5, [r3]
    7ea4:	2d00      	cmp	r5, #0
    7ea6:	da03      	bge.n	7eb0 <_printf_i+0xd0>
    7ea8:	232d      	movs	r3, #45	@ 0x2d
    7eaa:	426d      	negs	r5, r5
    7eac:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
    7eb0:	230a      	movs	r3, #10
    7eb2:	4859      	ldr	r0, [pc, #356]	@ (8018 <_printf_i+0x238>)
    7eb4:	e010      	b.n	7ed8 <_printf_i+0xf8>
    7eb6:	6821      	ldr	r1, [r4, #0]
    7eb8:	6833      	ldr	r3, [r6, #0]
    7eba:	0608      	lsls	r0, r1, #24
    7ebc:	f853 5b04 	ldr.w	r5, [r3], #4
    7ec0:	d402      	bmi.n	7ec8 <_printf_i+0xe8>
    7ec2:	0649      	lsls	r1, r1, #25
    7ec4:	bf48      	it	mi
    7ec6:	b2ad      	uxthmi	r5, r5
    7ec8:	2f6f      	cmp	r7, #111	@ 0x6f
    7eca:	4853      	ldr	r0, [pc, #332]	@ (8018 <_printf_i+0x238>)
    7ecc:	6033      	str	r3, [r6, #0]
    7ece:	d159      	bne.n	7f84 <_printf_i+0x1a4>
    7ed0:	2308      	movs	r3, #8
    7ed2:	2100      	movs	r1, #0
    7ed4:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
    7ed8:	6866      	ldr	r6, [r4, #4]
    7eda:	2e00      	cmp	r6, #0
    7edc:	60a6      	str	r6, [r4, #8]
    7ede:	db05      	blt.n	7eec <_printf_i+0x10c>
    7ee0:	6821      	ldr	r1, [r4, #0]
    7ee2:	432e      	orrs	r6, r5
    7ee4:	f021 0104 	bic.w	r1, r1, #4
    7ee8:	6021      	str	r1, [r4, #0]
    7eea:	d04d      	beq.n	7f88 <_printf_i+0x1a8>
    7eec:	4616      	mov	r6, r2
    7eee:	fbb5 f1f3 	udiv	r1, r5, r3
    7ef2:	fb03 5711 	mls	r7, r3, r1, r5
    7ef6:	5dc7      	ldrb	r7, [r0, r7]
    7ef8:	f806 7d01 	strb.w	r7, [r6, #-1]!
    7efc:	462f      	mov	r7, r5
    7efe:	42bb      	cmp	r3, r7
    7f00:	460d      	mov	r5, r1
    7f02:	d9f4      	bls.n	7eee <_printf_i+0x10e>
    7f04:	2b08      	cmp	r3, #8
    7f06:	d10b      	bne.n	7f20 <_printf_i+0x140>
    7f08:	6823      	ldr	r3, [r4, #0]
    7f0a:	07df      	lsls	r7, r3, #31
    7f0c:	d508      	bpl.n	7f20 <_printf_i+0x140>
    7f0e:	6923      	ldr	r3, [r4, #16]
    7f10:	6861      	ldr	r1, [r4, #4]
    7f12:	4299      	cmp	r1, r3
    7f14:	bfde      	ittt	le
    7f16:	2330      	movle	r3, #48	@ 0x30
    7f18:	f806 3c01 	strble.w	r3, [r6, #-1]
    7f1c:	f106 36ff 	addle.w	r6, r6, #4294967295
    7f20:	1b92      	subs	r2, r2, r6
    7f22:	6122      	str	r2, [r4, #16]
    7f24:	464b      	mov	r3, r9
    7f26:	4621      	mov	r1, r4
    7f28:	4640      	mov	r0, r8
    7f2a:	f8cd a000 	str.w	sl, [sp]
    7f2e:	aa03      	add	r2, sp, #12
    7f30:	f7ff fee4 	bl	7cfc <_printf_common>
    7f34:	3001      	adds	r0, #1
    7f36:	d14c      	bne.n	7fd2 <_printf_i+0x1f2>
    7f38:	f04f 30ff 	mov.w	r0, #4294967295
    7f3c:	b004      	add	sp, #16
    7f3e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    7f42:	6823      	ldr	r3, [r4, #0]
    7f44:	f043 0320 	orr.w	r3, r3, #32
    7f48:	6023      	str	r3, [r4, #0]
    7f4a:	2778      	movs	r7, #120	@ 0x78
    7f4c:	4833      	ldr	r0, [pc, #204]	@ (801c <_printf_i+0x23c>)
    7f4e:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
    7f52:	6823      	ldr	r3, [r4, #0]
    7f54:	6831      	ldr	r1, [r6, #0]
    7f56:	061f      	lsls	r7, r3, #24
    7f58:	f851 5b04 	ldr.w	r5, [r1], #4
    7f5c:	d402      	bmi.n	7f64 <_printf_i+0x184>
    7f5e:	065f      	lsls	r7, r3, #25
    7f60:	bf48      	it	mi
    7f62:	b2ad      	uxthmi	r5, r5
    7f64:	6031      	str	r1, [r6, #0]
    7f66:	07d9      	lsls	r1, r3, #31
    7f68:	bf44      	itt	mi
    7f6a:	f043 0320 	orrmi.w	r3, r3, #32
    7f6e:	6023      	strmi	r3, [r4, #0]
    7f70:	b11d      	cbz	r5, 7f7a <_printf_i+0x19a>
    7f72:	2310      	movs	r3, #16
    7f74:	e7ad      	b.n	7ed2 <_printf_i+0xf2>
    7f76:	4828      	ldr	r0, [pc, #160]	@ (8018 <_printf_i+0x238>)
    7f78:	e7e9      	b.n	7f4e <_printf_i+0x16e>
    7f7a:	6823      	ldr	r3, [r4, #0]
    7f7c:	f023 0320 	bic.w	r3, r3, #32
    7f80:	6023      	str	r3, [r4, #0]
    7f82:	e7f6      	b.n	7f72 <_printf_i+0x192>
    7f84:	230a      	movs	r3, #10
    7f86:	e7a4      	b.n	7ed2 <_printf_i+0xf2>
    7f88:	4616      	mov	r6, r2
    7f8a:	e7bb      	b.n	7f04 <_printf_i+0x124>
    7f8c:	6833      	ldr	r3, [r6, #0]
    7f8e:	6825      	ldr	r5, [r4, #0]
    7f90:	1d18      	adds	r0, r3, #4
    7f92:	6961      	ldr	r1, [r4, #20]
    7f94:	6030      	str	r0, [r6, #0]
    7f96:	062e      	lsls	r6, r5, #24
    7f98:	681b      	ldr	r3, [r3, #0]
    7f9a:	d501      	bpl.n	7fa0 <_printf_i+0x1c0>
    7f9c:	6019      	str	r1, [r3, #0]
    7f9e:	e002      	b.n	7fa6 <_printf_i+0x1c6>
    7fa0:	0668      	lsls	r0, r5, #25
    7fa2:	d5fb      	bpl.n	7f9c <_printf_i+0x1bc>
    7fa4:	8019      	strh	r1, [r3, #0]
    7fa6:	2300      	movs	r3, #0
    7fa8:	4616      	mov	r6, r2
    7faa:	6123      	str	r3, [r4, #16]
    7fac:	e7ba      	b.n	7f24 <_printf_i+0x144>
    7fae:	6833      	ldr	r3, [r6, #0]
    7fb0:	2100      	movs	r1, #0
    7fb2:	1d1a      	adds	r2, r3, #4
    7fb4:	6032      	str	r2, [r6, #0]
    7fb6:	681e      	ldr	r6, [r3, #0]
    7fb8:	6862      	ldr	r2, [r4, #4]
    7fba:	4630      	mov	r0, r6
    7fbc:	f000 fa8c 	bl	84d8 <memchr>
    7fc0:	b108      	cbz	r0, 7fc6 <_printf_i+0x1e6>
    7fc2:	1b80      	subs	r0, r0, r6
    7fc4:	6060      	str	r0, [r4, #4]
    7fc6:	6863      	ldr	r3, [r4, #4]
    7fc8:	6123      	str	r3, [r4, #16]
    7fca:	2300      	movs	r3, #0
    7fcc:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
    7fd0:	e7a8      	b.n	7f24 <_printf_i+0x144>
    7fd2:	4632      	mov	r2, r6
    7fd4:	4649      	mov	r1, r9
    7fd6:	4640      	mov	r0, r8
    7fd8:	6923      	ldr	r3, [r4, #16]
    7fda:	47d0      	blx	sl
    7fdc:	3001      	adds	r0, #1
    7fde:	d0ab      	beq.n	7f38 <_printf_i+0x158>
    7fe0:	6823      	ldr	r3, [r4, #0]
    7fe2:	079b      	lsls	r3, r3, #30
    7fe4:	d413      	bmi.n	800e <_printf_i+0x22e>
    7fe6:	68e0      	ldr	r0, [r4, #12]
    7fe8:	9b03      	ldr	r3, [sp, #12]
    7fea:	4298      	cmp	r0, r3
    7fec:	bfb8      	it	lt
    7fee:	4618      	movlt	r0, r3
    7ff0:	e7a4      	b.n	7f3c <_printf_i+0x15c>
    7ff2:	2301      	movs	r3, #1
    7ff4:	4632      	mov	r2, r6
    7ff6:	4649      	mov	r1, r9
    7ff8:	4640      	mov	r0, r8
    7ffa:	47d0      	blx	sl
    7ffc:	3001      	adds	r0, #1
    7ffe:	d09b      	beq.n	7f38 <_printf_i+0x158>
    8000:	3501      	adds	r5, #1
    8002:	68e3      	ldr	r3, [r4, #12]
    8004:	9903      	ldr	r1, [sp, #12]
    8006:	1a5b      	subs	r3, r3, r1
    8008:	42ab      	cmp	r3, r5
    800a:	dcf2      	bgt.n	7ff2 <_printf_i+0x212>
    800c:	e7eb      	b.n	7fe6 <_printf_i+0x206>
    800e:	2500      	movs	r5, #0
    8010:	f104 0619 	add.w	r6, r4, #25
    8014:	e7f5      	b.n	8002 <_printf_i+0x222>
    8016:	bf00      	nop
    8018:	0000ba61 	.word	0x0000ba61
    801c:	0000ba72 	.word	0x0000ba72

00008020 <_scanf_chars>:
    8020:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    8024:	4615      	mov	r5, r2
    8026:	688a      	ldr	r2, [r1, #8]
    8028:	4680      	mov	r8, r0
    802a:	460c      	mov	r4, r1
    802c:	b932      	cbnz	r2, 803c <_scanf_chars+0x1c>
    802e:	698a      	ldr	r2, [r1, #24]
    8030:	2a00      	cmp	r2, #0
    8032:	bf14      	ite	ne
    8034:	f04f 32ff 	movne.w	r2, #4294967295
    8038:	2201      	moveq	r2, #1
    803a:	608a      	str	r2, [r1, #8]
    803c:	2700      	movs	r7, #0
    803e:	6822      	ldr	r2, [r4, #0]
    8040:	f8df 908c 	ldr.w	r9, [pc, #140]	@ 80d0 <_scanf_chars+0xb0>
    8044:	06d1      	lsls	r1, r2, #27
    8046:	bf5f      	itttt	pl
    8048:	681a      	ldrpl	r2, [r3, #0]
    804a:	1d11      	addpl	r1, r2, #4
    804c:	6019      	strpl	r1, [r3, #0]
    804e:	6816      	ldrpl	r6, [r2, #0]
    8050:	69a0      	ldr	r0, [r4, #24]
    8052:	b188      	cbz	r0, 8078 <_scanf_chars+0x58>
    8054:	2801      	cmp	r0, #1
    8056:	d107      	bne.n	8068 <_scanf_chars+0x48>
    8058:	682b      	ldr	r3, [r5, #0]
    805a:	781a      	ldrb	r2, [r3, #0]
    805c:	6963      	ldr	r3, [r4, #20]
    805e:	5c9b      	ldrb	r3, [r3, r2]
    8060:	b953      	cbnz	r3, 8078 <_scanf_chars+0x58>
    8062:	2f00      	cmp	r7, #0
    8064:	d031      	beq.n	80ca <_scanf_chars+0xaa>
    8066:	e022      	b.n	80ae <_scanf_chars+0x8e>
    8068:	2802      	cmp	r0, #2
    806a:	d120      	bne.n	80ae <_scanf_chars+0x8e>
    806c:	682b      	ldr	r3, [r5, #0]
    806e:	781b      	ldrb	r3, [r3, #0]
    8070:	f819 3003 	ldrb.w	r3, [r9, r3]
    8074:	071b      	lsls	r3, r3, #28
    8076:	d41a      	bmi.n	80ae <_scanf_chars+0x8e>
    8078:	6823      	ldr	r3, [r4, #0]
    807a:	3701      	adds	r7, #1
    807c:	06da      	lsls	r2, r3, #27
    807e:	bf5e      	ittt	pl
    8080:	682b      	ldrpl	r3, [r5, #0]
    8082:	781b      	ldrbpl	r3, [r3, #0]
    8084:	f806 3b01 	strbpl.w	r3, [r6], #1
    8088:	682a      	ldr	r2, [r5, #0]
    808a:	686b      	ldr	r3, [r5, #4]
    808c:	3201      	adds	r2, #1
    808e:	602a      	str	r2, [r5, #0]
    8090:	68a2      	ldr	r2, [r4, #8]
    8092:	3b01      	subs	r3, #1
    8094:	3a01      	subs	r2, #1
    8096:	606b      	str	r3, [r5, #4]
    8098:	60a2      	str	r2, [r4, #8]
    809a:	b142      	cbz	r2, 80ae <_scanf_chars+0x8e>
    809c:	2b00      	cmp	r3, #0
    809e:	dcd7      	bgt.n	8050 <_scanf_chars+0x30>
    80a0:	4629      	mov	r1, r5
    80a2:	4640      	mov	r0, r8
    80a4:	f8d4 3180 	ldr.w	r3, [r4, #384]	@ 0x180
    80a8:	4798      	blx	r3
    80aa:	2800      	cmp	r0, #0
    80ac:	d0d0      	beq.n	8050 <_scanf_chars+0x30>
    80ae:	6823      	ldr	r3, [r4, #0]
    80b0:	f013 0310 	ands.w	r3, r3, #16
    80b4:	d105      	bne.n	80c2 <_scanf_chars+0xa2>
    80b6:	68e2      	ldr	r2, [r4, #12]
    80b8:	3201      	adds	r2, #1
    80ba:	60e2      	str	r2, [r4, #12]
    80bc:	69a2      	ldr	r2, [r4, #24]
    80be:	b102      	cbz	r2, 80c2 <_scanf_chars+0xa2>
    80c0:	7033      	strb	r3, [r6, #0]
    80c2:	2000      	movs	r0, #0
    80c4:	6923      	ldr	r3, [r4, #16]
    80c6:	443b      	add	r3, r7
    80c8:	6123      	str	r3, [r4, #16]
    80ca:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    80ce:	bf00      	nop
    80d0:	0000b879 	.word	0x0000b879

000080d4 <_scanf_i>:
    80d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    80d8:	460c      	mov	r4, r1
    80da:	4698      	mov	r8, r3
    80dc:	4b71      	ldr	r3, [pc, #452]	@ (82a4 <_scanf_i+0x1d0>)
    80de:	b087      	sub	sp, #28
    80e0:	4682      	mov	sl, r0
    80e2:	4616      	mov	r6, r2
    80e4:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
    80e8:	ab03      	add	r3, sp, #12
    80ea:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    80ee:	4b6e      	ldr	r3, [pc, #440]	@ (82a8 <_scanf_i+0x1d4>)
    80f0:	69a1      	ldr	r1, [r4, #24]
    80f2:	4a6e      	ldr	r2, [pc, #440]	@ (82ac <_scanf_i+0x1d8>)
    80f4:	4627      	mov	r7, r4
    80f6:	2903      	cmp	r1, #3
    80f8:	bf08      	it	eq
    80fa:	461a      	moveq	r2, r3
    80fc:	68a3      	ldr	r3, [r4, #8]
    80fe:	9201      	str	r2, [sp, #4]
    8100:	1e5a      	subs	r2, r3, #1
    8102:	f5b2 7fae 	cmp.w	r2, #348	@ 0x15c
    8106:	bf81      	itttt	hi
    8108:	f46f 75ae 	mvnhi.w	r5, #348	@ 0x15c
    810c:	eb03 0905 	addhi.w	r9, r3, r5
    8110:	f240 135d 	movwhi	r3, #349	@ 0x15d
    8114:	60a3      	strhi	r3, [r4, #8]
    8116:	f857 3b1c 	ldr.w	r3, [r7], #28
    811a:	bf98      	it	ls
    811c:	f04f 0900 	movls.w	r9, #0
    8120:	463d      	mov	r5, r7
    8122:	f04f 0b00 	mov.w	fp, #0
    8126:	f443 6350 	orr.w	r3, r3, #3328	@ 0xd00
    812a:	6023      	str	r3, [r4, #0]
    812c:	6831      	ldr	r1, [r6, #0]
    812e:	ab03      	add	r3, sp, #12
    8130:	2202      	movs	r2, #2
    8132:	7809      	ldrb	r1, [r1, #0]
    8134:	f853 002b 	ldr.w	r0, [r3, fp, lsl #2]
    8138:	f000 f9ce 	bl	84d8 <memchr>
    813c:	b328      	cbz	r0, 818a <_scanf_i+0xb6>
    813e:	f1bb 0f01 	cmp.w	fp, #1
    8142:	d158      	bne.n	81f6 <_scanf_i+0x122>
    8144:	6862      	ldr	r2, [r4, #4]
    8146:	b92a      	cbnz	r2, 8154 <_scanf_i+0x80>
    8148:	2108      	movs	r1, #8
    814a:	6822      	ldr	r2, [r4, #0]
    814c:	6061      	str	r1, [r4, #4]
    814e:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
    8152:	6022      	str	r2, [r4, #0]
    8154:	6822      	ldr	r2, [r4, #0]
    8156:	f422 62a0 	bic.w	r2, r2, #1280	@ 0x500
    815a:	6022      	str	r2, [r4, #0]
    815c:	68a2      	ldr	r2, [r4, #8]
    815e:	1e51      	subs	r1, r2, #1
    8160:	60a1      	str	r1, [r4, #8]
    8162:	b192      	cbz	r2, 818a <_scanf_i+0xb6>
    8164:	6832      	ldr	r2, [r6, #0]
    8166:	1c51      	adds	r1, r2, #1
    8168:	6031      	str	r1, [r6, #0]
    816a:	7812      	ldrb	r2, [r2, #0]
    816c:	f805 2b01 	strb.w	r2, [r5], #1
    8170:	6872      	ldr	r2, [r6, #4]
    8172:	3a01      	subs	r2, #1
    8174:	2a00      	cmp	r2, #0
    8176:	6072      	str	r2, [r6, #4]
    8178:	dc07      	bgt.n	818a <_scanf_i+0xb6>
    817a:	4631      	mov	r1, r6
    817c:	4650      	mov	r0, sl
    817e:	f8d4 2180 	ldr.w	r2, [r4, #384]	@ 0x180
    8182:	4790      	blx	r2
    8184:	2800      	cmp	r0, #0
    8186:	f040 8083 	bne.w	8290 <_scanf_i+0x1bc>
    818a:	f10b 0b01 	add.w	fp, fp, #1
    818e:	f1bb 0f03 	cmp.w	fp, #3
    8192:	d1cb      	bne.n	812c <_scanf_i+0x58>
    8194:	6861      	ldr	r1, [r4, #4]
    8196:	b909      	cbnz	r1, 819c <_scanf_i+0xc8>
    8198:	210a      	movs	r1, #10
    819a:	6061      	str	r1, [r4, #4]
    819c:	4b44      	ldr	r3, [pc, #272]	@ (82b0 <_scanf_i+0x1dc>)
    819e:	6960      	ldr	r0, [r4, #20]
    81a0:	1a59      	subs	r1, r3, r1
    81a2:	f000 f8f6 	bl	8392 <__sccl>
    81a6:	f04f 0b00 	mov.w	fp, #0
    81aa:	68a3      	ldr	r3, [r4, #8]
    81ac:	6822      	ldr	r2, [r4, #0]
    81ae:	2b00      	cmp	r3, #0
    81b0:	d03d      	beq.n	822e <_scanf_i+0x15a>
    81b2:	6831      	ldr	r1, [r6, #0]
    81b4:	6960      	ldr	r0, [r4, #20]
    81b6:	f891 c000 	ldrb.w	ip, [r1]
    81ba:	f810 000c 	ldrb.w	r0, [r0, ip]
    81be:	2800      	cmp	r0, #0
    81c0:	d035      	beq.n	822e <_scanf_i+0x15a>
    81c2:	f1bc 0f30 	cmp.w	ip, #48	@ 0x30
    81c6:	d124      	bne.n	8212 <_scanf_i+0x13e>
    81c8:	0510      	lsls	r0, r2, #20
    81ca:	d522      	bpl.n	8212 <_scanf_i+0x13e>
    81cc:	f10b 0b01 	add.w	fp, fp, #1
    81d0:	f1b9 0f00 	cmp.w	r9, #0
    81d4:	d003      	beq.n	81de <_scanf_i+0x10a>
    81d6:	3301      	adds	r3, #1
    81d8:	f109 39ff 	add.w	r9, r9, #4294967295
    81dc:	60a3      	str	r3, [r4, #8]
    81de:	6873      	ldr	r3, [r6, #4]
    81e0:	3b01      	subs	r3, #1
    81e2:	2b00      	cmp	r3, #0
    81e4:	6073      	str	r3, [r6, #4]
    81e6:	dd1b      	ble.n	8220 <_scanf_i+0x14c>
    81e8:	6833      	ldr	r3, [r6, #0]
    81ea:	3301      	adds	r3, #1
    81ec:	6033      	str	r3, [r6, #0]
    81ee:	68a3      	ldr	r3, [r4, #8]
    81f0:	3b01      	subs	r3, #1
    81f2:	60a3      	str	r3, [r4, #8]
    81f4:	e7d9      	b.n	81aa <_scanf_i+0xd6>
    81f6:	f1bb 0f02 	cmp.w	fp, #2
    81fa:	d1af      	bne.n	815c <_scanf_i+0x88>
    81fc:	6822      	ldr	r2, [r4, #0]
    81fe:	f402 61c0 	and.w	r1, r2, #1536	@ 0x600
    8202:	f5b1 7f00 	cmp.w	r1, #512	@ 0x200
    8206:	d1c5      	bne.n	8194 <_scanf_i+0xc0>
    8208:	2110      	movs	r1, #16
    820a:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
    820e:	6061      	str	r1, [r4, #4]
    8210:	e7a3      	b.n	815a <_scanf_i+0x86>
    8212:	f422 6210 	bic.w	r2, r2, #2304	@ 0x900
    8216:	6022      	str	r2, [r4, #0]
    8218:	780b      	ldrb	r3, [r1, #0]
    821a:	f805 3b01 	strb.w	r3, [r5], #1
    821e:	e7de      	b.n	81de <_scanf_i+0x10a>
    8220:	4631      	mov	r1, r6
    8222:	4650      	mov	r0, sl
    8224:	f8d4 3180 	ldr.w	r3, [r4, #384]	@ 0x180
    8228:	4798      	blx	r3
    822a:	2800      	cmp	r0, #0
    822c:	d0df      	beq.n	81ee <_scanf_i+0x11a>
    822e:	6823      	ldr	r3, [r4, #0]
    8230:	05db      	lsls	r3, r3, #23
    8232:	d50d      	bpl.n	8250 <_scanf_i+0x17c>
    8234:	42bd      	cmp	r5, r7
    8236:	d909      	bls.n	824c <_scanf_i+0x178>
    8238:	f815 1c01 	ldrb.w	r1, [r5, #-1]
    823c:	4632      	mov	r2, r6
    823e:	4650      	mov	r0, sl
    8240:	f8d4 317c 	ldr.w	r3, [r4, #380]	@ 0x17c
    8244:	f105 39ff 	add.w	r9, r5, #4294967295
    8248:	4798      	blx	r3
    824a:	464d      	mov	r5, r9
    824c:	42bd      	cmp	r5, r7
    824e:	d027      	beq.n	82a0 <_scanf_i+0x1cc>
    8250:	6822      	ldr	r2, [r4, #0]
    8252:	f012 0210 	ands.w	r2, r2, #16
    8256:	d112      	bne.n	827e <_scanf_i+0x1aa>
    8258:	702a      	strb	r2, [r5, #0]
    825a:	4639      	mov	r1, r7
    825c:	6863      	ldr	r3, [r4, #4]
    825e:	9e01      	ldr	r6, [sp, #4]
    8260:	4650      	mov	r0, sl
    8262:	47b0      	blx	r6
    8264:	f8d8 3000 	ldr.w	r3, [r8]
    8268:	6821      	ldr	r1, [r4, #0]
    826a:	1d1a      	adds	r2, r3, #4
    826c:	f8c8 2000 	str.w	r2, [r8]
    8270:	068e      	lsls	r6, r1, #26
    8272:	681b      	ldr	r3, [r3, #0]
    8274:	d50f      	bpl.n	8296 <_scanf_i+0x1c2>
    8276:	6018      	str	r0, [r3, #0]
    8278:	68e3      	ldr	r3, [r4, #12]
    827a:	3301      	adds	r3, #1
    827c:	60e3      	str	r3, [r4, #12]
    827e:	2000      	movs	r0, #0
    8280:	6923      	ldr	r3, [r4, #16]
    8282:	1bed      	subs	r5, r5, r7
    8284:	445d      	add	r5, fp
    8286:	442b      	add	r3, r5
    8288:	6123      	str	r3, [r4, #16]
    828a:	b007      	add	sp, #28
    828c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8290:	f04f 0b00 	mov.w	fp, #0
    8294:	e7cb      	b.n	822e <_scanf_i+0x15a>
    8296:	07ca      	lsls	r2, r1, #31
    8298:	bf4c      	ite	mi
    829a:	8018      	strhmi	r0, [r3, #0]
    829c:	6018      	strpl	r0, [r3, #0]
    829e:	e7eb      	b.n	8278 <_scanf_i+0x1a4>
    82a0:	2001      	movs	r0, #1
    82a2:	e7f2      	b.n	828a <_scanf_i+0x1b6>
    82a4:	0000baa0 	.word	0x0000baa0
    82a8:	00006c19 	.word	0x00006c19
    82ac:	0000863d 	.word	0x0000863d
    82b0:	0000ba93 	.word	0x0000ba93

000082b4 <fiprintf>:
    82b4:	b40e      	push	{r1, r2, r3}
    82b6:	b503      	push	{r0, r1, lr}
    82b8:	4601      	mov	r1, r0
    82ba:	ab03      	add	r3, sp, #12
    82bc:	4805      	ldr	r0, [pc, #20]	@ (82d4 <fiprintf+0x20>)
    82be:	f853 2b04 	ldr.w	r2, [r3], #4
    82c2:	6800      	ldr	r0, [r0, #0]
    82c4:	9301      	str	r3, [sp, #4]
    82c6:	f7ff fc01 	bl	7acc <_vfiprintf_r>
    82ca:	b002      	add	sp, #8
    82cc:	f85d eb04 	ldr.w	lr, [sp], #4
    82d0:	b003      	add	sp, #12
    82d2:	4770      	bx	lr
    82d4:	20000054 	.word	0x20000054

000082d8 <__swhatbuf_r>:
    82d8:	b570      	push	{r4, r5, r6, lr}
    82da:	460c      	mov	r4, r1
    82dc:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    82e0:	4615      	mov	r5, r2
    82e2:	2900      	cmp	r1, #0
    82e4:	461e      	mov	r6, r3
    82e6:	b096      	sub	sp, #88	@ 0x58
    82e8:	da0a      	bge.n	8300 <__swhatbuf_r+0x28>
    82ea:	89a1      	ldrh	r1, [r4, #12]
    82ec:	f011 0180 	ands.w	r1, r1, #128	@ 0x80
    82f0:	d113      	bne.n	831a <__swhatbuf_r+0x42>
    82f2:	f44f 6280 	mov.w	r2, #1024	@ 0x400
    82f6:	2000      	movs	r0, #0
    82f8:	6031      	str	r1, [r6, #0]
    82fa:	602a      	str	r2, [r5, #0]
    82fc:	b016      	add	sp, #88	@ 0x58
    82fe:	bd70      	pop	{r4, r5, r6, pc}
    8300:	466a      	mov	r2, sp
    8302:	f000 f8b7 	bl	8474 <_fstat_r>
    8306:	2800      	cmp	r0, #0
    8308:	dbef      	blt.n	82ea <__swhatbuf_r+0x12>
    830a:	9901      	ldr	r1, [sp, #4]
    830c:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
    8310:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
    8314:	4259      	negs	r1, r3
    8316:	4159      	adcs	r1, r3
    8318:	e7eb      	b.n	82f2 <__swhatbuf_r+0x1a>
    831a:	2100      	movs	r1, #0
    831c:	2240      	movs	r2, #64	@ 0x40
    831e:	e7ea      	b.n	82f6 <__swhatbuf_r+0x1e>

00008320 <__smakebuf_r>:
    8320:	898b      	ldrh	r3, [r1, #12]
    8322:	b573      	push	{r0, r1, r4, r5, r6, lr}
    8324:	079e      	lsls	r6, r3, #30
    8326:	4605      	mov	r5, r0
    8328:	460c      	mov	r4, r1
    832a:	d507      	bpl.n	833c <__smakebuf_r+0x1c>
    832c:	f104 0347 	add.w	r3, r4, #71	@ 0x47
    8330:	6023      	str	r3, [r4, #0]
    8332:	6123      	str	r3, [r4, #16]
    8334:	2301      	movs	r3, #1
    8336:	6163      	str	r3, [r4, #20]
    8338:	b002      	add	sp, #8
    833a:	bd70      	pop	{r4, r5, r6, pc}
    833c:	ab01      	add	r3, sp, #4
    833e:	466a      	mov	r2, sp
    8340:	f7ff ffca 	bl	82d8 <__swhatbuf_r>
    8344:	9e00      	ldr	r6, [sp, #0]
    8346:	4628      	mov	r0, r5
    8348:	4631      	mov	r1, r6
    834a:	f7ff f933 	bl	75b4 <_malloc_r>
    834e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    8352:	b938      	cbnz	r0, 8364 <__smakebuf_r+0x44>
    8354:	059a      	lsls	r2, r3, #22
    8356:	d4ef      	bmi.n	8338 <__smakebuf_r+0x18>
    8358:	f023 0303 	bic.w	r3, r3, #3
    835c:	f043 0302 	orr.w	r3, r3, #2
    8360:	81a3      	strh	r3, [r4, #12]
    8362:	e7e3      	b.n	832c <__smakebuf_r+0xc>
    8364:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
    8368:	81a3      	strh	r3, [r4, #12]
    836a:	9b01      	ldr	r3, [sp, #4]
    836c:	e9c4 0604 	strd	r0, r6, [r4, #16]
    8370:	6020      	str	r0, [r4, #0]
    8372:	2b00      	cmp	r3, #0
    8374:	d0e0      	beq.n	8338 <__smakebuf_r+0x18>
    8376:	4628      	mov	r0, r5
    8378:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    837c:	f000 f88c 	bl	8498 <_isatty_r>
    8380:	2800      	cmp	r0, #0
    8382:	d0d9      	beq.n	8338 <__smakebuf_r+0x18>
    8384:	89a3      	ldrh	r3, [r4, #12]
    8386:	f023 0303 	bic.w	r3, r3, #3
    838a:	f043 0301 	orr.w	r3, r3, #1
    838e:	81a3      	strh	r3, [r4, #12]
    8390:	e7d2      	b.n	8338 <__smakebuf_r+0x18>

00008392 <__sccl>:
    8392:	b570      	push	{r4, r5, r6, lr}
    8394:	780b      	ldrb	r3, [r1, #0]
    8396:	4604      	mov	r4, r0
    8398:	2b5e      	cmp	r3, #94	@ 0x5e
    839a:	bf0b      	itete	eq
    839c:	784b      	ldrbeq	r3, [r1, #1]
    839e:	1c4a      	addne	r2, r1, #1
    83a0:	1c8a      	addeq	r2, r1, #2
    83a2:	2100      	movne	r1, #0
    83a4:	bf08      	it	eq
    83a6:	2101      	moveq	r1, #1
    83a8:	3801      	subs	r0, #1
    83aa:	f104 05ff 	add.w	r5, r4, #255	@ 0xff
    83ae:	f800 1f01 	strb.w	r1, [r0, #1]!
    83b2:	42a8      	cmp	r0, r5
    83b4:	d1fb      	bne.n	83ae <__sccl+0x1c>
    83b6:	b90b      	cbnz	r3, 83bc <__sccl+0x2a>
    83b8:	1e50      	subs	r0, r2, #1
    83ba:	bd70      	pop	{r4, r5, r6, pc}
    83bc:	f081 0101 	eor.w	r1, r1, #1
    83c0:	4610      	mov	r0, r2
    83c2:	54e1      	strb	r1, [r4, r3]
    83c4:	4602      	mov	r2, r0
    83c6:	f812 5b01 	ldrb.w	r5, [r2], #1
    83ca:	2d2d      	cmp	r5, #45	@ 0x2d
    83cc:	d005      	beq.n	83da <__sccl+0x48>
    83ce:	2d5d      	cmp	r5, #93	@ 0x5d
    83d0:	d016      	beq.n	8400 <__sccl+0x6e>
    83d2:	2d00      	cmp	r5, #0
    83d4:	d0f1      	beq.n	83ba <__sccl+0x28>
    83d6:	462b      	mov	r3, r5
    83d8:	e7f2      	b.n	83c0 <__sccl+0x2e>
    83da:	7846      	ldrb	r6, [r0, #1]
    83dc:	2e5d      	cmp	r6, #93	@ 0x5d
    83de:	d0fa      	beq.n	83d6 <__sccl+0x44>
    83e0:	42b3      	cmp	r3, r6
    83e2:	dcf8      	bgt.n	83d6 <__sccl+0x44>
    83e4:	461a      	mov	r2, r3
    83e6:	3002      	adds	r0, #2
    83e8:	3201      	adds	r2, #1
    83ea:	4296      	cmp	r6, r2
    83ec:	54a1      	strb	r1, [r4, r2]
    83ee:	dcfb      	bgt.n	83e8 <__sccl+0x56>
    83f0:	1af2      	subs	r2, r6, r3
    83f2:	3a01      	subs	r2, #1
    83f4:	42b3      	cmp	r3, r6
    83f6:	bfa8      	it	ge
    83f8:	2200      	movge	r2, #0
    83fa:	3301      	adds	r3, #1
    83fc:	4413      	add	r3, r2
    83fe:	e7e1      	b.n	83c4 <__sccl+0x32>
    8400:	4610      	mov	r0, r2
    8402:	e7da      	b.n	83ba <__sccl+0x28>

00008404 <__submore>:
    8404:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    8408:	460c      	mov	r4, r1
    840a:	6b49      	ldr	r1, [r1, #52]	@ 0x34
    840c:	f104 0344 	add.w	r3, r4, #68	@ 0x44
    8410:	4299      	cmp	r1, r3
    8412:	d11b      	bne.n	844c <__submore+0x48>
    8414:	f44f 6180 	mov.w	r1, #1024	@ 0x400
    8418:	f7ff f8cc 	bl	75b4 <_malloc_r>
    841c:	b918      	cbnz	r0, 8426 <__submore+0x22>
    841e:	f04f 30ff 	mov.w	r0, #4294967295
    8422:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    8426:	f44f 6380 	mov.w	r3, #1024	@ 0x400
    842a:	63a3      	str	r3, [r4, #56]	@ 0x38
    842c:	f894 3046 	ldrb.w	r3, [r4, #70]	@ 0x46
    8430:	6360      	str	r0, [r4, #52]	@ 0x34
    8432:	f880 33ff 	strb.w	r3, [r0, #1023]	@ 0x3ff
    8436:	f894 3045 	ldrb.w	r3, [r4, #69]	@ 0x45
    843a:	f200 30fd 	addw	r0, r0, #1021	@ 0x3fd
    843e:	7043      	strb	r3, [r0, #1]
    8440:	f894 3044 	ldrb.w	r3, [r4, #68]	@ 0x44
    8444:	7003      	strb	r3, [r0, #0]
    8446:	6020      	str	r0, [r4, #0]
    8448:	2000      	movs	r0, #0
    844a:	e7ea      	b.n	8422 <__submore+0x1e>
    844c:	6ba6      	ldr	r6, [r4, #56]	@ 0x38
    844e:	0077      	lsls	r7, r6, #1
    8450:	463a      	mov	r2, r7
    8452:	f000 f856 	bl	8502 <_realloc_r>
    8456:	4605      	mov	r5, r0
    8458:	2800      	cmp	r0, #0
    845a:	d0e0      	beq.n	841e <__submore+0x1a>
    845c:	eb00 0806 	add.w	r8, r0, r6
    8460:	4601      	mov	r1, r0
    8462:	4632      	mov	r2, r6
    8464:	4640      	mov	r0, r8
    8466:	f7fe fff6 	bl	7456 <memcpy>
    846a:	e9c4 570d 	strd	r5, r7, [r4, #52]	@ 0x34
    846e:	f8c4 8000 	str.w	r8, [r4]
    8472:	e7e9      	b.n	8448 <__submore+0x44>

00008474 <_fstat_r>:
    8474:	b538      	push	{r3, r4, r5, lr}
    8476:	2300      	movs	r3, #0
    8478:	4d06      	ldr	r5, [pc, #24]	@ (8494 <_fstat_r+0x20>)
    847a:	4604      	mov	r4, r0
    847c:	4608      	mov	r0, r1
    847e:	4611      	mov	r1, r2
    8480:	602b      	str	r3, [r5, #0]
    8482:	f7f8 f8c0 	bl	606 <_fstat>
    8486:	1c43      	adds	r3, r0, #1
    8488:	d102      	bne.n	8490 <_fstat_r+0x1c>
    848a:	682b      	ldr	r3, [r5, #0]
    848c:	b103      	cbz	r3, 8490 <_fstat_r+0x1c>
    848e:	6023      	str	r3, [r4, #0]
    8490:	bd38      	pop	{r3, r4, r5, pc}
    8492:	bf00      	nop
    8494:	20004764 	.word	0x20004764

00008498 <_isatty_r>:
    8498:	b538      	push	{r3, r4, r5, lr}
    849a:	2300      	movs	r3, #0
    849c:	4d05      	ldr	r5, [pc, #20]	@ (84b4 <_isatty_r+0x1c>)
    849e:	4604      	mov	r4, r0
    84a0:	4608      	mov	r0, r1
    84a2:	602b      	str	r3, [r5, #0]
    84a4:	f7f8 f8c5 	bl	632 <_isatty>
    84a8:	1c43      	adds	r3, r0, #1
    84aa:	d102      	bne.n	84b2 <_isatty_r+0x1a>
    84ac:	682b      	ldr	r3, [r5, #0]
    84ae:	b103      	cbz	r3, 84b2 <_isatty_r+0x1a>
    84b0:	6023      	str	r3, [r4, #0]
    84b2:	bd38      	pop	{r3, r4, r5, pc}
    84b4:	20004764 	.word	0x20004764

000084b8 <_sbrk_r>:
    84b8:	b538      	push	{r3, r4, r5, lr}
    84ba:	2300      	movs	r3, #0
    84bc:	4d05      	ldr	r5, [pc, #20]	@ (84d4 <_sbrk_r+0x1c>)
    84be:	4604      	mov	r4, r0
    84c0:	4608      	mov	r0, r1
    84c2:	602b      	str	r3, [r5, #0]
    84c4:	f7f8 f8f4 	bl	6b0 <_sbrk>
    84c8:	1c43      	adds	r3, r0, #1
    84ca:	d102      	bne.n	84d2 <_sbrk_r+0x1a>
    84cc:	682b      	ldr	r3, [r5, #0]
    84ce:	b103      	cbz	r3, 84d2 <_sbrk_r+0x1a>
    84d0:	6023      	str	r3, [r4, #0]
    84d2:	bd38      	pop	{r3, r4, r5, pc}
    84d4:	20004764 	.word	0x20004764

000084d8 <memchr>:
    84d8:	4603      	mov	r3, r0
    84da:	b510      	push	{r4, lr}
    84dc:	b2c9      	uxtb	r1, r1
    84de:	4402      	add	r2, r0
    84e0:	4293      	cmp	r3, r2
    84e2:	4618      	mov	r0, r3
    84e4:	d101      	bne.n	84ea <memchr+0x12>
    84e6:	2000      	movs	r0, #0
    84e8:	e003      	b.n	84f2 <memchr+0x1a>
    84ea:	7804      	ldrb	r4, [r0, #0]
    84ec:	3301      	adds	r3, #1
    84ee:	428c      	cmp	r4, r1
    84f0:	d1f6      	bne.n	84e0 <memchr+0x8>
    84f2:	bd10      	pop	{r4, pc}

000084f4 <abort>:
    84f4:	2006      	movs	r0, #6
    84f6:	b508      	push	{r3, lr}
    84f8:	f000 f8ca 	bl	8690 <raise>
    84fc:	2001      	movs	r0, #1
    84fe:	f7f8 f87c 	bl	5fa <_exit>

00008502 <_realloc_r>:
    8502:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    8506:	4607      	mov	r7, r0
    8508:	4614      	mov	r4, r2
    850a:	460d      	mov	r5, r1
    850c:	b921      	cbnz	r1, 8518 <_realloc_r+0x16>
    850e:	4611      	mov	r1, r2
    8510:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    8514:	f7ff b84e 	b.w	75b4 <_malloc_r>
    8518:	b92a      	cbnz	r2, 8526 <_realloc_r+0x24>
    851a:	f7fe ffd1 	bl	74c0 <_free_r>
    851e:	4625      	mov	r5, r4
    8520:	4628      	mov	r0, r5
    8522:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    8526:	f000 f8cf 	bl	86c8 <_malloc_usable_size_r>
    852a:	4284      	cmp	r4, r0
    852c:	4606      	mov	r6, r0
    852e:	d802      	bhi.n	8536 <_realloc_r+0x34>
    8530:	ebb4 0f50 	cmp.w	r4, r0, lsr #1
    8534:	d8f4      	bhi.n	8520 <_realloc_r+0x1e>
    8536:	4621      	mov	r1, r4
    8538:	4638      	mov	r0, r7
    853a:	f7ff f83b 	bl	75b4 <_malloc_r>
    853e:	4680      	mov	r8, r0
    8540:	b908      	cbnz	r0, 8546 <_realloc_r+0x44>
    8542:	4645      	mov	r5, r8
    8544:	e7ec      	b.n	8520 <_realloc_r+0x1e>
    8546:	42b4      	cmp	r4, r6
    8548:	4622      	mov	r2, r4
    854a:	4629      	mov	r1, r5
    854c:	bf28      	it	cs
    854e:	4632      	movcs	r2, r6
    8550:	f7fe ff81 	bl	7456 <memcpy>
    8554:	4629      	mov	r1, r5
    8556:	4638      	mov	r0, r7
    8558:	f7fe ffb2 	bl	74c0 <_free_r>
    855c:	e7f1      	b.n	8542 <_realloc_r+0x40>
	...

00008560 <_strtoul_l.isra.0>:
    8560:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    8564:	4686      	mov	lr, r0
    8566:	460d      	mov	r5, r1
    8568:	4e33      	ldr	r6, [pc, #204]	@ (8638 <_strtoul_l.isra.0+0xd8>)
    856a:	4628      	mov	r0, r5
    856c:	f815 4b01 	ldrb.w	r4, [r5], #1
    8570:	5d37      	ldrb	r7, [r6, r4]
    8572:	f017 0708 	ands.w	r7, r7, #8
    8576:	d1f8      	bne.n	856a <_strtoul_l.isra.0+0xa>
    8578:	2c2d      	cmp	r4, #45	@ 0x2d
    857a:	d110      	bne.n	859e <_strtoul_l.isra.0+0x3e>
    857c:	2701      	movs	r7, #1
    857e:	782c      	ldrb	r4, [r5, #0]
    8580:	1c85      	adds	r5, r0, #2
    8582:	f033 0010 	bics.w	r0, r3, #16
    8586:	d115      	bne.n	85b4 <_strtoul_l.isra.0+0x54>
    8588:	2c30      	cmp	r4, #48	@ 0x30
    858a:	d10d      	bne.n	85a8 <_strtoul_l.isra.0+0x48>
    858c:	7828      	ldrb	r0, [r5, #0]
    858e:	f000 00df 	and.w	r0, r0, #223	@ 0xdf
    8592:	2858      	cmp	r0, #88	@ 0x58
    8594:	d108      	bne.n	85a8 <_strtoul_l.isra.0+0x48>
    8596:	786c      	ldrb	r4, [r5, #1]
    8598:	3502      	adds	r5, #2
    859a:	2310      	movs	r3, #16
    859c:	e00a      	b.n	85b4 <_strtoul_l.isra.0+0x54>
    859e:	2c2b      	cmp	r4, #43	@ 0x2b
    85a0:	bf04      	itt	eq
    85a2:	782c      	ldrbeq	r4, [r5, #0]
    85a4:	1c85      	addeq	r5, r0, #2
    85a6:	e7ec      	b.n	8582 <_strtoul_l.isra.0+0x22>
    85a8:	2b00      	cmp	r3, #0
    85aa:	d1f6      	bne.n	859a <_strtoul_l.isra.0+0x3a>
    85ac:	2c30      	cmp	r4, #48	@ 0x30
    85ae:	bf14      	ite	ne
    85b0:	230a      	movne	r3, #10
    85b2:	2308      	moveq	r3, #8
    85b4:	f04f 38ff 	mov.w	r8, #4294967295
    85b8:	fbb8 f8f3 	udiv	r8, r8, r3
    85bc:	2600      	movs	r6, #0
    85be:	fb03 f908 	mul.w	r9, r3, r8
    85c2:	4630      	mov	r0, r6
    85c4:	ea6f 0909 	mvn.w	r9, r9
    85c8:	f1a4 0c30 	sub.w	ip, r4, #48	@ 0x30
    85cc:	f1bc 0f09 	cmp.w	ip, #9
    85d0:	d810      	bhi.n	85f4 <_strtoul_l.isra.0+0x94>
    85d2:	4664      	mov	r4, ip
    85d4:	42a3      	cmp	r3, r4
    85d6:	dd1e      	ble.n	8616 <_strtoul_l.isra.0+0xb6>
    85d8:	f1b6 3fff 	cmp.w	r6, #4294967295
    85dc:	d007      	beq.n	85ee <_strtoul_l.isra.0+0x8e>
    85de:	4580      	cmp	r8, r0
    85e0:	d316      	bcc.n	8610 <_strtoul_l.isra.0+0xb0>
    85e2:	d101      	bne.n	85e8 <_strtoul_l.isra.0+0x88>
    85e4:	45a1      	cmp	r9, r4
    85e6:	db13      	blt.n	8610 <_strtoul_l.isra.0+0xb0>
    85e8:	2601      	movs	r6, #1
    85ea:	fb00 4003 	mla	r0, r0, r3, r4
    85ee:	f815 4b01 	ldrb.w	r4, [r5], #1
    85f2:	e7e9      	b.n	85c8 <_strtoul_l.isra.0+0x68>
    85f4:	f1a4 0c41 	sub.w	ip, r4, #65	@ 0x41
    85f8:	f1bc 0f19 	cmp.w	ip, #25
    85fc:	d801      	bhi.n	8602 <_strtoul_l.isra.0+0xa2>
    85fe:	3c37      	subs	r4, #55	@ 0x37
    8600:	e7e8      	b.n	85d4 <_strtoul_l.isra.0+0x74>
    8602:	f1a4 0c61 	sub.w	ip, r4, #97	@ 0x61
    8606:	f1bc 0f19 	cmp.w	ip, #25
    860a:	d804      	bhi.n	8616 <_strtoul_l.isra.0+0xb6>
    860c:	3c57      	subs	r4, #87	@ 0x57
    860e:	e7e1      	b.n	85d4 <_strtoul_l.isra.0+0x74>
    8610:	f04f 36ff 	mov.w	r6, #4294967295
    8614:	e7eb      	b.n	85ee <_strtoul_l.isra.0+0x8e>
    8616:	1c73      	adds	r3, r6, #1
    8618:	d106      	bne.n	8628 <_strtoul_l.isra.0+0xc8>
    861a:	2322      	movs	r3, #34	@ 0x22
    861c:	4630      	mov	r0, r6
    861e:	f8ce 3000 	str.w	r3, [lr]
    8622:	b932      	cbnz	r2, 8632 <_strtoul_l.isra.0+0xd2>
    8624:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    8628:	b107      	cbz	r7, 862c <_strtoul_l.isra.0+0xcc>
    862a:	4240      	negs	r0, r0
    862c:	2a00      	cmp	r2, #0
    862e:	d0f9      	beq.n	8624 <_strtoul_l.isra.0+0xc4>
    8630:	b106      	cbz	r6, 8634 <_strtoul_l.isra.0+0xd4>
    8632:	1e69      	subs	r1, r5, #1
    8634:	6011      	str	r1, [r2, #0]
    8636:	e7f5      	b.n	8624 <_strtoul_l.isra.0+0xc4>
    8638:	0000b879 	.word	0x0000b879

0000863c <_strtoul_r>:
    863c:	f7ff bf90 	b.w	8560 <_strtoul_l.isra.0>

00008640 <_raise_r>:
    8640:	291f      	cmp	r1, #31
    8642:	b538      	push	{r3, r4, r5, lr}
    8644:	4605      	mov	r5, r0
    8646:	460c      	mov	r4, r1
    8648:	d904      	bls.n	8654 <_raise_r+0x14>
    864a:	2316      	movs	r3, #22
    864c:	6003      	str	r3, [r0, #0]
    864e:	f04f 30ff 	mov.w	r0, #4294967295
    8652:	bd38      	pop	{r3, r4, r5, pc}
    8654:	6bc2      	ldr	r2, [r0, #60]	@ 0x3c
    8656:	b112      	cbz	r2, 865e <_raise_r+0x1e>
    8658:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
    865c:	b94b      	cbnz	r3, 8672 <_raise_r+0x32>
    865e:	4628      	mov	r0, r5
    8660:	f000 f830 	bl	86c4 <_getpid_r>
    8664:	4622      	mov	r2, r4
    8666:	4601      	mov	r1, r0
    8668:	4628      	mov	r0, r5
    866a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    866e:	f000 b817 	b.w	86a0 <_kill_r>
    8672:	2b01      	cmp	r3, #1
    8674:	d00a      	beq.n	868c <_raise_r+0x4c>
    8676:	1c59      	adds	r1, r3, #1
    8678:	d103      	bne.n	8682 <_raise_r+0x42>
    867a:	2316      	movs	r3, #22
    867c:	6003      	str	r3, [r0, #0]
    867e:	2001      	movs	r0, #1
    8680:	e7e7      	b.n	8652 <_raise_r+0x12>
    8682:	2100      	movs	r1, #0
    8684:	4620      	mov	r0, r4
    8686:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
    868a:	4798      	blx	r3
    868c:	2000      	movs	r0, #0
    868e:	e7e0      	b.n	8652 <_raise_r+0x12>

00008690 <raise>:
    8690:	4b02      	ldr	r3, [pc, #8]	@ (869c <raise+0xc>)
    8692:	4601      	mov	r1, r0
    8694:	6818      	ldr	r0, [r3, #0]
    8696:	f7ff bfd3 	b.w	8640 <_raise_r>
    869a:	bf00      	nop
    869c:	20000054 	.word	0x20000054

000086a0 <_kill_r>:
    86a0:	b538      	push	{r3, r4, r5, lr}
    86a2:	2300      	movs	r3, #0
    86a4:	4d06      	ldr	r5, [pc, #24]	@ (86c0 <_kill_r+0x20>)
    86a6:	4604      	mov	r4, r0
    86a8:	4608      	mov	r0, r1
    86aa:	4611      	mov	r1, r2
    86ac:	602b      	str	r3, [r5, #0]
    86ae:	f7f7 ffca 	bl	646 <_kill>
    86b2:	1c43      	adds	r3, r0, #1
    86b4:	d102      	bne.n	86bc <_kill_r+0x1c>
    86b6:	682b      	ldr	r3, [r5, #0]
    86b8:	b103      	cbz	r3, 86bc <_kill_r+0x1c>
    86ba:	6023      	str	r3, [r4, #0]
    86bc:	bd38      	pop	{r3, r4, r5, pc}
    86be:	bf00      	nop
    86c0:	20004764 	.word	0x20004764

000086c4 <_getpid_r>:
    86c4:	f7f7 bfae 	b.w	624 <_getpid>

000086c8 <_malloc_usable_size_r>:
    86c8:	f851 3c04 	ldr.w	r3, [r1, #-4]
    86cc:	1f18      	subs	r0, r3, #4
    86ce:	2b00      	cmp	r3, #0
    86d0:	bfbc      	itt	lt
    86d2:	580b      	ldrlt	r3, [r1, r0]
    86d4:	18c0      	addlt	r0, r0, r3
    86d6:	4770      	bx	lr

000086d8 <__aeabi_drsub>:
    86d8:	f081 4100 	eor.w	r1, r1, #2147483648	@ 0x80000000
    86dc:	e002      	b.n	86e4 <__adddf3>
    86de:	bf00      	nop

000086e0 <__aeabi_dsub>:
    86e0:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000

000086e4 <__adddf3>:
    86e4:	b530      	push	{r4, r5, lr}
    86e6:	ea4f 0441 	mov.w	r4, r1, lsl #1
    86ea:	ea4f 0543 	mov.w	r5, r3, lsl #1
    86ee:	ea94 0f05 	teq	r4, r5
    86f2:	bf08      	it	eq
    86f4:	ea90 0f02 	teqeq	r0, r2
    86f8:	bf1f      	itttt	ne
    86fa:	ea54 0c00 	orrsne.w	ip, r4, r0
    86fe:	ea55 0c02 	orrsne.w	ip, r5, r2
    8702:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
    8706:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    870a:	f000 80e2 	beq.w	88d2 <__adddf3+0x1ee>
    870e:	ea4f 5454 	mov.w	r4, r4, lsr #21
    8712:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
    8716:	bfb8      	it	lt
    8718:	426d      	neglt	r5, r5
    871a:	dd0c      	ble.n	8736 <__adddf3+0x52>
    871c:	442c      	add	r4, r5
    871e:	ea80 0202 	eor.w	r2, r0, r2
    8722:	ea81 0303 	eor.w	r3, r1, r3
    8726:	ea82 0000 	eor.w	r0, r2, r0
    872a:	ea83 0101 	eor.w	r1, r3, r1
    872e:	ea80 0202 	eor.w	r2, r0, r2
    8732:	ea81 0303 	eor.w	r3, r1, r3
    8736:	2d36      	cmp	r5, #54	@ 0x36
    8738:	bf88      	it	hi
    873a:	bd30      	pophi	{r4, r5, pc}
    873c:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
    8740:	ea4f 3101 	mov.w	r1, r1, lsl #12
    8744:	f44f 1c80 	mov.w	ip, #1048576	@ 0x100000
    8748:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
    874c:	d002      	beq.n	8754 <__adddf3+0x70>
    874e:	4240      	negs	r0, r0
    8750:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    8754:	f013 4f00 	tst.w	r3, #2147483648	@ 0x80000000
    8758:	ea4f 3303 	mov.w	r3, r3, lsl #12
    875c:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
    8760:	d002      	beq.n	8768 <__adddf3+0x84>
    8762:	4252      	negs	r2, r2
    8764:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    8768:	ea94 0f05 	teq	r4, r5
    876c:	f000 80a7 	beq.w	88be <__adddf3+0x1da>
    8770:	f1a4 0401 	sub.w	r4, r4, #1
    8774:	f1d5 0e20 	rsbs	lr, r5, #32
    8778:	db0d      	blt.n	8796 <__adddf3+0xb2>
    877a:	fa02 fc0e 	lsl.w	ip, r2, lr
    877e:	fa22 f205 	lsr.w	r2, r2, r5
    8782:	1880      	adds	r0, r0, r2
    8784:	f141 0100 	adc.w	r1, r1, #0
    8788:	fa03 f20e 	lsl.w	r2, r3, lr
    878c:	1880      	adds	r0, r0, r2
    878e:	fa43 f305 	asr.w	r3, r3, r5
    8792:	4159      	adcs	r1, r3
    8794:	e00e      	b.n	87b4 <__adddf3+0xd0>
    8796:	f1a5 0520 	sub.w	r5, r5, #32
    879a:	f10e 0e20 	add.w	lr, lr, #32
    879e:	2a01      	cmp	r2, #1
    87a0:	fa03 fc0e 	lsl.w	ip, r3, lr
    87a4:	bf28      	it	cs
    87a6:	f04c 0c02 	orrcs.w	ip, ip, #2
    87aa:	fa43 f305 	asr.w	r3, r3, r5
    87ae:	18c0      	adds	r0, r0, r3
    87b0:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
    87b4:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
    87b8:	d507      	bpl.n	87ca <__adddf3+0xe6>
    87ba:	f04f 0e00 	mov.w	lr, #0
    87be:	f1dc 0c00 	rsbs	ip, ip, #0
    87c2:	eb7e 0000 	sbcs.w	r0, lr, r0
    87c6:	eb6e 0101 	sbc.w	r1, lr, r1
    87ca:	f5b1 1f80 	cmp.w	r1, #1048576	@ 0x100000
    87ce:	d31b      	bcc.n	8808 <__adddf3+0x124>
    87d0:	f5b1 1f00 	cmp.w	r1, #2097152	@ 0x200000
    87d4:	d30c      	bcc.n	87f0 <__adddf3+0x10c>
    87d6:	0849      	lsrs	r1, r1, #1
    87d8:	ea5f 0030 	movs.w	r0, r0, rrx
    87dc:	ea4f 0c3c 	mov.w	ip, ip, rrx
    87e0:	f104 0401 	add.w	r4, r4, #1
    87e4:	ea4f 5244 	mov.w	r2, r4, lsl #21
    87e8:	f512 0f80 	cmn.w	r2, #4194304	@ 0x400000
    87ec:	f080 809a 	bcs.w	8924 <__adddf3+0x240>
    87f0:	f1bc 4f00 	cmp.w	ip, #2147483648	@ 0x80000000
    87f4:	bf08      	it	eq
    87f6:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    87fa:	f150 0000 	adcs.w	r0, r0, #0
    87fe:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    8802:	ea41 0105 	orr.w	r1, r1, r5
    8806:	bd30      	pop	{r4, r5, pc}
    8808:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
    880c:	4140      	adcs	r0, r0
    880e:	eb41 0101 	adc.w	r1, r1, r1
    8812:	3c01      	subs	r4, #1
    8814:	bf28      	it	cs
    8816:	f5b1 1f80 	cmpcs.w	r1, #1048576	@ 0x100000
    881a:	d2e9      	bcs.n	87f0 <__adddf3+0x10c>
    881c:	f091 0f00 	teq	r1, #0
    8820:	bf04      	itt	eq
    8822:	4601      	moveq	r1, r0
    8824:	2000      	moveq	r0, #0
    8826:	fab1 f381 	clz	r3, r1
    882a:	bf08      	it	eq
    882c:	3320      	addeq	r3, #32
    882e:	f1a3 030b 	sub.w	r3, r3, #11
    8832:	f1b3 0220 	subs.w	r2, r3, #32
    8836:	da0c      	bge.n	8852 <__adddf3+0x16e>
    8838:	320c      	adds	r2, #12
    883a:	dd08      	ble.n	884e <__adddf3+0x16a>
    883c:	f102 0c14 	add.w	ip, r2, #20
    8840:	f1c2 020c 	rsb	r2, r2, #12
    8844:	fa01 f00c 	lsl.w	r0, r1, ip
    8848:	fa21 f102 	lsr.w	r1, r1, r2
    884c:	e00c      	b.n	8868 <__adddf3+0x184>
    884e:	f102 0214 	add.w	r2, r2, #20
    8852:	bfd8      	it	le
    8854:	f1c2 0c20 	rsble	ip, r2, #32
    8858:	fa01 f102 	lsl.w	r1, r1, r2
    885c:	fa20 fc0c 	lsr.w	ip, r0, ip
    8860:	bfdc      	itt	le
    8862:	ea41 010c 	orrle.w	r1, r1, ip
    8866:	4090      	lslle	r0, r2
    8868:	1ae4      	subs	r4, r4, r3
    886a:	bfa2      	ittt	ge
    886c:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
    8870:	4329      	orrge	r1, r5
    8872:	bd30      	popge	{r4, r5, pc}
    8874:	ea6f 0404 	mvn.w	r4, r4
    8878:	3c1f      	subs	r4, #31
    887a:	da1c      	bge.n	88b6 <__adddf3+0x1d2>
    887c:	340c      	adds	r4, #12
    887e:	dc0e      	bgt.n	889e <__adddf3+0x1ba>
    8880:	f104 0414 	add.w	r4, r4, #20
    8884:	f1c4 0220 	rsb	r2, r4, #32
    8888:	fa20 f004 	lsr.w	r0, r0, r4
    888c:	fa01 f302 	lsl.w	r3, r1, r2
    8890:	ea40 0003 	orr.w	r0, r0, r3
    8894:	fa21 f304 	lsr.w	r3, r1, r4
    8898:	ea45 0103 	orr.w	r1, r5, r3
    889c:	bd30      	pop	{r4, r5, pc}
    889e:	f1c4 040c 	rsb	r4, r4, #12
    88a2:	f1c4 0220 	rsb	r2, r4, #32
    88a6:	fa20 f002 	lsr.w	r0, r0, r2
    88aa:	fa01 f304 	lsl.w	r3, r1, r4
    88ae:	ea40 0003 	orr.w	r0, r0, r3
    88b2:	4629      	mov	r1, r5
    88b4:	bd30      	pop	{r4, r5, pc}
    88b6:	fa21 f004 	lsr.w	r0, r1, r4
    88ba:	4629      	mov	r1, r5
    88bc:	bd30      	pop	{r4, r5, pc}
    88be:	f094 0f00 	teq	r4, #0
    88c2:	f483 1380 	eor.w	r3, r3, #1048576	@ 0x100000
    88c6:	bf06      	itte	eq
    88c8:	f481 1180 	eoreq.w	r1, r1, #1048576	@ 0x100000
    88cc:	3401      	addeq	r4, #1
    88ce:	3d01      	subne	r5, #1
    88d0:	e74e      	b.n	8770 <__adddf3+0x8c>
    88d2:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    88d6:	bf18      	it	ne
    88d8:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    88dc:	d029      	beq.n	8932 <__adddf3+0x24e>
    88de:	ea94 0f05 	teq	r4, r5
    88e2:	bf08      	it	eq
    88e4:	ea90 0f02 	teqeq	r0, r2
    88e8:	d005      	beq.n	88f6 <__adddf3+0x212>
    88ea:	ea54 0c00 	orrs.w	ip, r4, r0
    88ee:	bf04      	itt	eq
    88f0:	4619      	moveq	r1, r3
    88f2:	4610      	moveq	r0, r2
    88f4:	bd30      	pop	{r4, r5, pc}
    88f6:	ea91 0f03 	teq	r1, r3
    88fa:	bf1e      	ittt	ne
    88fc:	2100      	movne	r1, #0
    88fe:	2000      	movne	r0, #0
    8900:	bd30      	popne	{r4, r5, pc}
    8902:	ea5f 5c54 	movs.w	ip, r4, lsr #21
    8906:	d105      	bne.n	8914 <__adddf3+0x230>
    8908:	0040      	lsls	r0, r0, #1
    890a:	4149      	adcs	r1, r1
    890c:	bf28      	it	cs
    890e:	f041 4100 	orrcs.w	r1, r1, #2147483648	@ 0x80000000
    8912:	bd30      	pop	{r4, r5, pc}
    8914:	f514 0480 	adds.w	r4, r4, #4194304	@ 0x400000
    8918:	bf3c      	itt	cc
    891a:	f501 1180 	addcc.w	r1, r1, #1048576	@ 0x100000
    891e:	bd30      	popcc	{r4, r5, pc}
    8920:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
    8924:	f045 41fe 	orr.w	r1, r5, #2130706432	@ 0x7f000000
    8928:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
    892c:	f04f 0000 	mov.w	r0, #0
    8930:	bd30      	pop	{r4, r5, pc}
    8932:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    8936:	bf1a      	itte	ne
    8938:	4619      	movne	r1, r3
    893a:	4610      	movne	r0, r2
    893c:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
    8940:	bf1c      	itt	ne
    8942:	460b      	movne	r3, r1
    8944:	4602      	movne	r2, r0
    8946:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    894a:	bf06      	itte	eq
    894c:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
    8950:	ea91 0f03 	teqeq	r1, r3
    8954:	f441 2100 	orrne.w	r1, r1, #524288	@ 0x80000
    8958:	bd30      	pop	{r4, r5, pc}
    895a:	bf00      	nop

0000895c <__aeabi_ui2d>:
    895c:	f090 0f00 	teq	r0, #0
    8960:	bf04      	itt	eq
    8962:	2100      	moveq	r1, #0
    8964:	4770      	bxeq	lr
    8966:	b530      	push	{r4, r5, lr}
    8968:	f44f 6480 	mov.w	r4, #1024	@ 0x400
    896c:	f104 0432 	add.w	r4, r4, #50	@ 0x32
    8970:	f04f 0500 	mov.w	r5, #0
    8974:	f04f 0100 	mov.w	r1, #0
    8978:	e750      	b.n	881c <__adddf3+0x138>
    897a:	bf00      	nop

0000897c <__aeabi_i2d>:
    897c:	f090 0f00 	teq	r0, #0
    8980:	bf04      	itt	eq
    8982:	2100      	moveq	r1, #0
    8984:	4770      	bxeq	lr
    8986:	b530      	push	{r4, r5, lr}
    8988:	f44f 6480 	mov.w	r4, #1024	@ 0x400
    898c:	f104 0432 	add.w	r4, r4, #50	@ 0x32
    8990:	f010 4500 	ands.w	r5, r0, #2147483648	@ 0x80000000
    8994:	bf48      	it	mi
    8996:	4240      	negmi	r0, r0
    8998:	f04f 0100 	mov.w	r1, #0
    899c:	e73e      	b.n	881c <__adddf3+0x138>
    899e:	bf00      	nop

000089a0 <__aeabi_f2d>:
    89a0:	0042      	lsls	r2, r0, #1
    89a2:	ea4f 01e2 	mov.w	r1, r2, asr #3
    89a6:	ea4f 0131 	mov.w	r1, r1, rrx
    89aa:	ea4f 7002 	mov.w	r0, r2, lsl #28
    89ae:	bf1f      	itttt	ne
    89b0:	f012 437f 	andsne.w	r3, r2, #4278190080	@ 0xff000000
    89b4:	f093 4f7f 	teqne	r3, #4278190080	@ 0xff000000
    89b8:	f081 5160 	eorne.w	r1, r1, #939524096	@ 0x38000000
    89bc:	4770      	bxne	lr
    89be:	f032 427f 	bics.w	r2, r2, #4278190080	@ 0xff000000
    89c2:	bf08      	it	eq
    89c4:	4770      	bxeq	lr
    89c6:	f093 4f7f 	teq	r3, #4278190080	@ 0xff000000
    89ca:	bf04      	itt	eq
    89cc:	f441 2100 	orreq.w	r1, r1, #524288	@ 0x80000
    89d0:	4770      	bxeq	lr
    89d2:	b530      	push	{r4, r5, lr}
    89d4:	f44f 7460 	mov.w	r4, #896	@ 0x380
    89d8:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
    89dc:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
    89e0:	e71c      	b.n	881c <__adddf3+0x138>
    89e2:	bf00      	nop

000089e4 <__aeabi_ul2d>:
    89e4:	ea50 0201 	orrs.w	r2, r0, r1
    89e8:	bf08      	it	eq
    89ea:	4770      	bxeq	lr
    89ec:	b530      	push	{r4, r5, lr}
    89ee:	f04f 0500 	mov.w	r5, #0
    89f2:	e00a      	b.n	8a0a <__aeabi_l2d+0x16>

000089f4 <__aeabi_l2d>:
    89f4:	ea50 0201 	orrs.w	r2, r0, r1
    89f8:	bf08      	it	eq
    89fa:	4770      	bxeq	lr
    89fc:	b530      	push	{r4, r5, lr}
    89fe:	f011 4500 	ands.w	r5, r1, #2147483648	@ 0x80000000
    8a02:	d502      	bpl.n	8a0a <__aeabi_l2d+0x16>
    8a04:	4240      	negs	r0, r0
    8a06:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    8a0a:	f44f 6480 	mov.w	r4, #1024	@ 0x400
    8a0e:	f104 0432 	add.w	r4, r4, #50	@ 0x32
    8a12:	ea5f 5c91 	movs.w	ip, r1, lsr #22
    8a16:	f43f aed8 	beq.w	87ca <__adddf3+0xe6>
    8a1a:	f04f 0203 	mov.w	r2, #3
    8a1e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    8a22:	bf18      	it	ne
    8a24:	3203      	addne	r2, #3
    8a26:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    8a2a:	bf18      	it	ne
    8a2c:	3203      	addne	r2, #3
    8a2e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
    8a32:	f1c2 0320 	rsb	r3, r2, #32
    8a36:	fa00 fc03 	lsl.w	ip, r0, r3
    8a3a:	fa20 f002 	lsr.w	r0, r0, r2
    8a3e:	fa01 fe03 	lsl.w	lr, r1, r3
    8a42:	ea40 000e 	orr.w	r0, r0, lr
    8a46:	fa21 f102 	lsr.w	r1, r1, r2
    8a4a:	4414      	add	r4, r2
    8a4c:	e6bd      	b.n	87ca <__adddf3+0xe6>
    8a4e:	bf00      	nop

00008a50 <__aeabi_dmul>:
    8a50:	b570      	push	{r4, r5, r6, lr}
    8a52:	f04f 0cff 	mov.w	ip, #255	@ 0xff
    8a56:	f44c 6ce0 	orr.w	ip, ip, #1792	@ 0x700
    8a5a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    8a5e:	bf1d      	ittte	ne
    8a60:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    8a64:	ea94 0f0c 	teqne	r4, ip
    8a68:	ea95 0f0c 	teqne	r5, ip
    8a6c:	f000 f8de 	bleq	8c2c <__aeabi_dmul+0x1dc>
    8a70:	442c      	add	r4, r5
    8a72:	ea81 0603 	eor.w	r6, r1, r3
    8a76:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
    8a7a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
    8a7e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
    8a82:	bf18      	it	ne
    8a84:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
    8a88:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
    8a8c:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
    8a90:	d038      	beq.n	8b04 <__aeabi_dmul+0xb4>
    8a92:	fba0 ce02 	umull	ip, lr, r0, r2
    8a96:	f04f 0500 	mov.w	r5, #0
    8a9a:	fbe1 e502 	umlal	lr, r5, r1, r2
    8a9e:	f006 4200 	and.w	r2, r6, #2147483648	@ 0x80000000
    8aa2:	fbe0 e503 	umlal	lr, r5, r0, r3
    8aa6:	f04f 0600 	mov.w	r6, #0
    8aaa:	fbe1 5603 	umlal	r5, r6, r1, r3
    8aae:	f09c 0f00 	teq	ip, #0
    8ab2:	bf18      	it	ne
    8ab4:	f04e 0e01 	orrne.w	lr, lr, #1
    8ab8:	f1a4 04ff 	sub.w	r4, r4, #255	@ 0xff
    8abc:	f5b6 7f00 	cmp.w	r6, #512	@ 0x200
    8ac0:	f564 7440 	sbc.w	r4, r4, #768	@ 0x300
    8ac4:	d204      	bcs.n	8ad0 <__aeabi_dmul+0x80>
    8ac6:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
    8aca:	416d      	adcs	r5, r5
    8acc:	eb46 0606 	adc.w	r6, r6, r6
    8ad0:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
    8ad4:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
    8ad8:	ea4f 20c5 	mov.w	r0, r5, lsl #11
    8adc:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
    8ae0:	ea4f 2ece 	mov.w	lr, lr, lsl #11
    8ae4:	f1b4 0cfd 	subs.w	ip, r4, #253	@ 0xfd
    8ae8:	bf88      	it	hi
    8aea:	f5bc 6fe0 	cmphi.w	ip, #1792	@ 0x700
    8aee:	d81e      	bhi.n	8b2e <__aeabi_dmul+0xde>
    8af0:	f1be 4f00 	cmp.w	lr, #2147483648	@ 0x80000000
    8af4:	bf08      	it	eq
    8af6:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
    8afa:	f150 0000 	adcs.w	r0, r0, #0
    8afe:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    8b02:	bd70      	pop	{r4, r5, r6, pc}
    8b04:	f006 4600 	and.w	r6, r6, #2147483648	@ 0x80000000
    8b08:	ea46 0101 	orr.w	r1, r6, r1
    8b0c:	ea40 0002 	orr.w	r0, r0, r2
    8b10:	ea81 0103 	eor.w	r1, r1, r3
    8b14:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
    8b18:	bfc2      	ittt	gt
    8b1a:	ebd4 050c 	rsbsgt	r5, r4, ip
    8b1e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    8b22:	bd70      	popgt	{r4, r5, r6, pc}
    8b24:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
    8b28:	f04f 0e00 	mov.w	lr, #0
    8b2c:	3c01      	subs	r4, #1
    8b2e:	f300 80ab 	bgt.w	8c88 <__aeabi_dmul+0x238>
    8b32:	f114 0f36 	cmn.w	r4, #54	@ 0x36
    8b36:	bfde      	ittt	le
    8b38:	2000      	movle	r0, #0
    8b3a:	f001 4100 	andle.w	r1, r1, #2147483648	@ 0x80000000
    8b3e:	bd70      	pople	{r4, r5, r6, pc}
    8b40:	f1c4 0400 	rsb	r4, r4, #0
    8b44:	3c20      	subs	r4, #32
    8b46:	da35      	bge.n	8bb4 <__aeabi_dmul+0x164>
    8b48:	340c      	adds	r4, #12
    8b4a:	dc1b      	bgt.n	8b84 <__aeabi_dmul+0x134>
    8b4c:	f104 0414 	add.w	r4, r4, #20
    8b50:	f1c4 0520 	rsb	r5, r4, #32
    8b54:	fa00 f305 	lsl.w	r3, r0, r5
    8b58:	fa20 f004 	lsr.w	r0, r0, r4
    8b5c:	fa01 f205 	lsl.w	r2, r1, r5
    8b60:	ea40 0002 	orr.w	r0, r0, r2
    8b64:	f001 4200 	and.w	r2, r1, #2147483648	@ 0x80000000
    8b68:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
    8b6c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    8b70:	fa21 f604 	lsr.w	r6, r1, r4
    8b74:	eb42 0106 	adc.w	r1, r2, r6
    8b78:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    8b7c:	bf08      	it	eq
    8b7e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    8b82:	bd70      	pop	{r4, r5, r6, pc}
    8b84:	f1c4 040c 	rsb	r4, r4, #12
    8b88:	f1c4 0520 	rsb	r5, r4, #32
    8b8c:	fa00 f304 	lsl.w	r3, r0, r4
    8b90:	fa20 f005 	lsr.w	r0, r0, r5
    8b94:	fa01 f204 	lsl.w	r2, r1, r4
    8b98:	ea40 0002 	orr.w	r0, r0, r2
    8b9c:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
    8ba0:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    8ba4:	f141 0100 	adc.w	r1, r1, #0
    8ba8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    8bac:	bf08      	it	eq
    8bae:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    8bb2:	bd70      	pop	{r4, r5, r6, pc}
    8bb4:	f1c4 0520 	rsb	r5, r4, #32
    8bb8:	fa00 f205 	lsl.w	r2, r0, r5
    8bbc:	ea4e 0e02 	orr.w	lr, lr, r2
    8bc0:	fa20 f304 	lsr.w	r3, r0, r4
    8bc4:	fa01 f205 	lsl.w	r2, r1, r5
    8bc8:	ea43 0302 	orr.w	r3, r3, r2
    8bcc:	fa21 f004 	lsr.w	r0, r1, r4
    8bd0:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
    8bd4:	fa21 f204 	lsr.w	r2, r1, r4
    8bd8:	ea20 0002 	bic.w	r0, r0, r2
    8bdc:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
    8be0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    8be4:	bf08      	it	eq
    8be6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    8bea:	bd70      	pop	{r4, r5, r6, pc}
    8bec:	f094 0f00 	teq	r4, #0
    8bf0:	d10f      	bne.n	8c12 <__aeabi_dmul+0x1c2>
    8bf2:	f001 4600 	and.w	r6, r1, #2147483648	@ 0x80000000
    8bf6:	0040      	lsls	r0, r0, #1
    8bf8:	eb41 0101 	adc.w	r1, r1, r1
    8bfc:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
    8c00:	bf08      	it	eq
    8c02:	3c01      	subeq	r4, #1
    8c04:	d0f7      	beq.n	8bf6 <__aeabi_dmul+0x1a6>
    8c06:	ea41 0106 	orr.w	r1, r1, r6
    8c0a:	f095 0f00 	teq	r5, #0
    8c0e:	bf18      	it	ne
    8c10:	4770      	bxne	lr
    8c12:	f003 4600 	and.w	r6, r3, #2147483648	@ 0x80000000
    8c16:	0052      	lsls	r2, r2, #1
    8c18:	eb43 0303 	adc.w	r3, r3, r3
    8c1c:	f413 1f80 	tst.w	r3, #1048576	@ 0x100000
    8c20:	bf08      	it	eq
    8c22:	3d01      	subeq	r5, #1
    8c24:	d0f7      	beq.n	8c16 <__aeabi_dmul+0x1c6>
    8c26:	ea43 0306 	orr.w	r3, r3, r6
    8c2a:	4770      	bx	lr
    8c2c:	ea94 0f0c 	teq	r4, ip
    8c30:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    8c34:	bf18      	it	ne
    8c36:	ea95 0f0c 	teqne	r5, ip
    8c3a:	d00c      	beq.n	8c56 <__aeabi_dmul+0x206>
    8c3c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    8c40:	bf18      	it	ne
    8c42:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    8c46:	d1d1      	bne.n	8bec <__aeabi_dmul+0x19c>
    8c48:	ea81 0103 	eor.w	r1, r1, r3
    8c4c:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
    8c50:	f04f 0000 	mov.w	r0, #0
    8c54:	bd70      	pop	{r4, r5, r6, pc}
    8c56:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    8c5a:	bf06      	itte	eq
    8c5c:	4610      	moveq	r0, r2
    8c5e:	4619      	moveq	r1, r3
    8c60:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    8c64:	d019      	beq.n	8c9a <__aeabi_dmul+0x24a>
    8c66:	ea94 0f0c 	teq	r4, ip
    8c6a:	d102      	bne.n	8c72 <__aeabi_dmul+0x222>
    8c6c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
    8c70:	d113      	bne.n	8c9a <__aeabi_dmul+0x24a>
    8c72:	ea95 0f0c 	teq	r5, ip
    8c76:	d105      	bne.n	8c84 <__aeabi_dmul+0x234>
    8c78:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
    8c7c:	bf1c      	itt	ne
    8c7e:	4610      	movne	r0, r2
    8c80:	4619      	movne	r1, r3
    8c82:	d10a      	bne.n	8c9a <__aeabi_dmul+0x24a>
    8c84:	ea81 0103 	eor.w	r1, r1, r3
    8c88:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
    8c8c:	f041 41fe 	orr.w	r1, r1, #2130706432	@ 0x7f000000
    8c90:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
    8c94:	f04f 0000 	mov.w	r0, #0
    8c98:	bd70      	pop	{r4, r5, r6, pc}
    8c9a:	f041 41fe 	orr.w	r1, r1, #2130706432	@ 0x7f000000
    8c9e:	f441 0178 	orr.w	r1, r1, #16252928	@ 0xf80000
    8ca2:	bd70      	pop	{r4, r5, r6, pc}

00008ca4 <__aeabi_ddiv>:
    8ca4:	b570      	push	{r4, r5, r6, lr}
    8ca6:	f04f 0cff 	mov.w	ip, #255	@ 0xff
    8caa:	f44c 6ce0 	orr.w	ip, ip, #1792	@ 0x700
    8cae:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    8cb2:	bf1d      	ittte	ne
    8cb4:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    8cb8:	ea94 0f0c 	teqne	r4, ip
    8cbc:	ea95 0f0c 	teqne	r5, ip
    8cc0:	f000 f8a7 	bleq	8e12 <__aeabi_ddiv+0x16e>
    8cc4:	eba4 0405 	sub.w	r4, r4, r5
    8cc8:	ea81 0e03 	eor.w	lr, r1, r3
    8ccc:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    8cd0:	ea4f 3101 	mov.w	r1, r1, lsl #12
    8cd4:	f000 8088 	beq.w	8de8 <__aeabi_ddiv+0x144>
    8cd8:	ea4f 3303 	mov.w	r3, r3, lsl #12
    8cdc:	f04f 5580 	mov.w	r5, #268435456	@ 0x10000000
    8ce0:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
    8ce4:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
    8ce8:	ea4f 2202 	mov.w	r2, r2, lsl #8
    8cec:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
    8cf0:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
    8cf4:	ea4f 2600 	mov.w	r6, r0, lsl #8
    8cf8:	f00e 4100 	and.w	r1, lr, #2147483648	@ 0x80000000
    8cfc:	429d      	cmp	r5, r3
    8cfe:	bf08      	it	eq
    8d00:	4296      	cmpeq	r6, r2
    8d02:	f144 04fd 	adc.w	r4, r4, #253	@ 0xfd
    8d06:	f504 7440 	add.w	r4, r4, #768	@ 0x300
    8d0a:	d202      	bcs.n	8d12 <__aeabi_ddiv+0x6e>
    8d0c:	085b      	lsrs	r3, r3, #1
    8d0e:	ea4f 0232 	mov.w	r2, r2, rrx
    8d12:	1ab6      	subs	r6, r6, r2
    8d14:	eb65 0503 	sbc.w	r5, r5, r3
    8d18:	085b      	lsrs	r3, r3, #1
    8d1a:	ea4f 0232 	mov.w	r2, r2, rrx
    8d1e:	f44f 1080 	mov.w	r0, #1048576	@ 0x100000
    8d22:	f44f 2c00 	mov.w	ip, #524288	@ 0x80000
    8d26:	ebb6 0e02 	subs.w	lr, r6, r2
    8d2a:	eb75 0e03 	sbcs.w	lr, r5, r3
    8d2e:	bf22      	ittt	cs
    8d30:	1ab6      	subcs	r6, r6, r2
    8d32:	4675      	movcs	r5, lr
    8d34:	ea40 000c 	orrcs.w	r0, r0, ip
    8d38:	085b      	lsrs	r3, r3, #1
    8d3a:	ea4f 0232 	mov.w	r2, r2, rrx
    8d3e:	ebb6 0e02 	subs.w	lr, r6, r2
    8d42:	eb75 0e03 	sbcs.w	lr, r5, r3
    8d46:	bf22      	ittt	cs
    8d48:	1ab6      	subcs	r6, r6, r2
    8d4a:	4675      	movcs	r5, lr
    8d4c:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
    8d50:	085b      	lsrs	r3, r3, #1
    8d52:	ea4f 0232 	mov.w	r2, r2, rrx
    8d56:	ebb6 0e02 	subs.w	lr, r6, r2
    8d5a:	eb75 0e03 	sbcs.w	lr, r5, r3
    8d5e:	bf22      	ittt	cs
    8d60:	1ab6      	subcs	r6, r6, r2
    8d62:	4675      	movcs	r5, lr
    8d64:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
    8d68:	085b      	lsrs	r3, r3, #1
    8d6a:	ea4f 0232 	mov.w	r2, r2, rrx
    8d6e:	ebb6 0e02 	subs.w	lr, r6, r2
    8d72:	eb75 0e03 	sbcs.w	lr, r5, r3
    8d76:	bf22      	ittt	cs
    8d78:	1ab6      	subcs	r6, r6, r2
    8d7a:	4675      	movcs	r5, lr
    8d7c:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
    8d80:	ea55 0e06 	orrs.w	lr, r5, r6
    8d84:	d018      	beq.n	8db8 <__aeabi_ddiv+0x114>
    8d86:	ea4f 1505 	mov.w	r5, r5, lsl #4
    8d8a:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
    8d8e:	ea4f 1606 	mov.w	r6, r6, lsl #4
    8d92:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    8d96:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
    8d9a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
    8d9e:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
    8da2:	d1c0      	bne.n	8d26 <__aeabi_ddiv+0x82>
    8da4:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
    8da8:	d10b      	bne.n	8dc2 <__aeabi_ddiv+0x11e>
    8daa:	ea41 0100 	orr.w	r1, r1, r0
    8dae:	f04f 0000 	mov.w	r0, #0
    8db2:	f04f 4c00 	mov.w	ip, #2147483648	@ 0x80000000
    8db6:	e7b6      	b.n	8d26 <__aeabi_ddiv+0x82>
    8db8:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
    8dbc:	bf04      	itt	eq
    8dbe:	4301      	orreq	r1, r0
    8dc0:	2000      	moveq	r0, #0
    8dc2:	f1b4 0cfd 	subs.w	ip, r4, #253	@ 0xfd
    8dc6:	bf88      	it	hi
    8dc8:	f5bc 6fe0 	cmphi.w	ip, #1792	@ 0x700
    8dcc:	f63f aeaf 	bhi.w	8b2e <__aeabi_dmul+0xde>
    8dd0:	ebb5 0c03 	subs.w	ip, r5, r3
    8dd4:	bf04      	itt	eq
    8dd6:	ebb6 0c02 	subseq.w	ip, r6, r2
    8dda:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    8dde:	f150 0000 	adcs.w	r0, r0, #0
    8de2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    8de6:	bd70      	pop	{r4, r5, r6, pc}
    8de8:	f00e 4e00 	and.w	lr, lr, #2147483648	@ 0x80000000
    8dec:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
    8df0:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
    8df4:	bfc2      	ittt	gt
    8df6:	ebd4 050c 	rsbsgt	r5, r4, ip
    8dfa:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    8dfe:	bd70      	popgt	{r4, r5, r6, pc}
    8e00:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
    8e04:	f04f 0e00 	mov.w	lr, #0
    8e08:	3c01      	subs	r4, #1
    8e0a:	e690      	b.n	8b2e <__aeabi_dmul+0xde>
    8e0c:	ea45 0e06 	orr.w	lr, r5, r6
    8e10:	e68d      	b.n	8b2e <__aeabi_dmul+0xde>
    8e12:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    8e16:	ea94 0f0c 	teq	r4, ip
    8e1a:	bf08      	it	eq
    8e1c:	ea95 0f0c 	teqeq	r5, ip
    8e20:	f43f af3b 	beq.w	8c9a <__aeabi_dmul+0x24a>
    8e24:	ea94 0f0c 	teq	r4, ip
    8e28:	d10a      	bne.n	8e40 <__aeabi_ddiv+0x19c>
    8e2a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    8e2e:	f47f af34 	bne.w	8c9a <__aeabi_dmul+0x24a>
    8e32:	ea95 0f0c 	teq	r5, ip
    8e36:	f47f af25 	bne.w	8c84 <__aeabi_dmul+0x234>
    8e3a:	4610      	mov	r0, r2
    8e3c:	4619      	mov	r1, r3
    8e3e:	e72c      	b.n	8c9a <__aeabi_dmul+0x24a>
    8e40:	ea95 0f0c 	teq	r5, ip
    8e44:	d106      	bne.n	8e54 <__aeabi_ddiv+0x1b0>
    8e46:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    8e4a:	f43f aefd 	beq.w	8c48 <__aeabi_dmul+0x1f8>
    8e4e:	4610      	mov	r0, r2
    8e50:	4619      	mov	r1, r3
    8e52:	e722      	b.n	8c9a <__aeabi_dmul+0x24a>
    8e54:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    8e58:	bf18      	it	ne
    8e5a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    8e5e:	f47f aec5 	bne.w	8bec <__aeabi_dmul+0x19c>
    8e62:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
    8e66:	f47f af0d 	bne.w	8c84 <__aeabi_dmul+0x234>
    8e6a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
    8e6e:	f47f aeeb 	bne.w	8c48 <__aeabi_dmul+0x1f8>
    8e72:	e712      	b.n	8c9a <__aeabi_dmul+0x24a>

00008e74 <__aeabi_d2iz>:
    8e74:	ea4f 0241 	mov.w	r2, r1, lsl #1
    8e78:	f512 1200 	adds.w	r2, r2, #2097152	@ 0x200000
    8e7c:	d215      	bcs.n	8eaa <__aeabi_d2iz+0x36>
    8e7e:	d511      	bpl.n	8ea4 <__aeabi_d2iz+0x30>
    8e80:	f46f 7378 	mvn.w	r3, #992	@ 0x3e0
    8e84:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
    8e88:	d912      	bls.n	8eb0 <__aeabi_d2iz+0x3c>
    8e8a:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    8e8e:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
    8e92:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
    8e96:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
    8e9a:	fa23 f002 	lsr.w	r0, r3, r2
    8e9e:	bf18      	it	ne
    8ea0:	4240      	negne	r0, r0
    8ea2:	4770      	bx	lr
    8ea4:	f04f 0000 	mov.w	r0, #0
    8ea8:	4770      	bx	lr
    8eaa:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
    8eae:	d105      	bne.n	8ebc <__aeabi_d2iz+0x48>
    8eb0:	f011 4000 	ands.w	r0, r1, #2147483648	@ 0x80000000
    8eb4:	bf08      	it	eq
    8eb6:	f06f 4000 	mvneq.w	r0, #2147483648	@ 0x80000000
    8eba:	4770      	bx	lr
    8ebc:	f04f 0000 	mov.w	r0, #0
    8ec0:	4770      	bx	lr
    8ec2:	bf00      	nop

00008ec4 <__aeabi_uldivmod>:
    8ec4:	b953      	cbnz	r3, 8edc <__aeabi_uldivmod+0x18>
    8ec6:	b94a      	cbnz	r2, 8edc <__aeabi_uldivmod+0x18>
    8ec8:	2900      	cmp	r1, #0
    8eca:	bf08      	it	eq
    8ecc:	2800      	cmpeq	r0, #0
    8ece:	bf1c      	itt	ne
    8ed0:	f04f 31ff 	movne.w	r1, #4294967295
    8ed4:	f04f 30ff 	movne.w	r0, #4294967295
    8ed8:	f000 b986 	b.w	91e8 <__aeabi_idiv0>
    8edc:	f1ad 0c08 	sub.w	ip, sp, #8
    8ee0:	e96d ce04 	strd	ip, lr, [sp, #-16]!
    8ee4:	f000 f806 	bl	8ef4 <__udivmoddi4>
    8ee8:	f8dd e004 	ldr.w	lr, [sp, #4]
    8eec:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    8ef0:	b004      	add	sp, #16
    8ef2:	4770      	bx	lr

00008ef4 <__udivmoddi4>:
    8ef4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    8ef8:	9d08      	ldr	r5, [sp, #32]
    8efa:	460f      	mov	r7, r1
    8efc:	4604      	mov	r4, r0
    8efe:	468e      	mov	lr, r1
    8f00:	2b00      	cmp	r3, #0
    8f02:	d148      	bne.n	8f96 <__udivmoddi4+0xa2>
    8f04:	428a      	cmp	r2, r1
    8f06:	4616      	mov	r6, r2
    8f08:	d961      	bls.n	8fce <__udivmoddi4+0xda>
    8f0a:	fab2 f282 	clz	r2, r2
    8f0e:	b14a      	cbz	r2, 8f24 <__udivmoddi4+0x30>
    8f10:	f1c2 0320 	rsb	r3, r2, #32
    8f14:	fa01 fe02 	lsl.w	lr, r1, r2
    8f18:	fa20 f303 	lsr.w	r3, r0, r3
    8f1c:	4096      	lsls	r6, r2
    8f1e:	ea43 0e0e 	orr.w	lr, r3, lr
    8f22:	4094      	lsls	r4, r2
    8f24:	ea4f 4c16 	mov.w	ip, r6, lsr #16
    8f28:	fbbe f1fc 	udiv	r1, lr, ip
    8f2c:	b2b7      	uxth	r7, r6
    8f2e:	fb0c ee11 	mls	lr, ip, r1, lr
    8f32:	fb01 f007 	mul.w	r0, r1, r7
    8f36:	0c23      	lsrs	r3, r4, #16
    8f38:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
    8f3c:	4298      	cmp	r0, r3
    8f3e:	d909      	bls.n	8f54 <__udivmoddi4+0x60>
    8f40:	18f3      	adds	r3, r6, r3
    8f42:	f101 3eff 	add.w	lr, r1, #4294967295
    8f46:	f080 80ed 	bcs.w	9124 <__udivmoddi4+0x230>
    8f4a:	4298      	cmp	r0, r3
    8f4c:	f240 80ea 	bls.w	9124 <__udivmoddi4+0x230>
    8f50:	3902      	subs	r1, #2
    8f52:	4433      	add	r3, r6
    8f54:	1a1b      	subs	r3, r3, r0
    8f56:	fbb3 f0fc 	udiv	r0, r3, ip
    8f5a:	fb0c 3310 	mls	r3, ip, r0, r3
    8f5e:	fb00 f707 	mul.w	r7, r0, r7
    8f62:	b2a4      	uxth	r4, r4
    8f64:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
    8f68:	42a7      	cmp	r7, r4
    8f6a:	d909      	bls.n	8f80 <__udivmoddi4+0x8c>
    8f6c:	1934      	adds	r4, r6, r4
    8f6e:	f100 33ff 	add.w	r3, r0, #4294967295
    8f72:	f080 80d9 	bcs.w	9128 <__udivmoddi4+0x234>
    8f76:	42a7      	cmp	r7, r4
    8f78:	f240 80d6 	bls.w	9128 <__udivmoddi4+0x234>
    8f7c:	4434      	add	r4, r6
    8f7e:	3802      	subs	r0, #2
    8f80:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
    8f84:	2100      	movs	r1, #0
    8f86:	1be4      	subs	r4, r4, r7
    8f88:	b11d      	cbz	r5, 8f92 <__udivmoddi4+0x9e>
    8f8a:	2300      	movs	r3, #0
    8f8c:	40d4      	lsrs	r4, r2
    8f8e:	e9c5 4300 	strd	r4, r3, [r5]
    8f92:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    8f96:	428b      	cmp	r3, r1
    8f98:	d906      	bls.n	8fa8 <__udivmoddi4+0xb4>
    8f9a:	b10d      	cbz	r5, 8fa0 <__udivmoddi4+0xac>
    8f9c:	e9c5 0100 	strd	r0, r1, [r5]
    8fa0:	2100      	movs	r1, #0
    8fa2:	4608      	mov	r0, r1
    8fa4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    8fa8:	fab3 f183 	clz	r1, r3
    8fac:	2900      	cmp	r1, #0
    8fae:	d147      	bne.n	9040 <__udivmoddi4+0x14c>
    8fb0:	42bb      	cmp	r3, r7
    8fb2:	d302      	bcc.n	8fba <__udivmoddi4+0xc6>
    8fb4:	4282      	cmp	r2, r0
    8fb6:	f200 8104 	bhi.w	91c2 <__udivmoddi4+0x2ce>
    8fba:	1a84      	subs	r4, r0, r2
    8fbc:	eb67 0203 	sbc.w	r2, r7, r3
    8fc0:	2001      	movs	r0, #1
    8fc2:	4696      	mov	lr, r2
    8fc4:	2d00      	cmp	r5, #0
    8fc6:	d0e4      	beq.n	8f92 <__udivmoddi4+0x9e>
    8fc8:	e9c5 4e00 	strd	r4, lr, [r5]
    8fcc:	e7e1      	b.n	8f92 <__udivmoddi4+0x9e>
    8fce:	2a00      	cmp	r2, #0
    8fd0:	f000 8090 	beq.w	90f4 <__udivmoddi4+0x200>
    8fd4:	fab2 f282 	clz	r2, r2
    8fd8:	2a00      	cmp	r2, #0
    8fda:	f040 80a7 	bne.w	912c <__udivmoddi4+0x238>
    8fde:	1b88      	subs	r0, r1, r6
    8fe0:	2101      	movs	r1, #1
    8fe2:	0c37      	lsrs	r7, r6, #16
    8fe4:	fa1f fe86 	uxth.w	lr, r6
    8fe8:	fbb0 fcf7 	udiv	ip, r0, r7
    8fec:	fb07 001c 	mls	r0, r7, ip, r0
    8ff0:	0c23      	lsrs	r3, r4, #16
    8ff2:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
    8ff6:	fb0e f00c 	mul.w	r0, lr, ip
    8ffa:	4298      	cmp	r0, r3
    8ffc:	d907      	bls.n	900e <__udivmoddi4+0x11a>
    8ffe:	18f3      	adds	r3, r6, r3
    9000:	f10c 38ff 	add.w	r8, ip, #4294967295
    9004:	d202      	bcs.n	900c <__udivmoddi4+0x118>
    9006:	4298      	cmp	r0, r3
    9008:	f200 80e0 	bhi.w	91cc <__udivmoddi4+0x2d8>
    900c:	46c4      	mov	ip, r8
    900e:	1a1b      	subs	r3, r3, r0
    9010:	fbb3 f0f7 	udiv	r0, r3, r7
    9014:	fb07 3310 	mls	r3, r7, r0, r3
    9018:	fb0e fe00 	mul.w	lr, lr, r0
    901c:	b2a4      	uxth	r4, r4
    901e:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
    9022:	45a6      	cmp	lr, r4
    9024:	d907      	bls.n	9036 <__udivmoddi4+0x142>
    9026:	1934      	adds	r4, r6, r4
    9028:	f100 33ff 	add.w	r3, r0, #4294967295
    902c:	d202      	bcs.n	9034 <__udivmoddi4+0x140>
    902e:	45a6      	cmp	lr, r4
    9030:	f200 80c9 	bhi.w	91c6 <__udivmoddi4+0x2d2>
    9034:	4618      	mov	r0, r3
    9036:	eba4 040e 	sub.w	r4, r4, lr
    903a:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
    903e:	e7a3      	b.n	8f88 <__udivmoddi4+0x94>
    9040:	f1c1 0620 	rsb	r6, r1, #32
    9044:	408b      	lsls	r3, r1
    9046:	fa22 fc06 	lsr.w	ip, r2, r6
    904a:	ea4c 0c03 	orr.w	ip, ip, r3
    904e:	fa27 fa06 	lsr.w	sl, r7, r6
    9052:	ea4f 491c 	mov.w	r9, ip, lsr #16
    9056:	fbba f8f9 	udiv	r8, sl, r9
    905a:	408f      	lsls	r7, r1
    905c:	fa20 f306 	lsr.w	r3, r0, r6
    9060:	fb09 aa18 	mls	sl, r9, r8, sl
    9064:	fa1f fe8c 	uxth.w	lr, ip
    9068:	433b      	orrs	r3, r7
    906a:	fa00 f701 	lsl.w	r7, r0, r1
    906e:	fb08 f00e 	mul.w	r0, r8, lr
    9072:	0c1c      	lsrs	r4, r3, #16
    9074:	ea44 440a 	orr.w	r4, r4, sl, lsl #16
    9078:	42a0      	cmp	r0, r4
    907a:	fa02 f201 	lsl.w	r2, r2, r1
    907e:	d90b      	bls.n	9098 <__udivmoddi4+0x1a4>
    9080:	eb1c 0404 	adds.w	r4, ip, r4
    9084:	f108 3aff 	add.w	sl, r8, #4294967295
    9088:	f080 8099 	bcs.w	91be <__udivmoddi4+0x2ca>
    908c:	42a0      	cmp	r0, r4
    908e:	f240 8096 	bls.w	91be <__udivmoddi4+0x2ca>
    9092:	f1a8 0802 	sub.w	r8, r8, #2
    9096:	4464      	add	r4, ip
    9098:	1a24      	subs	r4, r4, r0
    909a:	b298      	uxth	r0, r3
    909c:	fbb4 f3f9 	udiv	r3, r4, r9
    90a0:	fb09 4413 	mls	r4, r9, r3, r4
    90a4:	fb03 fe0e 	mul.w	lr, r3, lr
    90a8:	ea40 4404 	orr.w	r4, r0, r4, lsl #16
    90ac:	45a6      	cmp	lr, r4
    90ae:	d908      	bls.n	90c2 <__udivmoddi4+0x1ce>
    90b0:	eb1c 0404 	adds.w	r4, ip, r4
    90b4:	f103 30ff 	add.w	r0, r3, #4294967295
    90b8:	d27f      	bcs.n	91ba <__udivmoddi4+0x2c6>
    90ba:	45a6      	cmp	lr, r4
    90bc:	d97d      	bls.n	91ba <__udivmoddi4+0x2c6>
    90be:	3b02      	subs	r3, #2
    90c0:	4464      	add	r4, ip
    90c2:	ea43 4008 	orr.w	r0, r3, r8, lsl #16
    90c6:	eba4 040e 	sub.w	r4, r4, lr
    90ca:	fba0 8e02 	umull	r8, lr, r0, r2
    90ce:	4574      	cmp	r4, lr
    90d0:	4643      	mov	r3, r8
    90d2:	46f1      	mov	r9, lr
    90d4:	d361      	bcc.n	919a <__udivmoddi4+0x2a6>
    90d6:	d05e      	beq.n	9196 <__udivmoddi4+0x2a2>
    90d8:	b155      	cbz	r5, 90f0 <__udivmoddi4+0x1fc>
    90da:	1afa      	subs	r2, r7, r3
    90dc:	eb64 0409 	sbc.w	r4, r4, r9
    90e0:	fa04 f606 	lsl.w	r6, r4, r6
    90e4:	fa22 f301 	lsr.w	r3, r2, r1
    90e8:	431e      	orrs	r6, r3
    90ea:	40cc      	lsrs	r4, r1
    90ec:	e9c5 6400 	strd	r6, r4, [r5]
    90f0:	2100      	movs	r1, #0
    90f2:	e74e      	b.n	8f92 <__udivmoddi4+0x9e>
    90f4:	0843      	lsrs	r3, r0, #1
    90f6:	ea4f 0c51 	mov.w	ip, r1, lsr #1
    90fa:	ea43 71c1 	orr.w	r1, r3, r1, lsl #31
    90fe:	0c0a      	lsrs	r2, r1, #16
    9100:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
    9104:	b28b      	uxth	r3, r1
    9106:	07c4      	lsls	r4, r0, #31
    9108:	fbb2 f1f6 	udiv	r1, r2, r6
    910c:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    9110:	fbbc fcf6 	udiv	ip, ip, r6
    9114:	46b6      	mov	lr, r6
    9116:	4630      	mov	r0, r6
    9118:	4637      	mov	r7, r6
    911a:	221f      	movs	r2, #31
    911c:	1a18      	subs	r0, r3, r0
    911e:	ea41 410c 	orr.w	r1, r1, ip, lsl #16
    9122:	e761      	b.n	8fe8 <__udivmoddi4+0xf4>
    9124:	4671      	mov	r1, lr
    9126:	e715      	b.n	8f54 <__udivmoddi4+0x60>
    9128:	4618      	mov	r0, r3
    912a:	e729      	b.n	8f80 <__udivmoddi4+0x8c>
    912c:	f1c2 0320 	rsb	r3, r2, #32
    9130:	fa21 f003 	lsr.w	r0, r1, r3
    9134:	4096      	lsls	r6, r2
    9136:	fa24 f303 	lsr.w	r3, r4, r3
    913a:	4097      	lsls	r7, r2
    913c:	433b      	orrs	r3, r7
    913e:	0c37      	lsrs	r7, r6, #16
    9140:	fbb0 f8f7 	udiv	r8, r0, r7
    9144:	fb07 0018 	mls	r0, r7, r8, r0
    9148:	fa1f fe86 	uxth.w	lr, r6
    914c:	0c19      	lsrs	r1, r3, #16
    914e:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
    9152:	fb08 f00e 	mul.w	r0, r8, lr
    9156:	4288      	cmp	r0, r1
    9158:	fa04 f402 	lsl.w	r4, r4, r2
    915c:	d93a      	bls.n	91d4 <__udivmoddi4+0x2e0>
    915e:	1871      	adds	r1, r6, r1
    9160:	f108 3cff 	add.w	ip, r8, #4294967295
    9164:	d201      	bcs.n	916a <__udivmoddi4+0x276>
    9166:	4288      	cmp	r0, r1
    9168:	d81e      	bhi.n	91a8 <__udivmoddi4+0x2b4>
    916a:	1a09      	subs	r1, r1, r0
    916c:	fbb1 f8f7 	udiv	r8, r1, r7
    9170:	fb08 f00e 	mul.w	r0, r8, lr
    9174:	fb07 1118 	mls	r1, r7, r8, r1
    9178:	b29b      	uxth	r3, r3
    917a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    917e:	4283      	cmp	r3, r0
    9180:	d22f      	bcs.n	91e2 <__udivmoddi4+0x2ee>
    9182:	18f3      	adds	r3, r6, r3
    9184:	f108 31ff 	add.w	r1, r8, #4294967295
    9188:	d2c8      	bcs.n	911c <__udivmoddi4+0x228>
    918a:	4283      	cmp	r3, r0
    918c:	d2c6      	bcs.n	911c <__udivmoddi4+0x228>
    918e:	f1a8 0102 	sub.w	r1, r8, #2
    9192:	4433      	add	r3, r6
    9194:	e7c2      	b.n	911c <__udivmoddi4+0x228>
    9196:	4547      	cmp	r7, r8
    9198:	d29e      	bcs.n	90d8 <__udivmoddi4+0x1e4>
    919a:	ebb8 0302 	subs.w	r3, r8, r2
    919e:	eb6e 0e0c 	sbc.w	lr, lr, ip
    91a2:	3801      	subs	r0, #1
    91a4:	46f1      	mov	r9, lr
    91a6:	e797      	b.n	90d8 <__udivmoddi4+0x1e4>
    91a8:	1a30      	subs	r0, r6, r0
    91aa:	4401      	add	r1, r0
    91ac:	f1a8 0c02 	sub.w	ip, r8, #2
    91b0:	fbb1 f8f7 	udiv	r8, r1, r7
    91b4:	fb08 f00e 	mul.w	r0, r8, lr
    91b8:	e7dc      	b.n	9174 <__udivmoddi4+0x280>
    91ba:	4603      	mov	r3, r0
    91bc:	e781      	b.n	90c2 <__udivmoddi4+0x1ce>
    91be:	46d0      	mov	r8, sl
    91c0:	e76a      	b.n	9098 <__udivmoddi4+0x1a4>
    91c2:	4608      	mov	r0, r1
    91c4:	e6fe      	b.n	8fc4 <__udivmoddi4+0xd0>
    91c6:	4434      	add	r4, r6
    91c8:	3802      	subs	r0, #2
    91ca:	e734      	b.n	9036 <__udivmoddi4+0x142>
    91cc:	f1ac 0c02 	sub.w	ip, ip, #2
    91d0:	4433      	add	r3, r6
    91d2:	e71c      	b.n	900e <__udivmoddi4+0x11a>
    91d4:	1a09      	subs	r1, r1, r0
    91d6:	46c4      	mov	ip, r8
    91d8:	fbb1 f8f7 	udiv	r8, r1, r7
    91dc:	fb08 f00e 	mul.w	r0, r8, lr
    91e0:	e7c8      	b.n	9174 <__udivmoddi4+0x280>
    91e2:	4641      	mov	r1, r8
    91e4:	e79a      	b.n	911c <__udivmoddi4+0x228>
    91e6:	bf00      	nop

000091e8 <__aeabi_idiv0>:
    91e8:	4770      	bx	lr
    91ea:	bf00      	nop

000091ec <operator delete(void*, unsigned int)>:
    91ec:	f000 b800 	b.w	91f0 <operator delete(void*)>

000091f0 <operator delete(void*)>:
    91f0:	f7fe b9b6 	b.w	7560 <free>
    91f4:	70616548 	.word	0x70616548
    91f8:	646e6120 	.word	0x646e6120
    91fc:	61747320 	.word	0x61747320
    9200:	63206b63 	.word	0x63206b63
    9204:	696c6c6f 	.word	0x696c6c6f
    9208:	6e6f6973 	.word	0x6e6f6973
    920c:	0000000a 	.word	0x0000000a
    9210:	2074754f 	.word	0x2074754f
    9214:	6820666f 	.word	0x6820666f
    9218:	20706165 	.word	0x20706165
    921c:	6f6d656d 	.word	0x6f6d656d
    9220:	000a7972 	.word	0x000a7972

00009224 <table.0>:
    9224:	00000000 04c11db7 09823b6e 0d4326d9     ........n;...&C.
    9234:	130476dc 17c56b6b 1a864db2 1e475005     .v..kk...M...PG.
    9244:	2608edb8 22c9f00f 2f8ad6d6 2b4bcb61     ...&...".../a.K+
    9254:	350c9b64 31cd86d3 3c8ea00a 384fbdbd     d..5...1...<..O8
    9264:	4c11db70 48d0c6c7 4593e01e 4152fda9     p..L...H...E..RA
    9274:	5f15adac 5bd4b01b 569796c2 52568b75     ..._...[...Vu.VR
    9284:	6a1936c8 6ed82b7f 639b0da6 675a1011     .6.j.+.n...c..Zg
    9294:	791d4014 7ddc5da3 709f7b7a 745e66cd     .@.y.].}z{.p.f^t
    92a4:	9823b6e0 9ce2ab57 91a18d8e 95609039     ..#.W.......9.`.
    92b4:	8b27c03c 8fe6dd8b 82a5fb52 8664e6e5     <.'.....R.....d.
    92c4:	be2b5b58 baea46ef b7a96036 b3687d81     X[+..F..6`...}h.
    92d4:	ad2f2d84 a9ee3033 a4ad16ea a06c0b5d     .-/.30......].l.
    92e4:	d4326d90 d0f37027 ddb056fe d9714b49     .m2.'p...V..IKq.
    92f4:	c7361b4c c3f706fb ceb42022 ca753d95     L.6....." ...=u.
    9304:	f23a8028 f6fb9d9f fbb8bb46 ff79a6f1     (.:.....F.....y.
    9314:	e13ef6f4 e5ffeb43 e8bccd9a ec7dd02d     ..>.C.......-.}.
    9324:	34867077 30476dc0 3d044b19 39c556ae     wp.4.mG0.K.=.V.9
    9334:	278206ab 23431b1c 2e003dc5 2ac12072     ...'..C#.=..r .*
    9344:	128e9dcf 164f8078 1b0ca6a1 1fcdbb16     ....x.O.........
    9354:	018aeb13 054bf6a4 0808d07d 0cc9cdca     ......K.}.......
    9364:	7897ab07 7c56b6b0 71159069 75d48dde     ...x..V|i..q...u
    9374:	6b93dddb 6f52c06c 6211e6b5 66d0fb02     ...kl.Ro...b...f
    9384:	5e9f46bf 5a5e5b08 571d7dd1 53dc6066     .F.^.[^Z.}.Wf`.S
    9394:	4d9b3063 495a2dd4 44190b0d 40d816ba     c0.M.-ZI...D...@
    93a4:	aca5c697 a864db20 a527fdf9 a1e6e04e     .... .d...'.N...
    93b4:	bfa1b04b bb60adfc b6238b25 b2e29692     K.....`.%.#.....
    93c4:	8aad2b2f 8e6c3698 832f1041 87ee0df6     /+...6l.A./.....
    93d4:	99a95df3 9d684044 902b669d 94ea7b2a     .]..D@h..f+.*{..
    93e4:	e0b41de7 e4750050 e9362689 edf73b3e     ....P.u..&6.>;..
    93f4:	f3b06b3b f771768c fa325055 fef34de2     ;k...vq.UP2..M..
    9404:	c6bcf05f c27dede8 cf3ecb31 cbffd686     _.....}.1.>.....
    9414:	d5b88683 d1799b34 dc3abded d8fba05a     ....4.y...:.Z...
    9424:	690ce0ee 6dcdfd59 608edb80 644fc637     ...iY..m...`7.Od
    9434:	7a089632 7ec98b85 738aad5c 774bb0eb     2..z...~\..s..Kw
    9444:	4f040d56 4bc510e1 46863638 42472b8f     V..O...K86.F.+GB
    9454:	5c007b8a 58c1663d 558240e4 51435d53     .{.\=f.X.@.US]CQ
    9464:	251d3b9e 21dc2629 2c9f00f0 285e1d47     .;.%)&.!...,G.^(
    9474:	36194d42 32d850f5 3f9b762c 3b5a6b9b     BM.6.P.2,v.?.kZ;
    9484:	0315d626 07d4cb91 0a97ed48 0e56f0ff     &.......H.....V.
    9494:	1011a0fa 14d0bd4d 19939b94 1d528623     ....M.......#.R.
    94a4:	f12f560e f5ee4bb9 f8ad6d60 fc6c70d7     .V/..K..`m...pl.
    94b4:	e22b20d2 e6ea3d65 eba91bbc ef68060b     . +.e=........h.
    94c4:	d727bbb6 d3e6a601 dea580d8 da649d6f     ..'.........o.d.
    94d4:	c423cd6a c0e2d0dd cda1f604 c960ebb3     j.#...........`.
    94e4:	bd3e8d7e b9ff90c9 b4bcb610 b07daba7     ~.>...........}.
    94f4:	ae3afba2 aafbe615 a7b8c0cc a379dd7b     ..:.........{.y.
    9504:	9b3660c6 9ff77d71 92b45ba8 9675461f     .`6.q}...[...Fu.
    9514:	8832161a 8cf30bad 81b02d74 857130c3     ..2.....t-...0q.
    9524:	5d8a9099 594b8d2e 5408abf7 50c9b640     ...]..KY...T@..P
    9534:	4e8ee645 4a4ffbf2 470cdd2b 43cdc09c     E..N..OJ+..G...C
    9544:	7b827d21 7f436096 7200464f 76c15bf8     !}.{.`C.OF.r.[.v
    9554:	68860bfd 6c47164a 61043093 65c52d24     ...hJ.Gl.0.a$-.e
    9564:	119b4be9 155a565e 18197087 1cd86d30     .K..^VZ..p..0m..
    9574:	029f3d35 065e2082 0b1d065b 0fdc1bec     5=... ^.[.......
    9584:	3793a651 3352bbe6 3e119d3f 3ad08088     Q..7..R3?..>...:
    9594:	2497d08d 2056cd3a 2d15ebe3 29d4f654     ...$:.V ...-T..)
    95a4:	c5a92679 c1683bce cc2b1d17 c8ea00a0     y&...;h...+.....
    95b4:	d6ad50a5 d26c4d12 df2f6bcb dbee767c     .P...Ml..k/.|v..
    95c4:	e3a1cbc1 e760d676 ea23f0af eee2ed18     ....v.`...#.....
    95d4:	f0a5bd1d f464a0aa f9278673 fde69bc4     ......d.s.'.....
    95e4:	89b8fd09 8d79e0be 803ac667 84fbdbd0     ......y.g.:.....
    95f4:	9abc8bd5 9e7d9662 933eb0bb 97ffad0c     ....b.}...>.....
    9604:	afb010b1 ab710d06 a6322bdf a2f33668     ......q..+2.h6..
    9614:	bcb4666d b8757bda b5365d03 b1f740b4     mf...{u..]6..@..

00009624 <spaces>:
    9624:	20202020 20202020 20202020 20202020                     
    9634:	00000000                                ....

00009638 <zeroes>:
    9638:	30303030 30303030 30303030 30303030     0000000000000000
    9648:	00000000 006e616e 004e414e 00666e69     ....nan.NAN.inf.
    9658:	00464e49 0000002d 0000002b 00000020     INF.-...+... ...
    9668:	00000000 0000002e 6c756e28 0000296c     ........(null)..
    9678:	7a6a6c68 00004c74                       hljztL..

00009680 <digits.2>:
    9680:	33323130 37363534 42413938 46454443     0123456789ABCDEF
    9690:	4a494847 4e4d4c4b 5251504f 56555453     GHIJKLMNOPQRSTUV
    96a0:	5a595857 00000000                       WXYZ....

000096a8 <fchar.1>:
    96a8:	232d2b20 005e2130                        +-#0!^.

000096b0 <fbit.0>:
    96b0:	00000001 00000002 00000004 00000008     ................
    96c0:	00000010 00000020 00000040 00000000     .... ...@.......
    96d0:	4d210a0a 726f6a61 73617243 67655368     ..!MajorCrashSeg
    96e0:	6c756146 6e614874 72656c64 0a212928     FaultHandler()!.
    96f0:	00000000 3d203052 0a782520 00000000     ....R0 = %x.....
    9700:	3d203152 0a782520 00000000 3d203252     R1 = %x.....R2 =
    9710:	0a782520 00000000 3d203352 0a782520      %x.....R3 = %x.
    9720:	00000000 20323152 7825203d 0000000a     ....R12 = %x....
    9730:	5b20524c 5d343152 25203d20 73202078     LR [R14] = %x  s
    9740:	6f726275 6e697475 61632065 72206c6c     ubroutine call r
    9750:	72757465 6461206e 73657264 00000a73     eturn address...
    9760:	5b204350 5d353152 25203d20 70202078     PC [R15] = %x  p
    9770:	72676f72 63206d61 746e756f 000a7265     rogram counter..
    9780:	20525350 7825203d 0000000a 52414642     PSR = %x....BFAR
    9790:	25203d20 00000a78 52534643 25203d20      = %x...CFSR = %
    97a0:	00000a78 52534648 25203d20 00000a78     x...HFSR = %x...
    97b0:	52534644 25203d20 00000a78 52534641     DFSR = %x...AFSR
    97c0:	25203d20 00000a78 210a0a0a 46737542      = %x......!BusF
    97d0:	746c7561 00000a21 5b204350 5d353152     ault!...PC [R15]
    97e0:	25203d20 00000a78 5b20524c 5d343152      = %x...LR [R14]
    97f0:	25203d20 00000a78 210a0a0a 67617355      = %x......!Usag
    9800:	75614665 0a21746c 00000000 72655622     eFault!....."Ver
    9810:	6e6f6973 53203a22 73776f68 72616820     sion": Shows har
    9820:	72617764 6e612065 69662064 61776d72     dware and firmwa
    9830:	76206572 69737265 69206e6f 2e6f666e     re version info.
    9840:	00000000 53524556 004e4f49 64616552     ....VERSION.Read
    9850:	61677046 64613c20 73657264 00003e73     Fpga <address>..
    9860:	44414552 41475046 00000000 74697257     READFPGA....Writ
    9870:	67704665 613c2061 65726464 2c3e7373     eFpga <address>,
    9880:	6c61763c 003e6575 54495257 47504645     <value>.WRITEFPG
    9890:	00000041 61652852 67704664 3c202961     A...R(eadFpga) <
    98a0:	72646461 3e737365 00000000 00000052     address>....R...
    98b0:	69722857 70466574 20296167 6464613c     W(riteFpga) <add
    98c0:	73736572 763c2c3e 65756c61 0000003e     ress>,<value>...
    98d0:	00000057 444d4422 20736361 2c3e413c     W..."DMDacs <A>,
    98e0:	2c3e423c 223e433c 6553203a 712f7374     <B>,<C>": Sets/q
    98f0:	69726575 74207365 44206568 2f44204d     ueries the DM D/
    9900:	20732741 78656828 63656461 6c616d69     A's (hexadecimal
    9910:	62736c20 696e7520 2e297374 00000000      lsb units).....
    9920:	41444d44 00005343 44284422 6361444d     DMDACS.."D(DMDac
    9930:	3c202973 3c2c3e41 3c2c3e42 3a223e43     s) <A>,<B>,<C>":
    9940:	74655320 75712f73 65697265 68742073      Sets/queries th
    9950:	4d442065 412f4420 28207327 61786568     e DM D/A's (hexa
    9960:	69636564 206c616d 2062736c 74696e75     decimal lsb unit
    9970:	002e2973 00000044 414d4422 20736364     s)..D..."DMAdcs 
    9980:	2c3e413c 2c3e423c 223e433c 6553203a     <A>,<B>,<C>": Se
    9990:	712f7374 69726575 74207365 44206568     ts/queries the D
    99a0:	2f41204d 2e732744 00000000 44414d44     M A/D's.....DMAD
    99b0:	00005343 44284122 6364414d 3c202973     CS.."A(DMAdcs) <
    99c0:	3c2c3e41 3c2c3e42 3a223e43 74655320     A>,<B>,<C>": Set
    99d0:	75712f73 65697265 68742073 4d442065     s/queries the DM
    99e0:	442f4120 002e7327 00000041 53494222      A/D's..A..."BIS
    99f0:	203a2254 736e7552 73206120 2d666c65     T": Runs a self-
    9a00:	74736574 6f6c202c 76207367 65756c61     test, logs value
    9a10:	6f742073 72657420 616e696d 00002e6c     s to terminal...
    9a20:	54534942 00000000 72615522 203a2274     BIST...."Uart": 
    9a30:	64697754 20656c64 20656874 74726175     Twiddle the uart
    9a40:	0000002e 54524155 00000000 61285522     ....UART...."U(a
    9a50:	22297472 7754203a 6c646469 68742065     rt)": Twiddle th
    9a60:	61752065 002e7472 00000055 75614222     e uart..U..."Bau
    9a70:	76694464 72656469 203a2273 2c312c30     dDividers": 0,1,
    9a80:	53203a32 74207465 64206568 64697669     2: Set the divid
    9a90:	74207265 6863206f 65676e61 65687420     er to change the
    9aa0:	75616220 74617264 6f662065 61652072      baudrate for ea
    9ab0:	70206863 2e74726f 00002e2e 44554142     ch port.....BAUD
    9ac0:	49564944 53524544 00000000 69725022     DIVIDERS...."Pri
    9ad0:	7542746e 72656666 203a2273 706d7544     ntBuffers": Dump
    9ae0:	72756320 746e6572 6e6f6320 746e6574      current content
    9af0:	666f2073 72617020 73726573 726f6620     s of parsers for
    9b00:	62656420 2e2e6775 0000002e 4e495250      debug......PRIN
    9b10:	46554254 53524546 00000000 6e6f4d22     TBUFFERS...."Mon
    9b20:	726f7469 69726553 3c206c61 207c2030     itorSerial <0 | 
    9b30:	207c2031 3c203e32 207c2059 3a223e4e     1 | 2> <Y | N>":
    9b40:	6f685320 69682f77 69206564 6d6f636e      Show/hide incom
    9b50:	20676e69 69726573 62206c61 73657479     ing serial bytes
    9b60:	0000002e 494e4f4d 53524f54 41495245     ....MONITORSERIA
    9b70:	0000004c 4d4d4422 69707061 2273676e     L..."DMMappings"
    9b80:	6950203a 206c6578 65646e69 42202c78     : Pixel index, B
    9b90:	6472616f 646e6920 202c7865 20412f44     oard index, D/A 
    9ba0:	65646e69 44202c78 6320412f 6e6e6168     index, D/A chann
    9bb0:	6e206c65 65626d75 53203a72 61207465     el number: Set a
    9bc0:	70616d20 676e6970 00000000 414d4d44      mapping....DMMA
    9bd0:	4e495050 00005347 534d4422 74726f68     PPINGS.."DMShort
    9be0:	65786950 3a22736c 61745320 69507472     Pixels": StartPi
    9bf0:	2c6c6578 78695020 50202c30 2c317869     xel, Pix0, Pix1,
    9c00:	2e2e2e20 78695020 53203a4e 20646e65      ... PixN: Send 
    9c10:	65786970 6176206c 7365756c 36312820     pixel values (16
    9c20:	29746962 00000000 48534d44 5054524f     bit)....DMSHORTP
    9c30:	4c455849 00000053 444d4422 65687469     IXELS..."DMDithe
    9c40:	203a2272 72617453 78695074 202c6c65     r": StartPixel, 
    9c50:	30786950 6950202c 202c3178 202e2e2e     Pix0, Pix1, ... 
    9c60:	4e786950 6553203a 7020646e 6c657869     PixN: Send pixel
    9c70:	74696420 20726568 756c6176 28207365      dither values (
    9c80:	74696238 00000029 49444d44 52454854     8bit)...DMDITHER
    9c90:	00000000 4c4d4422 50676e6f 6c657869     ...."DMLongPixel
    9ca0:	203a2273 72617453 78695074 202c6c65     s": StartPixel, 
    9cb0:	30786950 6950202c 202c3178 202e2e2e     Pix0, Pix1, ... 
    9cc0:	4e786950 6553203a 7020646e 6c657869     PixN: Send pixel
    9cd0:	6c617620 20736575 62323328 00297469      values (32bit).
    9ce0:	4f4c4d44 4950474e 534c4558 00000000     DMLONGPIXELS....
    9cf0:	61724743 65566870 6f697372 7961506e     CGraphVersionPay
    9d00:	64616f6c 6553203a 6c616972 3a6d754e     load: SerialNum:
    9d10:	25783020 202c586c 636f7250 6f737365      0x%lX, Processo
    9d20:	72694672 7261776d 69754265 754e646c     rFirmwareBuildNu
    9d30:	25203a6d 202c756c 41475046 6d726946     m: %lu, FPGAFirm
    9d40:	65726177 6c697542 6d754e64 6c25203a     wareBuildNum: %l
    9d50:	00000075 61724743 4d446870 7070614d     u...CGraphDMMapp
    9d60:	50676e69 6f6c7961 203a6461 746e6f43     ingPayload: Cont
    9d70:	6c6c6f72 6f427265 49647261 7865646e     rollerBoardIndex
    9d80:	6c25203a 44202c75 6e496361 3a786564     : %lu, DacIndex:
    9d90:	756c2520 6144202c 61684363 6c656e6e      %lu, DacChannel
    9da0:	6c25203a 00000075 69420a0a 7972616e     : %lu.....Binary
    9db0:	74726155 2c752528 2c632520 29752520     Uart(%u, %c, %u)
    9dc0:	003a203a 58322e25 0000003a 0000000a     : :.%.2X:.......
    9dd0:	78540a0a 616e6942 61507972 74656b63     ..TxBinaryPacket
    9de0:	554e203a 50204c4c 656b6361 6e6f4374     : NULL PacketCon
    9df0:	74786574 53282021 6c756f68 65622064     text! (Should be
    9e00:	6e694220 55797261 2a747261 6c502029      BinaryUart*) Pl
    9e10:	65736165 63657220 69706d6f 7420656c     ease recompile t
    9e20:	20736968 616e6962 2e2e7972 000d0a2e     his binary......
    9e30:	66636436 66333262 30323234 32393137     6dcfb23f42207192
    9e40:	30323065 65313862 66626431 64303333     e020b81e1dbf330d
    9e50:	30366163 61663339 00000000 65560a0a     ca6093fa......Ve
    9e60:	6f697372 53203a6e 61697265 754e206c     rsion: Serial Nu
    9e70:	7265626d 2e25203a 2c586c38 6f6c4720     mber: %.8lX, Glo
    9e80:	206c6162 69766552 6e6f6973 7325203a     bal Revision: %s
    9e90:	7562203b 20646c69 626d756e 203a7265     ; build number: 
    9ea0:	6f207525 25203a6e 66203b73 20616770     %u on: %s; fpga 
    9eb0:	6c697562 25203a64 0a2e756c 00000000     build: %lu......
    9ec0:	65560a0a 6f697372 47203a6e 61626f6c     ..Version: Globa
    9ed0:	6552206c 69736976 203a6e6f 203b7325     l Revision: %s; 
    9ee0:	6c697562 756e2064 7265626d 7525203a     build number: %u
    9ef0:	3a6e6f20 2e732520 0000000a 00587a25      on: %s.....%zX.
    9f00:	6165520a 67704664 6d6f4361 646e616d     .ReadFpgaCommand
    9f10:	0000203a 2578300a 587a322e 7830203a     : ...0x%.2zX: 0x
    9f20:	58322e25 00000020 5d75255b 00000000     %.2X ...[%u]....
    9f30:	25272820 0a292763 0000000a 20587a25      ('%c').....%zX 
    9f40:	00756c25 6972570a 70466574 6f436167     %lu..WriteFpgaCo
    9f50:	6e616d6d 6e203a64 20646565 756e2032     mmand: need 2 nu
    9f60:	6972656d 61702063 656d6172 73726574     meric parameters
    9f70:	64612820 73657264 6e612073 61762064      (address and va
    9f80:	2965756c 6f67202c 25222074 28202273     lue), got "%s" (
    9f90:	70206425 6d617261 0a2e2973 00000000     %d params)......
    9fa0:	6972570a 70466574 6f436167 6e616d6d     .WriteFpgaComman
    9fb0:	57203a64 65746f72 756c2520 206f7420     d: Wrote %lu to 
    9fc0:	00000000 2e257830 2e587a34 0000000a     ....0x%.4zX.....
    9fd0:	4d440a0a 73636144 7046203a 69206167     ..DMDacs: Fpga i
    9fe0:	7265746e 65636166 20736920 20746f6e     nterface is not 
    9ff0:	74696e69 696c6169 2164657a 656c5020     initialized! Ple
    a000:	20657361 6c6c6163 696e4920 67704674     ase call InitFpg
    a010:	69662061 21747372 0000002e 2c786c25     a first!....%lx,
    a020:	2c786c25 00786c25 4d440a0a 73636144     %lx,%lx...DMDacs
    a030:	6573203a 6f742074 6c25203a 25202c78     : set to: %lx, %
    a040:	202c786c 2e786c25 0000000a 4d440a0a     lx, %lx.......DM
    a050:	73636144 7563203a 6e657272 61762074     Dacs: current va
    a060:	3a65756c 786c2520 6c25202c 25202c78     lue: %lx, %lx, %
    a070:	0a2e786c 00000000 444d440a 3a736361     lx.......DMDacs:
    a080:	6e655320 20726f73 27442f41 30203a73      Sensor A/D's: 0
    a090:	31302578 786c6c36 7830202c 36313025     x%016llx, 0x%016
    a0a0:	2c786c6c 25783020 6c363130 203b786c     llx, 0x%016llx; 
    a0b0:	28642b25 2c297525 642b2520 29752528     %+d(%u), %+d(%u)
    a0c0:	2b25202c 75252864 25202c29 332e312b     , %+d(%u), %+1.3
    a0d0:	202c666c 2e312b25 2c666c33 312b2520     lf, %+1.3lf, %+1
    a0e0:	666c332e 0000000a 4d440a0a 73636441     .3lf......DMAdcs
    a0f0:	7046203a 69206167 7265746e 65636166     : Fpga interface
    a100:	20736920 20746f6e 74696e69 696c6169      is not initiali
    a110:	2164657a 656c5020 20657361 6c6c6163     zed! Please call
    a120:	696e4920 67704674 69662061 21747372      InitFpga first!
    a130:	0000002e 414d440a 3a736364 72756320     .....DMAdcs: cur
    a140:	746e6572 6c617620 3a736575 25783020     rent values: 0x%
    a150:	6c363130 202c786c 30257830 6c6c3631     016llx, 0x%016ll
    a160:	30202c78 31302578 786c6c36 2b25203b     x, 0x%016llx; %+
    a170:	75252864 25202c29 2528642b 202c2975     d(%u), %+d(%u), 
    a180:	28642b25 2c297525 312b2520 666c332e     %+d(%u), %+1.3lf
    a190:	2b25202c 6c332e31 25202c66 332e312b     , %+1.3lf, %+1.3
    a1a0:	000a666c 49420a0a 203a5453 7079654b     lf....BIST: Keyp
    a1b0:	73736572 29642528 7865203b 6e697469     ress(%d); exitin
    a1c0:	000a2e67 7261550a 6d6f4374 646e616d     g....UartCommand
    a1d0:	7525203a 7525202c 0000202e 706f6f6c     : %u, %u. ..loop
    a1e0:	00000000 69430a0a 656c6372 4b203a73     ......Circles: K
    a1f0:	72707965 28737365 3b296425 69786520     eypress(%d); exi
    a200:	676e6974 00000a2e 7261550a 6d6f4374     ting.....UartCom
    a210:	646e616d 6553203a 6e69646e 65722067     mand: Sending re
    a220:	6e6f7073 28206573 62207525 73657479     sponse (%u bytes
    a230:	00203a29 7261550a 6d6f4374 646e616d     ): ..UartCommand
    a240:	6f63203a 656c706d 002e6574 61420a0a     : complete....Ba
    a250:	69446475 65646976 203a7372 61677046     udDividers: Fpga
    a260:	746e6920 61667265 69206563 6f6e2073      interface is no
    a270:	6e692074 61697469 657a696c 50202164     t initialized! P
    a280:	7361656c 61632065 49206c6c 4674696e     lease call InitF
    a290:	20616770 73726966 002e2174 2c756c25     pga first!..%lu,
    a2a0:	2c756c25 2c756c25 00756c25 61420a0a     %lu,%lu,%lu...Ba
    a2b0:	69446475 65646976 203a7372 74746573     udDividers: sett
    a2c0:	20676e69 203a6f74 2c756c25 756c2520     ing to: %lu, %lu
    a2d0:	6c25202c 25202c75 0a2e756c 00000000     , %lu, %lu......
    a2e0:	61420a0a 69446475 65646976 203a7372     ..BaudDividers: 
    a2f0:	72727563 20746e65 756c6176 203a7365     current values: 
    a300:	2c756c25 756c2520 6c25202c 000a2e75     %lu, %lu, %lu...
    a310:	7561420a 76694464 72656469 50203a73     .BaudDividers: P
    a320:	3074726f 6e696620 64206c61 73697669     ort0 final divis
    a330:	206e6f69 69746172 25203a6f 2f282075     ion ratio: %u (/
    a340:	3b293631 74634120 206c6175 64756162     16); Actual baud
    a350:	65746172 2e25203a 00666c35 7561420a     rate: %.5lf..Bau
    a360:	76694464 72656469 50203a73 3174726f     dDividers: Port1
    a370:	6e696620 64206c61 73697669 206e6f69      final division 
    a380:	69746172 25203a6f 2f282075 3b293631     ratio: %u (/16);
    a390:	74634120 206c6175 64756162 65746172      Actual baudrate
    a3a0:	2e25203a 00666c35 7561420a 76694464     : %.5lf..BaudDiv
    a3b0:	72656469 50203a73 3274726f 6e696620     iders: Port2 fin
    a3c0:	64206c61 73697669 206e6f69 69746172     al division rati
    a3d0:	25203a6f 2f282075 3b293631 74634120     o: %u (/16); Act
    a3e0:	206c6175 64756162 65746172 2e25203a     ual baudrate: %.
    a3f0:	0a666c35 00000000 6f68530a 66754277     5lf......ShowBuf
    a400:	73726566 6d6d6f43 3a646e61 67704620     fersCommand: Fpg
    a410:	72615561 72615074 3a726573 00000020     aUartParser: ...
    a420:	25756c25 092c5b32 63255d20 00000000     %lu%2[,. ]%c....
    a430:	6f4d0a0a 6f74696e 72655372 436c6169     ..MonitorSerialC
    a440:	616d6d6f 203a646e 696e6f4d 69726f74     ommand: Monitori
    a450:	7020676e 2074726f 3a756c25 2e632520     ng port %lu: %c.
    a460:	0000000a 6f4d0a0a 6f74696e 72655372     ......MonitorSer
    a470:	436c6169 616d6d6f 203a646e 61766e49     ialCommand: Inva
    a480:	2064696c 74726f70 756c2520 616d203b     lid port %lu; ma
    a490:	73692078 2e322320 0000000a 6f4d0a0a     x is #2.......Mo
    a4a0:	6f74696e 72655372 436c6169 616d6d6f     nitorSerialComma
    a4b0:	203a646e 75736e49 63696666 746e6569     nd: Insufficient
    a4c0:	72617020 74656d61 20737265 3b752528      parameters (%u;
    a4d0:	6f687320 20646c75 32206562 71203b29      should be 2); q
    a4e0:	79726575 2e676e69 00002e2e 6e6f4d0a     uerying......Mon
    a4f0:	726f7469 69726553 6f436c61 6e616d6d     itorSerialComman
    a500:	4d203a64 74696e6f 6e69726f 6f702067     d: Monitoring po
    a510:	30207472 6325203a 00000a2e 6e6f4d0a     rt 0: %c.....Mon
    a520:	726f7469 69726553 6f436c61 6e616d6d     itorSerialComman
    a530:	4d203a64 74696e6f 6e69726f 6f702067     d: Monitoring po
    a540:	31207472 6325203a 00000a2e 6e6f4d0a     rt 1: %c.....Mon
    a550:	726f7469 69726553 6f436c61 6e616d6d     itorSerialComman
    a560:	4d203a64 74696e6f 6e69726f 6f702067     d: Monitoring po
    a570:	32207472 6325203a 00000a2e 6e69420a     rt 2: %c.....Bin
    a580:	44797261 70614d4d 676e6970 6d6d6f43     aryDMMappingComm
    a590:	3a646e61 74655320 70616d20 676e6970     and: Set mapping
    a5a0:	756c2520 206f7420 00000000 4d440a0a      %lu to ......DM
    a5b0:	7070614d 43676e69 616d6d6f 203a646e     MappingCommand: 
    a5c0:	70206f4e 6d617261 72657465 69672073     No parameters gi
    a5d0:	3b6e6576 6c6c6120 70616d20 676e6970     ven; all mapping
    a5e0:	6f662073 776f6c6c 0000003a 534d440a     s follow:....DMS
    a5f0:	74726f68 65786950 6f43736c 6e616d6d     hortPixelsComman
    a600:	44203a64 6f70204d 65746e69 73692072     d: DM pointer is
    a610:	4c554e20 4620214c 776d7269 20657261      NULL! Firmware 
    a620:	72726f63 65747075 00002164 0d092c20     corrupted!.. ,..
    a630:	0000000a 00756c25 534d440a 74726f68     ....%lu..DMShort
    a640:	65786950 6f43736c 6e616d6d 49203a64     PixelsCommand: I
    a650:	6c61766e 6d206469 69707061 2520676e     nvalid mapping %
    a660:	203b756c 61656c70 72206573 696e6965     lu; please reini
    a670:	6c616974 20657a69 7070616d 73676e69     tialize mappings
    a680:	00203a21 534d440a 74726f68 65786950     !: ..DMShortPixe
    a690:	6f43736c 6e616d6d 53203a64 61207465     lsCommand: Set a
    a6a0:	61757463 20726f74 20756c25 25206f74     ctuator %lu to %
    a6b0:	0000756c 4d440a0a 726f6853 78695074     lu....DMShortPix
    a6c0:	43736c65 616d6d6f 203a646e 70206f4e     elsCommand: No p
    a6d0:	6d617261 72657465 69672073 3b6e6576     arameters given;
    a6e0:	65757120 6e697972 2e2e2e67 00000000      querying.......
    a6f0:	444d440a 65687469 6d6f4372 646e616d     .DMDitherCommand
    a700:	4d44203a 696f7020 7265746e 20736920     : DM pointer is 
    a710:	4c4c554e 69462021 61776d72 63206572     NULL! Firmware c
    a720:	7572726f 64657470 00000021 444d440a     orrupted!....DMD
    a730:	65687469 6d6f4372 646e616d 6e49203a     itherCommand: In
    a740:	696c6176 616d2064 6e697070 6c252067     valid mapping %l
    a750:	70203b75 7361656c 65722065 74696e69     u; please reinit
    a760:	696c6169 6d20657a 69707061 2173676e     ialize mappings!
    a770:	0000203a 444d440a 65687469 6d6f4372     : ...DMDitherCom
    a780:	646e616d 6553203a 63612074 74617574     mand: Set actuat
    a790:	2520726f 7420756c 6c25206f 00000075     or %lu to %lu...
    a7a0:	4d440a0a 68746944 6f437265 6e616d6d     ..DMDitherComman
    a7b0:	4e203a64 6170206f 656d6172 73726574     d: No parameters
    a7c0:	76696720 203b6e65 72657571 676e6979      given; querying
    a7d0:	002e2e2e 4c4d440a 50676e6f 6c657869     .....DMLongPixel
    a7e0:	6d6f4373 646e616d 4d44203a 696f7020     sCommand: DM poi
    a7f0:	7265746e 20736920 4c4c554e 69462021     nter is NULL! Fi
    a800:	61776d72 63206572 7572726f 64657470     rmware corrupted
    a810:	00000021 4c4d440a 50676e6f 6c657869     !....DMLongPixel
    a820:	6d6f4373 646e616d 6e49203a 696c6176     sCommand: Invali
    a830:	616d2064 6e697070 6c252067 70203b75     d mapping %lu; p
    a840:	7361656c 65722065 74696e69 696c6169     lease reinitiali
    a850:	6d20657a 69707061 2173676e 0000203a     ze mappings!: ..
    a860:	4c4d440a 50676e6f 6c657869 6d6f4373     .DMLongPixelsCom
    a870:	646e616d 6553203a 63612074 74617574     mand: Set actuat
    a880:	2520726f 7420756c 6c25206f 00000075     or %lu to %lu...
    a890:	4d440a0a 676e6f4c 65786950 6f43736c     ..DMLongPixelsCo
    a8a0:	6e616d6d 4e203a64 6170206f 656d6172     mmand: No parame
    a8b0:	73726574 76696720 203b6e65 72657571     ters given; quer
    a8c0:	676e6979 002e2e2e                       ying....

0000a8c8 <BuildTimeStr>:
    a8c8:	20646557 2079614d 32203132 33353a30     Wed May 21 20:53
    a8d8:	2036323a 35323032                        :26 2025.

0000a8e1 <NumBinaryCmds>:
    a8e1:	42000009 72616e69 72655679 6e6f6973     ...BinaryVersion
    a8f1:	6d6d6f43 00646e61 42000000 72616e69     Command....Binar
    a901:	444d4479 6f436361 6e616d6d 42000064     yDMDacCommand..B
    a911:	72616e69 544d4479 6d656c65 79727465     inaryDMTelemetry
    a921:	6d6d6f43 00646e61 42000000 72616e69     Command....Binar
    a931:	444d4479 6f436361 6769666e 6d6d6f43     yDMDacConfigComm
    a941:	00646e61 42000000 72616e69 534d4479     and....BinaryDMS
    a951:	74726174 6f434d53 6e616d6d 42000064     tartSMCommand..B
    a961:	72616e69 4d4d4479 69707061 6f43676e     inaryDMMappingCo
    a971:	6e616d6d 42000064 72616e69 534d4479     mmand..BinaryDMS
    a981:	74726f68 65786950 6f43736c 6e616d6d     hortPixelsComman
    a991:	42000064 72616e69 444d4479 65687469     d..BinaryDMDithe
    a9a1:	6d6f4372 646e616d 42000000 72616e69     rCommand...Binar
    a9b1:	4c4d4479 50676e6f 6c657869 6d6f4373     yDMLongPixelsCom
    a9c1:	646e616d 41000000 63416364 756d7563     mand...AdcAccumu
    a9d1:	6f74616c 53203a72 6c706d61 203a7365     lator: Samples: 
    a9e1:	30312b25 666c302e 28000020 2e257830     %+10.0lf ..(0x%.
    a9f1:	00586c38 25000000 586c382e 2c000029     8lX....%.8lX)..,
    aa01:	6d754e20 75636341 203a736d 20756c25      NumAccums: %lu 
    aa11:	28000000 6c257830 43002958 70617247     ...(0x%lX).CGrap
    aa21:	72655668 6e6f6973 6c796150 3a64616f     hVersionPayload:
    aa31:	72655320 4e6c6169 203a6d75 6c257830      SerialNum: 0x%l
    aa41:	50202c58 65636f72 726f7373 6d726946     X, ProcessorFirm
    aa51:	65726177 6c697542 6d754e64 6c25203a     wareBuildNum: %l
    aa61:	46202c75 46414750 776d7269 42657261     u, FPGAFirmwareB
    aa71:	646c6975 3a6d754e 756c2520 43000000     uildNum: %lu...C
    aa81:	70617247 4d4d4468 69707061 6150676e     GraphDMMappingPa
    aa91:	616f6c79 43203a64 72746e6f 656c6c6f     yload: Controlle
    aaa1:	616f4272 6e496472 3a786564 756c2520     rBoardIndex: %lu
    aab1:	6144202c 646e4963 203a7865 2c756c25     , DacIndex: %lu,
    aac1:	63614420 6e616843 3a6c656e 756c2520      DacChannel: %lu
    aad1:	0a000000 4278540a 72616e69 63615079     .....TxBinaryPac
    aae1:	3a74656b 4c554e20 6150204c 74656b63     ket: NULL Packet
    aaf1:	746e6f43 21747865 68532820 646c756f     Context! (Should
    ab01:	20656220 616e6942 61557972 292a7472      be BinaryUart*)
    ab11:	656c5020 20657361 6f636572 6c69706d      Please recompil
    ab21:	68742065 62207369 72616e69 2e2e2e79     e this binary...
    ab31:	0a000d0a 616e6942 65567972 6f697372     ....BinaryVersio
    ab41:	6d6f436e 646e616d 6553203a 6e69646e     nCommand: Sendin
    ab51:	65722067 6e6f7073 28206573 62207525     g response (%u b
    ab61:	73657479 00203a29 0a000000 616e6942     ytes): .....Bina
    ab71:	46537972 63644132 6d6f4373 646e616d     rySF2AdcsCommand
    ab81:	2000203a 0a00207c 0a000000 616e6942     : . | ......Bina
    ab91:	46537972 63644132 6d6f4373 646e616d     rySF2AdcsCommand
    aba1:	6853203a 2074726f 6b636170 203a7465     : Short packet: 
    abb1:	28207525 74707865 65746365 75252064     %u (exptected %u
    abc1:	74796220 3a297365 0a000020 616e6942      bytes): ...Bina
    abd1:	46537972 63644132 43504673 616d6d6f     rySF2AdcsFPComma
    abe1:	203a646e 20666c25 6c25207c 207c2066     nd: %lf | %lf | 
    abf1:	0a666c25 0a00000a 616e6942 46537972     %lf.....BinarySF
    ac01:	63644132 43504673 616d6d6f 203a646e     2AdcsFPCommand: 
    ac11:	726f6853 61702074 74656b63 7525203a     Short packet: %u
    ac21:	78652820 63657470 20646574 62207525      (exptected %u b
    ac31:	73657479 00203a29 0a000000 616e6942     ytes): .....Bina
    ac41:	4d447972 73636441 6f435046 6e616d6d     ryDMAdcsFPComman
    ac51:	53203a64 74726f68 63617020 3a74656b     d: Short packet:
    ac61:	20752520 70786528 74636574 25206465      %u (exptected %
    ac71:	79622075 29736574 0a00203a 616e6942     u bytes): ..Bina
    ac81:	4d447972 7070614d 43676e69 616d6d6f     ryDMMappingComma
    ac91:	203a646e 61766e49 2064696c 72617453     nd: Invalid Star
    aca1:	78695074 203a6c65 21756c25 0a00000a     tPixel: %lu!....
    acb1:	616e6942 4d447972 7070614d 43676e69     BinaryDMMappingC
    acc1:	616d6d6f 203a646e 72617453 78695074     ommand: StartPix
    acd1:	203a6c65 2c756c25 6d754e20 65786950     el: %lu, NumPixe
    ace1:	203a736c 0a756c25 0a000000 616e6942     ls: %lu.....Bina
    acf1:	4d447972 7070614d 43676e69 616d6d6f     ryDMMappingComma
    ad01:	203a646e 61766e49 2064696c 746e6f43     nd: Invalid Cont
    ad11:	6c6c6f72 42207265 6472616f 726f6620     roller Board for
    ad21:	70616d20 676e6970 756c2520 6c25203a      mapping %lu: %l
    ad31:	000a2175 0a000000 616e6942 4d447972     u!......BinaryDM
    ad41:	7070614d 43676e69 616d6d6f 203a646e     MappingCommand: 
    ad51:	61766e49 2064696c 20636144 626d754e     Invalid Dac Numb
    ad61:	66207265 6d20726f 69707061 2520676e     er for mapping %
    ad71:	203a756c 21756c25 0a00000a 616e6942     lu: %lu!....Bina
    ad81:	4d447972 7070614d 43676e69 616d6d6f     ryDMMappingComma
    ad91:	203a646e 61766e49 2064696c 20636144     nd: Invalid Dac 
    ada1:	6e616863 206c656e 20726f66 7070616d     channel for mapp
    adb1:	20676e69 3a756c25 756c2520 0a000a21     ing %lu: %lu!...
    adc1:	616e6942 4d447972 7070614d 43676e69     BinaryDMMappingC
    add1:	616d6d6f 203a646e 20746553 7070616d     ommand: Set mapp
    ade1:	20676e69 20756c25 00206f74 0a000000     ing %lu to .....
    adf1:	616e6942 4d447972 7070614d 43676e69     BinaryDMMappingC
    ae01:	616d6d6f 203a646e 74706d45 61702079     ommand: Empty pa
    ae11:	74656b63 6572202c 6e727574 20676e69     cket, returning 
    ae21:	72657571 0a000079 616e6942 4d447972     query...BinaryDM
    ae31:	726f6853 78695074 43736c65 616d6d6f     ShortPixelsComma
    ae41:	203a646e 70204d44 746e696f 69207265     nd: DM pointer i
    ae51:	554e2073 20214c4c 6d726946 65726177     s NULL! Firmware
    ae61:	726f6320 74707572 00216465 0a000000      corrupted!.....
    ae71:	616e6942 4d447972 726f6853 78695074     BinaryDMShortPix
    ae81:	43736c65 616d6d6f 203a646e 61766e49     elsCommand: Inva
    ae91:	2064696c 72617453 78695074 203a6c65     lid StartPixel: 
    aea1:	21756c25 0a00000a 616e6942 4d447972     %lu!....BinaryDM
    aeb1:	726f6853 78695074 43736c65 616d6d6f     ShortPixelsComma
    aec1:	203a646e 61766e49 2064696c 7070616d     nd: Invalid mapp
    aed1:	20676e69 3b756c25 656c7020 20657361     ing %lu; please 
    aee1:	6e696572 61697469 657a696c 70616d20     reinitialize map
    aef1:	676e6970 203a2173 0a000000 616e6942     pings!: ....Bina
    af01:	4d447972 7070614d 43676e69 616d6d6f     ryDMMappingComma
    af11:	203a646e 726f6853 61702074 74656b63     nd: Short packet
    af21:	7525203a 78652820 63657470 20646574     : %u (exptected 
    af31:	2075253e 65747962 203a2973 0a000000     >%u bytes): ....
    af41:	616e6942 4d447972 68746944 6f437265     BinaryDMDitherCo
    af51:	6e616d6d 44203a64 6f70204d 65746e69     mmand: DM pointe
    af61:	73692072 4c554e20 4620214c 776d7269     r is NULL! Firmw
    af71:	20657261 72726f63 65747075 0a002164     are corrupted!..
    af81:	616e6942 4d447972 68746944 6f437265     BinaryDMDitherCo
    af91:	6e616d6d 49203a64 6c61766e 53206469     mmand: Invalid S
    afa1:	74726174 65786950 25203a6c 0a21756c     tartPixel: %lu!.
    afb1:	0a000000 616e6942 4d447972 68746944     ....BinaryDMDith
    afc1:	6f437265 6e616d6d 53203a64 74726174     erCommand: Start
    afd1:	65786950 25203a6c 202c756c 506d754e     Pixel: %lu, NumP
    afe1:	6c657869 25203a73 000a756c 0a000000     ixels: %lu......
    aff1:	616e6942 4d447972 68746944 6f437265     BinaryDMDitherCo
    b001:	6e616d6d 49203a64 6c61766e 6d206469     mmand: Invalid m
    b011:	69707061 2520676e 203b756c 61656c70     apping %lu; plea
    b021:	72206573 696e6965 6c616974 20657a69     se reinitialize 
    b031:	7070616d 73676e69 00203a21 0a000000     mappings!: .....
    b041:	616e6942 4d447972 68746944 6f437265     BinaryDMDitherCo
    b051:	6e616d6d 53203a64 61207465 61757463     mmand: Set actua
    b061:	20726f74 20756c25 25206f74 0a00756c     tor %lu to %lu..
    b071:	616e6942 4d447972 7070614d 43676e69     BinaryDMMappingC
    b081:	616d6d6f 203a646e 68746944 70207265     ommand: Dither p
    b091:	656b6361 25203a74 65282075 65747078     acket: %u (expte
    b0a1:	64657463 75253e20 74796220 3a297365     cted >%u bytes):
    b0b1:	0a000020 616e6942 4d447972 676e6f4c      ...BinaryDMLong
    b0c1:	65786950 6f43736c 6e616d6d 44203a64     PixelsCommand: D
    b0d1:	6f70204d 65746e69 73692072 4c554e20     M pointer is NUL
    b0e1:	4620214c 776d7269 20657261 72726f63     L! Firmware corr
    b0f1:	65747075 0a002164 616e6942 4d447972     upted!..BinaryDM
    b101:	676e6f4c 65786950 6f43736c 6e616d6d     LongPixelsComman
    b111:	49203a64 6c61766e 53206469 74726174     d: Invalid Start
    b121:	65786950 25203a6c 0a21756c 0a000000     Pixel: %lu!.....
    b131:	616e6942 4d447972 676e6f4c 65786950     BinaryDMLongPixe
    b141:	6f43736c 6e616d6d 53203a64 74726174     lsCommand: Start
    b151:	65786950 25203a6c 202c756c 506d754e     Pixel: %lu, NumP
    b161:	6c657869 25203a73 000a756c 0a000000     ixels: %lu......
    b171:	616e6942 4d447972 676e6f4c 65786950     BinaryDMLongPixe
    b181:	6f43736c 6e616d6d 49203a64 6c61766e     lsCommand: Inval
    b191:	6d206469 69707061 2520676e 203b756c     id mapping %lu; 
    b1a1:	61656c70 72206573 696e6965 6c616974     please reinitial
    b1b1:	20657a69 7070616d 73676e69 00203a21     ize mappings!: .
    b1c1:	0a000000 616e6942 4d447972 676e6f4c     ....BinaryDMLong
    b1d1:	65786950 6f43736c 6e616d6d 53203a64     PixelsCommand: S
    b1e1:	61207465 61757463 20726f74 20756c25     et actuator %lu 
    b1f1:	25206f74 0a00756c 616e6942 4d447972     to %lu..BinaryDM
    b201:	7070614d 43676e69 616d6d6f 203a646e     MappingCommand: 
    b211:	676e6f4c 63617020 3a74656b 20752520     Long packet: %u 
    b221:	70786528 74636574 3e206465 62207525     (exptected >%u b
    b231:	73657479 00203a29 43000000 70617247     ytes): ....CGrap
    b241:	63615068 4874656b 65646165 53203a72     hPacketHeader: S
    b251:	74726174 656b6f54 30203a6e 586c2578     tartToken: 0x%lX
    b261:	6150202c 616f6c79 70795464 25203a65     , PayloadType: %
    b271:	202c756c 6c796150 4c64616f 203a6e65     lu, PayloadLen: 
    b281:	00756c25 0a000000 6e69420a 20797261     %lu......Binary 
    b291:	74726155 6e49203a 50287469 2048746b     Uart: Init(PktH 
    b2a1:	202c7525 46746b50 29752520 000d0a2e     %u, PktF %u)....
    b2b1:	0a000000 6e69420a 55797261 3a747261     .....BinaryUart:
    b2c1:	66754220 28726566 20297025 7265766f      Buffer(%p) over
    b2d1:	776f6c66 6874203b 70207369 656b6361     flow; this packe
    b2e1:	69772074 6e206c6c 6620746f 28207469     t will not fit (
    b2f1:	62757a25 66202c29 6873756c 20676e69     %zub), flushing 
    b301:	66667562 0a2e7265 0a00000d 6e69420a     buffer.......Bin
    b311:	55797261 3a747261 63615020 2074656b     aryUart: Packet 
    b321:	72617473 65642074 74636574 20216465     start detected! 
    b331:	66667542 6e697265 0d0a2e67 0a000000     Buffering.......
    b341:	6e69420a 55797261 3a747261 69745320     .BinaryUart: Sti
    b351:	77206c6c 69746961 6620676e 7020726f     ll waiting for p
    b361:	656b6361 6e652074 2e2e2e64 0a000d0a     acket end.......
    b371:	6e69420a 55797261 3a747261 63615020     .BinaryUart: Pac
    b381:	2074656b 20646e65 65746564 64657463     ket end detected
    b391:	6f4c203b 6e696b6f 6f662067 616d2072     ; Looking for ma
    b3a1:	69686374 7020676e 656b6361 61682074     tching packet ha
    b3b1:	656c646e 0a2e7372 0a00000d 6e69420a     ndlers.......Bin
    b3c1:	55797261 3a747261 6f685320 70207472     aryUart: Short p
    b3d1:	656b6361 25282074 6220756c 73657479     acket (%lu bytes
    b3e1:	69772029 75206874 6165726e 7473696c     ) with unrealist
    b3f1:	70206369 6f6c7961 6c206461 203b6e65     ic payload len; 
    b401:	6f6e6769 676e6972 726f6320 74707572     ignoring corrupt
    b411:	70206465 656b6361 73282074 6c756f68     ed packet (shoul
    b421:	61682064 62206576 206e6565 64616568     d have been head
    b431:	29287265 70202b20 6f6c7961 25286461     er() + payload(%
    b441:	2029756c 6f66202b 7265746f 0a2e2928     lu) + footer()..
    b451:	0a00000d 6e69420a 55797261 3a747261     .....BinaryUart:
    b461:	6f685320 70207472 656b6361 25282074      Short packet (%
    b471:	6220756c 73657479 77203b29 6c6c2765     lu bytes); we'll
    b481:	73736120 20656d75 20656874 6b636170      assume the pack
    b491:	66207465 65746f6f 61772072 61702073     et footer was pa
    b4a1:	6f207472 68742066 61702065 616f6c79     rt of the payloa
    b4b1:	61642064 61206174 6b20646e 20706565     d data and keep 
    b4c1:	72616573 6e696863 6f662067 68742072     searching for th
    b4d1:	61702065 74656b63 646e6520 68732820     e packet end (sh
    b4e1:	646c756f 76616820 65622065 68206e65     ould have been h
    b4f1:	65646165 20292872 6170202b 616f6c79     eader() + payloa
    b501:	6c252864 2b202975 6f6f6620 28726574     d(%lu) + footer(
    b511:	0d0a2e29 0a000000 65707845 64657463     ).......Expected
    b521:	72655320 4e6c6169 203a6d75 2e257830      SerialNum: 0x%.
    b531:	586c6c38 6150202c 74656b63 72655320     8llX, Packet Ser
    b541:	4e6c6169 203a6d75 2e257830 586c6c38     ialNum: 0x%.8llX
    b551:	0a00000a 6e69420a 55797261 3a747261     .....BinaryUart:
    b561:	6d6e5520 68637461 63206465 616d6d6f      Unmatched comma
    b571:	3020646e 382e2578 2021586c 436d754e     nd 0x%.8lX! NumC
    b581:	3a73646d 756c2520 0a00000a 6e69420a     mds: %lu.....Bin
    b591:	55797261 3a747261 63615020 2074656b     aryUart: Packet 
    b5a1:	65636572 64657669 7562202c 65532074     received, but Se
    b5b1:	6c616972 626d754e 63207265 61706d6f     rialNumber compa
    b5c1:	6f736972 6166206e 64656c69 78652820     rison failed (ex
    b5d1:	74636570 203a6465 2e257830 3b586c38     pected: 0x%.8lX;
    b5e1:	746f6720 7830203a 6c382e25 0a2e2958      got: 0x%.8lX)..
    b5f1:	0a00000d 6e69420a 55797261 3a747261     .....BinaryUart:
    b601:	63615020 2074656b 65636572 64657669      Packet received
    b611:	7562202c 6e692074 696c6176 0d0a2e64     , but invalid...
    b621:	0a000000 6e69420a 20797261 74726155     .....Binary Uart
    b631:	6553203a 6e69646e 61702067 74656b63     : Sending packet
    b641:	2c752528 29752520 2500203a 3a58322e     (%u, %u): .%.2X:
    b651:	0a000000 25000000 322e2563 0a000078     .......%c%.2x...
    b661:	41475046 74726155 6c6c6143 6b636162     FPGAUartCallback
    b671:	4e203a73 284c4c55 20297525 61766e49     s: NULL(%u) Inva
    b681:	5064696c 656b6361 0a0a2174 0a000000     lidPacket!......
    b691:	41475046 74726155 6c6c6143 6b636162     FPGAUartCallback
    b6a1:	49203a73 6c61766e 61506469 74656b63     s: InvalidPacket
    b6b1:	6f632021 6e65746e 203a7374 0a00003a     ! contents: :...
    b6c1:	6b636f53 61557465 61437472 61626c6c     SocketUartCallba
    b6d1:	3a736b63 4c554e20 7525284c 6e552029     cks: NULL(%u) Un
    b6e1:	646e6148 5064656c 656b6361 0a0a2174     HandledPacket!..
    b6f1:	0a000000 41475046 74726155 6c6c6143     ....FPGAUartCall
    b701:	6b636162 55203a73 6e61686e 64656c64     backs: Unhandled
    b711:	63617020 2874656b 3a297525                packet(%u): ..

0000b720 <vtable for RTSCallback>:
	...
    b728:	00006853 00006869 00006889              Sh..ih...h..

0000b734 <vtable for FPGABinaryUartCallbacks>:
	...
    b73c:	00006721 00006745 00006765 000067e5     !g..Eg..eg...g..
    b74c:	000058ed 0000683d                       .X..=h..

0000b754 <vtable for uart_pinout_fpga>:
	...
    b75c:	000065c5 000065e9 00006609 0000663d     .e...e...f..=f..
    b76c:	00006699 000066c5 000066d7 000066e9     .f...f...f...f..

0000b77c <vtable for BinaryUart>:
	...
    b784:	00006919 0000693d 00005a8d 000063d5     .i..=i...Z...c..

0000b794 <vtable for BinaryUartCallbacks>:
	...
    b79c:	00005881 000058a1 000058c1 000058d7     .X...X...X...X..
    b7ac:	000058ed 00005903                       .X...Y..

0000b7b4 <vtable for IUartParser>:
	...

0000b7c8 <vtable for IUart>:
	...

0000b7f0 <vtable for CGraphPacket>:
	...
    b7f8:	00005431 00005455 00005475 000054c1     1T..UT..uT...T..
    b808:	000054fd 00005511 00005525 00005539     .T...U..%U..9U..
    b818:	0000558b 00005649 0000554f 00005569     .U..IV..OU..iU..
    b828:	000055bf 00005607 000056e9              .U...V...V..

0000b834 <vtable for IPacket>:
	...

0000b878 <_ctype_>:
    b878:	20202000 20202020 28282020 20282828     .         ((((( 
    b888:	20202020 20202020 20202020 20202020                     
    b898:	10108820 10101010 10101010 10101010      ...............
    b8a8:	04040410 04040404 10040404 10101010     ................
    b8b8:	41411010 41414141 01010101 01010101     ..AAAAAA........
    b8c8:	01010101 01010101 01010101 10101010     ................
    b8d8:	42421010 42424242 02020202 02020202     ..BBBBBB........
    b8e8:	02020202 02020202 02020202 10101010     ................
    b8f8:	00000020 00000000 00000000 00000000      ...............
	...
    b978:	45455200 6d20544e 6f6c6c61 75732063     .REENT malloc su
    b988:	65656363 00646564 775f5f2f 6d72612f     cceeded./__w/arm
    b998:	6e6f6e2d 61652d65 672d6962 782d6363     -none-eabi-gcc-x
    b9a8:	6b636170 6d72612f 6e6f6e2d 61652d65     pack/arm-none-ea
    b9b8:	672d6962 782d6363 6b636170 6975622f     bi-gcc-xpack/bui
    b9c8:	612d646c 74657373 75622f73 2f646c69     ld-assets/build/
    b9d8:	336e6977 36782d32 6f732f34 65637275     win32-x64/source
    b9e8:	656e2f73 62696c77 6779632d 2f6e6977     s/newlib-cygwin/
    b9f8:	6c77656e 6c2f6269 2f636269 69727473     newlib/libc/stri
    ba08:	732f676e 6f747274 00632e6b 7566202c     ng/strtok.c., fu
    ba18:	6974636e 203a6e6f 73736100 69747265     nction: .asserti
    ba28:	22206e6f 20227325 6c696166 203a6465     on "%s" failed: 
    ba38:	656c6966 73252220 6c202c22 20656e69     file "%s", line 
    ba48:	73256425 000a7325 004c6c68 2b302d23     %d%s%s..hlL.#-0+
    ba58:	66650020 47464567 32313000 36353433      .efgEFG.0123456
    ba68:	41393837 45444342 31300046 35343332     789ABCDEF.012345
    ba78:	39383736 64636261 41006665 2d61462d     6789abcdef.A-Fa-
    ba88:	30393866 34333231 5d373635 002d2b00     f8901234567].+-.
    ba98:	78003030 00000058 0000ba95 0000ba98     00.xX...........
    baa8:	0000ba9b                                ....

0000baac <_init>:
    baac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    baae:	bf00      	nop
    bab0:	bcf8      	pop	{r3, r4, r5, r6, r7}
    bab2:	bc08      	pop	{r3}
    bab4:	469e      	mov	lr, r3
    bab6:	4770      	bx	lr

0000bab8 <_fini>:
    bab8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    baba:	bf00      	nop
    babc:	bcf8      	pop	{r3, r4, r5, r6, r7}
    babe:	bc08      	pop	{r3}
    bac0:	469e      	mov	lr, r3
    bac2:	4770      	bx	lr

0000bac4 <__frame_dummy_init_array_entry>:
    bac4:	04d5 0000 308d 0000 4345 0000 52b1 0000     .....0..EC...R..
    bad4:	6b09 0000                                   .k..

0000bad8 <__do_global_dtors_aux_fini_array_entry>:
    bad8:	04b1 0000 6b13 0000                         .....k..
